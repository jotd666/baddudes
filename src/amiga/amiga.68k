*
*	Amiga-specific portions of Bad Dudes vs Dragonninja (AGA version)
*
* (c) JOTD 2025 (hopefully not 2026 as well!)
*
* music modules by no9



.include "custom.i"
.include "exec_lvos.i"
.include "dos_lvos.i"
.include "graphics_lvos.i"
.include "baddudes.inc"
.include "sounds.inc"

AttnFlags = 0x128
AFB_68010 = 0
AFB_68020 = 1

	.ifdef	RELEASE
	.macro	TMPBREAK
	.error  "stray TMPBREAK macro"
	.endm
	.macro	TMPWRITE
	.error  "stray TMPWRITE macro"
	.endm
	.else
	.macro	TMPBREAK
	BREAKPOINT	"work breakpoint"
	.endm
	.macro	TMPWRITE
	move.b	#0,0x100		| 0x100 is used but only for exceptions
	.endm
	.endif
	
TOTAL_PUBLIC_MEMORY_SIZE = 350000
* this is the minimum memory required for level 5 (because of train)
* if memory is lower than that, it loads, no memory issues detected but
* the background is trashed...
TOTAL_CHIP_MEMORY_SIZE = 1350000	

PREVIOUS_SPRITE_SIZE = 8
BORDERBLANK = 1

* how negative we can tolerate before clipping
* some bobs are grouped up to 64 pixels wide, we
* don't want them clipped on the left
CLIPPED_WIDTH_MARGIN = 64

SPRITE_X_CORRECTION = 0
SPRITE_Y_CORRECTION = 0
HW_SPRITE_X_CORRECTION = 0
HW_SPRITE_Y_CORRECTION = 0

SCROLL_NONE = 0
SCROLL_DOWN = 4
SCROLL_UP = 16

* level 5 top part of lead wagon
MIN_TRAIN_X_TOP_DRAW = 0x140


* 3 & 3: most performant
BITPLANE_FMODE = 3			| works with 1, albeit slower
SPRITE_FMODE = 3			| required!!

	.ifeq	BITPLANE_FMODE-3
* bitplane fmode = 3 needs this
HW_SPRITE_SHIFT = 32
	.else
	.ifeq	BITPLANE_FMODE-1
HW_SPRITE_SHIFT = 0
	.else
	.error	"unsupported BITPLANE_FMODE"
	.endif
	.endif
	
Y_WATER_MIN = 224
Y_MAX = 240
Y_MAX_SPRITE = 256
ONE_FULL_16_BIT_ROW = 3*Y_MAX_SPRITE*2

BASE_BPLCON3_VALUE = (BORDERBLANK<<5)
BASE_BPLCON2_VALUE = 0x0264  | killehb (we're using 6 real bitplanes) sprites above all playfields
SPRITES_BELOW_BPLCON2_VALUE = 0x0210  | killehb (we're using 6 real bitplanes) sprites above all playfields
BASE_BPLCON4_VALUE = 0x0045	| even sprites palette starts at color 64, odd at 80
SCREEN_ADDRESS = 0x244000

* set both to nonzero for full static screen, no scroll, 1 screen tile
OPT_NO_SCROLLING_X = 0
OPT_NO_SCROLLING_Y = 0
OPT_NO_BOTTOM_SCROLL = 0
OPT_DEBUG_GAP_ERASE = 1

* load fixed sprites, mostly bosses as they're long to reach & test
OPT_BOSS_SPRITES_MOCKUP = 0

* if the alloc_sprite & update_sprite routines
* are reused, changing those offsets can make
* a quick reuse from game to game as most sprite
* RAMs have 4 bytes per sprite, only the order
* and some bits differ

TARGET_SPRITE_Y = 0
TARGET_SPRITE_X = 4
TARGET_SPRITE_CODE = 2
TARGET_SPRITE_SIZE = 8

	.ifdef	RELEASE
OPT_ENABLE_PROFILING = 0         | DO NOT CHANGE THIS
OPT_ENABLE_LOGGING = 0           | DO NOT CHANGE THIS
ONE_TICK = 1
	.else
OPT_ENABLE_LOGGING = 1
OPT_ENABLE_PROFILING = 0
* set to higher values than 1 to speed game up
ONE_TICK = 1


	.endif
	
* note: double buffering eats a lot of memory, it cannot run in debug mode
* either simple or reloc. Only in "none" (program running in fastmem, data
* located in low chipmem)
OPT_ENABLE_DOUBLE_BUFFERING = 1

_custom = 0xDFF000


* background scrolls (in-game)
* foreground is static and contains bobs

NB_PLAYFIELD_PLANES = 6
NB_BYTES_PER_SCREEN_ROW = 32
NB_BYTES_PER_ROW = (NB_BYTES_PER_SCREEN_ROW*3)+8   | add 64 extra pixels to clip properly


PROGRAM_SIZE = 0x60000



NB_PLAYFIELD_LINES = 256

* the screen plane size is pretty huge, so the offset can go beyond 0x8000 and
* the word add on address registers won't work
SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES*2
RESTORE_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES*2
SCREEN_SIZE =  SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES


NB_HOST_SPRITES = 8

* MAME driver uses 0x800 bytes of sprite ram, 8 bytes per sprite, let's hope
* that the game doesn't use them all!
NB_TARGET_SPRITES = 256

SPRITE_X = 0
SPRITE_Y = 1
SPRITE_CODE = 2
SPRITE_CLUT = 3
SPRITE_SIZEOF = 4

NB_BYTES_PER_SPRITE_ROW = 8   | fmode=3: 64 pixels wide sprites!

.macro	GET_RAM_START_IN_A6	
	.ifdef	RELEASE
	lea		ram_buffer,a6
	.else
	move.l		ram_start_ff8000,a6
	.endif
	.endm
	
.macro	WAIT_BLIT
	move.w	#0x8400,(dmacon,a5)		| blitter high priority
wait\@:
	BTST	#6,(dmaconr,a5)
	BNE.S	wait\@
	move.w	#0x0400,(dmacon,a5)		| blitter normal priority
.endm

.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm

.macro	DECL_BITPLANES	bpoff_start,nb_planes
	.set	bpoff,\bpoff_start
	.rept	\nb_planes
	dc.w  bplpt+bpoff,0
	dc.w  bplpt+bpoff+2,0
	.set	bpoff,bpoff+4
	.endr
	.endm

.macro	DECL_COLOR_BANK	bankno
	.word	bplcon3,BASE_BPLCON3_VALUE+(\bankno<<13)
	.endm
	
.macro	DECL_COLORS	offset,nb_colors
	.set	colidx,\offset
	.rept	\nb_colors
	dc.w	color+(colidx*2),0
	.set	colidx,colidx+1
	.endr
	.endm

.macro	DECL_SPRITES	nb_sprites
	.rept	\nb_sprites*2
	* 2 slots
	.word	0x1FE,0
    .endr
	.endm
* debug macro that colors the screen until LMB pressed
.macro 	blitz_bypass
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* same thing but if LMB is pressed when entering, macro waits for release)
.macro blitz
w\@:
	btst	#6,0xbfe001
	beq.b	w\@
	blitz_bypass
.endm

	.macro	NEXT_SPRITE_OFFSET
	.set	offset,offset+NB_BYTES_PER_SPRITE_ROW*2	
	.endm
	
	.macro	CLEAR_SPRITE_TILE_ROW
	clr.b	(offset,a3)
	.set	offset,offset+NB_BYTES_PER_SPRITE_ROW	
	.endm
	
	* < A0: first tile plane
	* < A1: second tile plane
	* < A3: sprite data
	.macro	COPY_SPRITE_TILE_ROW
	move.b	(a0)+,d0
	move.b	d0,(offset,a3)
	move.b	(a1)+,d0
	move.b	d0,(NB_BYTES_PER_SPRITE_ROW+offset,a3)
	NEXT_SPRITE_OFFSET
	.endm
	

start:
	move.l	a7,old_stack
	bra	_user
    
	

* exports

	.global		_user
	.global		_player_start
	.global		_demo_end
	.global		_resload
	.global		_dosbase
	.global		cheat_used
* osd layer		
	.global		osd_flush_caches
	.global		osd_install_trap
	.global		osd_break
	.global		osd_real_ram_address
	.global		osd_read_byte
	.global		osd_read_word
	.global		osd_read_long
	.global		osd_write_byte
	.global		osd_write_word
	.global		osd_write_long
	.global		osd_enable_interrupts
	.global		osd_set_context
	
	.include	"ReadJoypad.i"
	.include	"whdload_funcs.i"
		.text



	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
	move.b	d1,_keyexit
    move.l a0,_resload

	move.l	a0,a2
	lea	(_tag,pc),a0
	jsr	(resload_Control,a2)
	
	
	.ifndef	RELEASE
	* install quit handler 
	move.l	#quit_to_os,0x4	
	.endif

	

   jra		.no_forbid
.standard:
	
    * open dos library, graphics library
    move.l  0x4.W,a6
    lea dosname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_dosbase

	lea	read_args_string,a0
	lea	program_args,a1
	move.l	#program_args_end-program_args,d0
	lsr.l	#2,d0		| number of longs
	

	jbsr	get_args_BCPL

0:	
	lea		program_args,a0

	move.l	(A0)+,D0	| INVINCIBLE/S
	beq.b	1f
	or.l	#1,cheat_flags
	st.b	cheat_used
1:
	move.l	(A0)+,D0	| INFLIVES/S
	beq.b	2f
	or.l	#2,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| SECTORSELECT/S
	beq.b	2f
	or.l	#8,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| CHEATKEYS/S
	beq.b	2f
	* cheat isn't used as long as no cheat key is used
	or.l	#0x10,cheat_flags
2:

	move.l	(A0)+,D0	| STARTLEVEL/K/N
	beq.b	2f
	jbsr		bcpl_string_to_int
	move.l	d0,dip_switch_start_level
2:
	move.l	(A0)+,D0	| STARTLIVES/S
	beq.b	2f
	jbsr		bcpl_string_to_int
	subq.b	#1,d0
	bmi.b	2f
	move.l	d0,dip_switch_start_lives
	bra.b	3f
2:
	move.l	#2,dip_switch_start_lives		| 3 lives default
3:


	lea		_custom,a5
	lea		debug_copperlist,a0
	move.l	a0,cop1lc(a5)

* no multitask
	
	move.l	4.W,A6
	lea graphicsname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_gfxbase
    move.l	d0,a6
	move.l	38(a6),old_syscoplist
	move.l	34(A6),old_actiview		| gb_ActiView

	sub.l	a1,a1
	jsr	_LVOLoadView(a6)
	jsr	_LVOWaitTOF(a6)
	jsr	_LVOWaitTOF(a6)
	
	jbsr		load_highscores
    * check if "floppy" file is here
    move.l  _dosbase,a6
    move.l   #floppy_file,d1
    move.l  #1005,d2   | MODE_OLDFILE
    jsr     _LVOOpen(a6)
    move.l  d0,d1
    beq.b   .no_floppy
    * "floppy" file found
    jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    move.l  #100,d1
    jsr     _LVODelay(a6)
.no_floppy:

* no multitask
	
    move.l  4,a6
    jsr _LVOForbid(a6)

    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	move.l	#-1,184(A0)	| pr_WindowPtr: no more system requesters (insert volume, write protected...)

.no_forbid:

	* init tables for sprites with some used heights
	jbsr		init_sprite_y_table_table
	
	* align bitplanes
	lea		fg_screen_buffer_1,a0
	jbsr		align_for_fmode
	move.l	a0,fg_screen_data_1
	move.l	a0,fg_drawed_screen_ptr
	move.l	a0,fg_displayed_screen_ptr
	
	
	lea		fg_screen_buffer_2,a0
	jbsr		align_for_fmode
	move.l	a0,fg_screen_data_2
	
	lea		_custom,a5
	
	
	
	move.l	frameskip_flag,d0
	jne		0f
	moveq	#1,d0		| auto, starts with full fps
0:
	move.b	d0,graphics_update_counter_start
	move.b	d0,graphics_update_counter

* ALL DIP SWITCHES ARE WRONG ATM

	move.l	dip_switch_start_level,d0
	move.b	d0,start_level
	
	moveq	#0,d1
	move.b	dip_switch_start_lives+3,d1
	bne.b	1f
	moveq	#3,d1	| 3 lives is default
1:
	* DSW 0 = 2 lives
*	move.b	(a0,d1.w),d0
*	not.b	d0
*	move.b	d0,dip_switches_1
	
	.ifdef	RELEASE
	moveq	#0,d1
	.else
	move.l	debug_options,d1
	.endif

	* load game ROM
	lea		rom_file,a0

	cmp		#1,d1
	jne		0f
	* simple debug mode requires exe loaded in 0
	sub.l	a1,a1
	jra		1f
0:
	* normal program load
	lea	program_space,a1
	.ifndef	RELEASE
	* align ROM when debugging (those fastmem addresses are a bitch)
	move.l	a1,d1
	tst		d1
	jeq		0f	| just in case (very unlikely!!)
	clr		d1
	swap	d1
	addq	#1,d1
	swap	d1
	move.l	d1,a1
0:
	.endif
1:
	move.l	a1,rom_base
	move.l	_resload,a2
	jsr	(resload_LoadFileDecrunch,a2)

	

	move.l	cheat_flags,d0
	btst	#0,d0
	beq.b	0f
	st		cheat_used
	st		invincible_flag
0:
	btst	#1,d0
	beq.b	0f
	st		infinite_lives_flag
	st		cheat_used
0:
	btst	#2,d0
	beq.b	0f
	st		infinite_time_flag
	st		cheat_used
0:
	move.l	cheat_flags,d0
	btst	#3,d0
	beq.b	0f
	st		cheat_used
0:
	
	jsr	 _detect_controller_types 
	clr.b	controller_joypad_0
	clr.b	controller_joypad_1

	jra		demo_game


* so memory is quadword-aligned (not trusting .align directives)
align_for_fmode:
	add.w	#0x8,a0
	move.l	a0,d0
	and.b	#0xF8,d0
	move.l	d0,a0
	rts

	
* < D0: bcpl string (with leading size byte)
* < A1: dest C string
bcpl_arg_string_copy:
    movem.l D0-D2/A0-A1,-(a7)
	lsl.l	#2,d0
	moveq.l	#0,d2
    move.l  d0,a0
	move.b	(a0)+,d2	| size
	beq.b	1f
	subq	#1,d2
0:
	move.b	(a0)+,(a1)+
	dbf		d2,0b
1:
    movem.l (a7)+,D0-D2/A0-A1
    rts


bcpl_string_to_int:
    movem.l A0/A1,-(a7)
    lea temp_filename_buffer,a1
    jbsr bcpl_arg_string_copy
    * convert to integer
    move.l  a1,a0
    * < A0: pointer on C string
    * > D0: value
    * > D1: -1 if ok, position of the string if error
    jbsr parse_integer
    movem.l  (a7)+,a0/a1
	rts
	
* parse integer from string
* < A0: pointer on C string
* > D0: value
* > D1: -1 if ok, position of the string if error
parse_integer:
    movem.l  d2/d3,-(a7)
    * go to end of string
    moveq.l #-1,d1
.loop1:
    addq.l  #1,d1
    tst.b   (a0,d1.w)
    bne.b   .loop1
    * d1 is the number of chars
    moveq.l #0,d0
    moveq.l #0,d2
    subq.l  #2,d1   | 10th power minus 1
.loop2:
    move.b  (a0)+,d2
    beq.b   .out
    
    cmp.b   #32,d2
    beq.b   .skip
    sub.b   #48,d2
    bcs.b   .error
    cmp.b   #10,d2
    bcc.b   .error
    move.w  d1,d3
    bmi.b   .doadd
.muloop:
    mulu    #10,d2
    dbf d3,.muloop
.doadd:
    add.l   d2,d0
.skip:
    subq.l  #1,d1
    bra.b   .loop2
.out:    
    movem.l  (a7)+,d2/d3
    rts
.error:
    moveq.l #0,d0
    bra.b   .error
	
    * thanks Toni for this 1.3 read argument code
BCPL_RdArgs = 78
	
	* a1 = pointer to result array. Must be LONG aligned!
	* a0 = formatting string. BSTR!
	* d0 = size of result array (number of LONGs)
get_args_BCPL:
	movem.l d2/d3/d4,-(sp)
	move.l d0,d3
	moveq #BCPL_RdArgs,d0
	move.l a0,d1
	lsr.l #2,d1
	move.l a1,d2
	lsr.l #2,d2
	moveq #0,d4
	jbsr call_bcpl
	movem.l (sp)+,d2/d3/d4
	rts

	* d0 = gv index
	* d1-d4 = bcpl parms

BCPL_STACK = 3000

call_bcpl:
	movem.l d2-d7/a2-a6,-(sp)

	move.l d0,d6
	move.l d1,d5

	move.l 4.w,a6
	move.l	_dosbase,a5


	sub.l a1,a1
	jsr	_LVOFindTask(a6)
	move.l d0,a4

	* allocate BCPL stack
	move.l #BCPL_STACK,d0
	move.l #65536+1,d1
	jsr	_LVOAllocMem(a6)
	move.l d0,d7
	beq.s 0f
	
	movem.l d7/a5/a6,-(sp)

	moveq #0,d0
	move.l d5,d1
	sub.l a0,a0
	move.l d7,a1
	lea 3*4(a1),a1
	move.l 136(a4),a2
	move.l 0(a2,d6.w*4),a4
	movem.l 46(a5),a5/a6
	jsr (a5) | call bcpl!
	
	movem.l (sp)+,d7/a5/a6

0:
	move.l d7,a1
	move.l #BCPL_STACK,d0
	jsr	_LVOFreeMem(a6)


	movem.l (sp)+,d2-d7/a2-a6
	rts



	

demo_game:

	* init dynamic memory blocks
	jbsr	free_all_memory
	
	move.w	#CTX_INTRO,d0
	jbsr	osd_set_context
	
	move		#0x4000,_custom+intena						| disable interrupts
	move		#0x7FFF,_custom+intreq						| ack all interrupts
	jbsr			platform_init					| amiga-specific init
		
0:	

	
	* compute ram start
	lea		ram_buffer,a6
	.ifndef	RELEASE
	* align so real addresses are $xxxx8yyyy
	* and lower 16-bit match original RAM offsets
	move.l	a6,d0
	clr.w	d0
	add.l	#0x18000,d0
	move.l	d0,a6
	move.l	a6,ram_start_ff8000
	.endif

	move.l	a6,ram_base
	
	.ifndef	RELEASE
	* log rom/ram start in zero page
	move.l	rom_base,0xF0
	move.l	ram_base,0xF4
	.endif
	
	*lea		stack_top,a7
	jmp			baddudes_reset					| pass control to the mpatrol core
		
	
* just in case some hardware calls nmi
_nmi:
	move.w	#0x7FFF,_custom+intreq
	move.w	#0x7FFF,_custom+intreq
	rts
	
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	lea		_custom,a5
	move.w	(intreqr,a5),d0
	btst	#5,d0
	beq.b		1f
	
	move.l	_joypad_state,d1
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state
	
	* CD32 "play" is disabled but it's free to read
	* 3rd button on a Sega 3-button so 3rd button is pause
	btst	#JPB_BTN_PLAY,d0
	beq.b	0f
	btst	#JPB_BTN_PLAY,d1
	bne.b	0f
	jbsr		toggle_pause
0:
	* here music doesn't loop. We have to stop it when it ends
	move.w	music_tick,d1
	beq.b	13f
	
	subq	#1,d1

	move.w	d1,music_tick
	bne.b	13f
	jbsr		osd_music_stop
13:
	
	* ack vbl twice (040/pistorm bug)
	move.w	#0x20,(intreq,a5)
	move.w	#0x20,(intreq,a5)	
	jra	3f
1:
	* has to be copper
	* is level 1 interrupt set? that would mean that mid-screen interrupt
	* is the source of the interrupt
	btst	#2,d0
	sne		mid_screen_interrupt

	* we're going to ack copper & software interrupt now
	* do it twice (040/pistorm bug)
	move.w	#0x14,(intreq,a5)
	move.w	#0x14,(intreq,a5)

	* set base for RAM
	GET_RAM_START_IN_A6
	btst	#2,d0
	beq.b	2f
	* mid-screen copper interrupt, must occur once every 5 times
	* to simulate ~60 Hz on 50 Hz display
	move.b	mid_screen_interrupt_count,d0
	addq.b	#1,d0
	cmp.b	#5,d0
	bne.b	1f
	* declare that we're in interrupt mode so osd_disable_interrupts/osd_enable_interrupts
	* also set SR accordingly
	st.b	interrupt_mode
	jbsr		baddudes_irq
	clr.b	interrupt_mode	
	clr.b	d0
1:
	move.b	d0,mid_screen_interrupt_count
	jra		3f
2:

	

	
	tst.b	pause_flag
	jne	23f

	subq.w	#1,delay_timer
		
	* declare that we're in interrupt mode so osd_disable_interrupts/osd_enable_interrupts
	* also set SR accordingly
	st.b	interrupt_mode
	jbsr		baddudes_irq
	clr.b	interrupt_mode

	move.w	display_dudes,d0
	jeq		1100f
	
	cmp.w	#1,display_dudes
	jeq		1101f
	move.w	D0,-(a7)
	* restore background
* what: blits data on bg plane, no horizontal shifting (erase)
* args:
* < A0: pristine background
* < A1: dest buffer
* < D0: X (rounded to smaller 8-multiple)
* < D1: Y
* < D2: width in bytes
* < D4: height

	move.l	dude_pics,a2
	move.l	(a2),a2		| first dude struct data

	move.l	fg_drawed_screen_ptr,a1
	move.l	background_restore_buffer,a0
	move.w	(a2)+,d0			| X
	move.w	(a2)+,d1			| Y
	move.w	(a2)+,d2			| width
	lsr.w	#3,d2				| divide by 8 to get len in bytes
	move.w	(a2)+,d4			| height
	jbsr	restore_background
	lea	(SCREEN_PLANE_SIZE,a1),a1
	* remaining planes need to be simply cleared
	* when exiting from restore_background, A1 points
	* to the exact next erase position so D0=0, D1=0 here
	move.w	nb_tile_planes_24da,d3
	neg.w	d3
	addq.w	#NB_PLAYFIELD_PLANES,d3
	moveq	#0,d0
	moveq	#0,d1
	lea		_custom,a5
	jbsr	clear_fg_planes_any_blitter_internal
	move.w	(a7)+,d0
1101:
	
	* set dudes palette
	move.l	dude_pics,a2
	move.l	(-4,a2,d0.w*4),a2		| requested dude struct
	lea		(8,a2),a0			    | palette (maybe different for both pics)
	lea		dudes_palette,a1
	move.w	#24,d0
	jbsr	load_palette

	move.l	fg_drawed_screen_ptr,a1
	move.w	(a2)+,d0			| X
	move.w	(a2)+,d1			| Y
	move.w	(a2)+,d2			| width
	lsr.w	#3,d2				| divide by 8 to get len in bytes
	move.w	#4,d3				| 4 bitplanes in cookie cut mode
	move.w	(a2)+,d4			| height
	moveq	#0,d5				| no clipping
	lea		(0x40,a2),a0		| pic planes
	move.l	(6*4,a0),a3			| mask plane
	movem.l	D0-D5/A1/A2,-(a7)
	moveq	#0,d6
	jbsr	blit_planes_any_internal_cookie_cut
	movem.l	(a7)+,D0-D5/A1/A2
	lea		(0x50,a2),a0			| pic remaining planes
	move.w	#2,d3				| 4 bitplanes in non cookie cut mode
	lea		(SCREEN_PLANE_SIZE*4,a1),a1
	jbsr	blit_planes_any_internal_no_cookie_cut
	
	clr.w	display_dudes
	* we have to wait for blitter, as 8x8 font engine uses cpu only
	lea		_custom,a5
	WAIT_BLIT
	
1100:

	subq.b	#1,graphics_update_counter
	jne		23f

	eor.b	#1,flashing_flip_flop

	move.b	graphics_update_counter_start,graphics_update_counter
	

	tst.b	clear_target_sprites_flag
	jeq		24f
	clr.b	clear_target_sprites_flag
	* remove all remaining sprites to avoid conflicts with new loaded sprites
	GET_RAM_START_IN_A6
	cmp.l	#0,a6
	jeq		24f		| ram is not initialized yet!
0:
	lea	(0x4000,a6),a0		| sprites
	move.w	#NB_TARGET_SPRITES-1,d1
0:
	clr.l	(a0)+
	clr.l	(a0)+
	dbf	d1,0b

24:
	tst.b	level_7_load_second_part_flag
	jeq		25f
	jbsr	level_7_load_second_part
25:
	tst.l	sprite_table_base
	jeq		1f			| no sprites? don't update
	jbsr	really_update_sprites
1:
	* don't blit, but update hw sprites as it doesn't cost a lot
	cmp.w	#CTX_GAME,global_context
	jcs		23f
	* double buffering only in-game
	jbsr		switch_screen_buffers
23:
	.ifndef		RELEASE
	tst.b	debug_truck_control
	jeq		1f
	move.w	debug_truck_move,d0
	jeq		0f
	add.w	d0,x_secondary_scroll_value
	clr.w	debug_truck_move
0:
	and.w	#0x3FF,x_secondary_scroll_value
	
	* display test boss energy
	lea		boss_life,a0
	lea		0x244758,a6
0:
	move.w	(a0)+,d7
	jeq		1f
	jbsr	osd_write_word
	addq	#2,a6
	jra	0b
1:
	tst.b	debug_scroll_display
	jeq		2f
	* copy truck scroll value
	move.w	x_secondary_scroll_value,d0
	lea		debug_truck_message(pc),a0
	jbsr	encode_debug_message
	jbsr	osd_write_right_debug_message
	moveq	#0,d0
	move.w	y_background_scroll_value,d0
	swap	d0
	lsr.l	#4,d0
	or.w	x_background_scroll_value,d0
	lea		debug_scroll_message(pc),a0
	jbsr	encode_debug_message
	jbsr	osd_write_left_debug_message
2:
	.endif

3:
    movem.l (a7)+,d0-d7/a0-a6
    rte

encode_debug_message:
	move.l	a0,-(a7)
	add.w	#11,a0
	lea		hex_table(pc),a1
	moveq	#0,d1
	moveq	#2,d3
0:
	move.b	d0,d1
	and.b	#0xF,d1
	move.b	(a1,d1.W),D2
	move.b	d2,-(a0)
	move.b	d0,d1
	lsr.b	#4,d1
	move.b	(a1,d1.W),D2
	
	move.b	d2,-(a0)
	lsr.l	#8,d0
	dbf		d3,0b
	move.l	(a7)+,a0
	rts
	

	
hex_table:
	.byte	0x30
	.byte	0x31
	.byte	0x32
	.byte	0x33
	.byte	0x34
	.byte	0x35
	.byte	0x36
	.byte	0x37
	.byte	0x38
	.byte	0x39
	.byte	0x41
	.byte	0x42
	.byte	0x43
	.byte	0x44
	.byte	0x45
	.byte	0x46
	
update_front_objects:
	* level 1/2: scan for front objects
	move.w 	front_objects_x_scroll,d5		| X start
	lea		video_ram_244000,a0	| bottom of object Y at scroll = 0

	move.w	#0x3F,d7
	move.w	#32,d6		| current X (without scroll)
	moveq	#0,d3		| sprite slot
	moveq 	#0,d4
0:
	* X/Y (Y fixed to 0x1B) => screen address (not linear, there are 4 pages)
	move.w	d5,d0
	and.w	#0x300,d0
	lsl.w	#2,D0		| times 4, 0x800 per scroll page, we multiply after
	move.b	d5,d4		| lower part
	lsr.w	#3,d4		| divide to get byte offset
	add.w 	d4,d0
	add.w	d0,d0		| multiply by 2, 2 bytes per 8x8 tile
	add.w	#0x6C0,d0	| offset with Y=0x1B
	and.w	#0x1FFF,d0	| wrap
	move.w 	(a0,d0.w),d1
	jeq		1f
	
	* found a non-zero tile
	cmp.w	#0x4227,d1
	jeq		5f
	cmp.w	#0x623B,d1
	jne		4f
	* meter
	moveq	#3,d2
	jra		3f
4:
	cmp.w	#0x522F,d1
	jne		4f
	* fire hydrant
	moveq	#0,d2
	jra		3f
5:
	* lamp, but which one?
	move.w	(-0x442,a0,d0.w),d1
	moveq	#1,d2		| lamp
	cmp.w	#0x3212,d1
	jne		3f
	moveq	#2,d2		| lamp with sign
3:
	move.w	d6,d0
	move.w 	front_objects_x_scroll,d1
	and.w	#0x7,d1		| fine scroll offset must be reversed
	sub.w	d1,d0
	jmi		2f
	jbsr	display_front_object
	addq.w	#1,d3		| next sprite slot
2:

1:
	addq	#8,d5		| next X
	addq	#8,d6
	dbf		d7,0b
	
	* zero out the unused sprite slots
	moveq	#-1,d2
1:
	cmp.w	#4,d3
	jeq		1f
	jbsr	display_front_object
	addq	#1,d3
	jra		1b
1:	
	rts
	
* truck_erase erase_truck
* complete nightmare to do properly given
* that we're trying to avoid erasing the parts
* that don't need erasing (huge trailer rectangles)
* and also it scrolls...

erase_big_machine:
	tst.b	truck_previously_drawn
	jeq		0f

	* truck: amounts to roughly 12 objects ?
	add.b	#12,nb_erased_objects

	* we cannot just restore the whole truck background, it's
	* inefficient and makes the game crawl. Just restore parts
	* that won't be immediately overwritten by the truck/train itself
	* again (which is pretty rectangular and moves only to the right)
	

	lea		specific_big_machine_restore,a0
	jbsr	get_current_level
	jsr		([a0,d0.w*4])

1:
	clr.b	truck_previously_drawn
0:
	rts
	
specific_big_machine_restore:
	.long	nope
	.long	specific_level_1_truck_erase
	.long	specific_level_2_truck_erase
	.long	nope
	.long	nope
	.long	specific_level_5_train_erase
	.long	nope
	.long	nope
		
specific_level_1_truck_erase:
	jbsr	erase_truck_bottom_part
	
	* rear should be erased only when X > 0
	lea		prev_truck_params+2,a1
	move.w	(a1)+,d0	| X
	subq.w	#8,d0
	move.w	truck_y_pos,d1	| Y
	moveq	#4,d2		| just the first bytes
	move.l	fg_drawed_screen_ptr,a1
	move.w  big_machine_height,d4
	* clip to bottom of truck (wheels) doesn't work,
	* as the back of the truck leaves a trail
	*sub.w	truck_wheels_height,d4
	
	move.l	background_restore_buffer,a0
	jbsr	restore_background



	* restore blank between truck front & tow
	* broken... to re-test
	lea		prev_truck_params,a1
	move.w	(a1),d0		| displayX
	sub.w	(6,a1),d0	| truck pos
	add.w	#0x320,d0	| correct X
	jmi		1f
	move.l	fg_drawed_screen_ptr,a1
	move.w	truck_y_pos,d1
	move.w  big_machine_height,d4
	sub.w	truck_wheels_height,d4
	move.w	#4,d2
	move.l	background_restore_buffer,a0  | TEMP TEMP
	sub.w	#30,d1				| TEMP TEMP
	*jbsr	restore_background
	moveq	#4,D3
	jbsr	clear_fg_planes_any_blitter_internal
	rts
	
specific_level_2_truck_erase:
	jbsr	erase_truck_bottom_part
	* level 2: 2 gaps to restore, plus back of truck

	move.w	prev_truck_params,d0	| absolute secondary scroll pos
	moveq	#4,d2
	moveq	#0,d1		| full height
	jbsr	restore_gap
	
	
	* inter-trailer gap
	move.w	prev_truck_params,d0	| absolute secondary scroll pos
	* this is the X coord of start of truck

	add.w	#0xF0,d0
	* we must restore the trailer/truck gap


	moveq	#1,d1
	moveq	#4,d2
	jbsr	restore_gap

	
	* between trailer & truck
19:
	move.w	prev_truck_params,d0	| absolute secondary scroll pos
	
	add.w	#0x100-0x40,d0
	jpl		20f
	moveq	#6,d2
	moveq	#1,d1
	add.w	#0xF8,d0
	jbsr	restore_gap


20:
	* okay I don't know what the f*ck is going on 
	* (not displayed trailer stays on screen and wraps
	* probably, leaving some crap trailer parts everywhere)
	* easy way on that level: extra restore right part no matter what 
	* (don't do it when reaching the boss fight, useless, wastes blitter)
	
	move.w	x_secondary_scroll_value,d0
	cmp.w	#0x390,d0
	bcc		21f
	move.w	#0xF0,d0
	moveq	#4,d2
	moveq	#0,d1
	jbsr	restore_gap
21:
	rts
	
erase_truck_bottom_part:
	lea		prev_truck_params+2,a1
	move.w	truck_wheels_height,d3		| bottom part which needs restoring
	move.w	(a1)+,d0	| X
	move.w	truck_y_pos,d1	| Y
	move.w	(a1),d2		| real object size
	move.l	fg_drawed_screen_ptr,a1
	move.w  big_machine_height,d4
	* clip to bottom of truck (wheels)
	sub.w	d3,d4
	add.w	d4,d1
	move.w	d3,d4
	move.l	background_restore_buffer,a0
	jbra	restore_background

specific_level_5_train_erase:
	* there are 2 wagon gaps that need restoring
	lea		prev_truck_params,a1
	move.w	(a1)+,d0	| absolute secondary scroll pos
	add.w	#0x800,d0
	* this is the X coord of start of truck	

	* this is great! it works because wagon size + gaps
	* are exactly 1 screen wide

	move.w	d0,d7		| save value

	add.w	#0x80,d0
	and.w	#0xFF,d0	| modulus
	sub.w	#0x8,d0		| adjust for round corners
	* wagon gap
	moveq	#1,d1
	moveq	#4,d2	| no need to restore a lot
	jbsr	restore_gap
	
	move.w	d7,d0
	cmp.w	#0xB0,d0
	jcs		21f

	* not start of train, check if last wagon, we have to erase top of wagon
	* trail
	move.w	x_secondary_scroll_value,d0
	jeq		20f
	cmp.w	#MIN_TRAIN_X_TOP_DRAW,d0
	jcc		20f
	neg		d0
	add.w	#MIN_TRAIN_X_TOP_DRAW-8,d0
	
	move.w	truck_y_pos,d1		| Y-pos: fixed
	move.w	big_machine_extra_pic_height,d4
	sub.w	d4,d1
	add.w	x_background_scroll_value,d0
	move.l 	fg_drawed_screen_ptr,a1
	move.l	background_restore_buffer,a0
	moveq	#4,d2	| no need to restore a lot
	jbsr	restore_background

	
20:
	rts
21:
	* gap for tail wagon
	move.w	#0x100-48,d0
	move.w	#8,d2
	moveq	#1,d1
	jbsr	restore_gap

	rts
	
* < D1: 0: full height, 1: not lower part
* < D0: X (without scroll)
* < D2: width in bytes
restore_gap:
	* don't restore if not in visible screen
	tst.w	d0
	jpl		1f
	cmp.w	#0xFFE0,d0
	jcs		2f
	jra		3f
1:
	cmp.w	#0x100,d0
	jcc		2f
3:	
	add.w	x_background_scroll_value,d0
	move.w  big_machine_height,d4
	tst		d1
	jeq		4f
	sub.w	truck_wheels_height,d4
4:
	move.w	truck_y_pos,d1	| displayY
	move.l	background_restore_buffer,a0
	move.l	fg_drawed_screen_ptr,a1

	.ifne	OPT_DEBUG_GAP_ERASE
	sub.w	#10,d1	| slightly up that was to see where areas are restored
	add.w	#10,d4
	move.w	nb_tile_planes_24da,D3
	jbsr	clear_fg_planes_any_blitter_internal
	.else
	jbsr	restore_background
	.endif
2:
	rts
	
* truck_draw draw_truck for level 1
draw_truck_level_1:
	move.w	x_secondary_scroll_value,d0
	jeq		2f		| reached destination
	cmp.w	#0x400,d0
	jeq		2f		| not started: only on level 1
	cmp.w	#0x100,d0
	jcs		2f 		| out of the screen already
	jbsr	draw_big_machine
2:
	rts
	
draw_big_machine:
	move.w	x_secondary_scroll_value,d0
	move.w	big_machine_width,d6	| full truck size
	lsl.w	#3,d6			| in pixels
	
	* required to start displaying truck outside the screen: we have to compute
	* offset to skip start (and also adjust real width)
	moveq	#0,d5			| XY-offset
	neg	d0
	lea		prev_truck_params,a1
	add.w	big_machine_x_offset,d0	| now scroll value -0x200->0x200

	move.w	d0,(a1)+		| absolute secondary scroll start position (no back scroll)
	jpl		truck_not_clipped_left
	add.w	d0,d6	| adjust width to remove start/end of truck
	jmi		2f		| rightmost part still negative: too far right: don't display
truck_clipped_left:
	* truck starting to appear on the left side, clipped
	move.w	big_machine_width,d5	| full truck size
	lsl.w	#3,d5			| in pixels
	sub.w	d6,d5			| X-offset
	lsr.w	#3,d5			| in bytes
	bclr	#0,d5			| multiple of 16

	| of course X is at 0 (except fine shift)
	and.w	#0xF,d0
	jeq		11f
	add.w	#16,d6		| increase length
	sub.w	#0x10,d0
	move.l	#0xFFFF0000,bltamask_long_value	| testing
11:
	
	* we have to consider X shift
	jra		do_truck_draw
	
truck_not_clipped_left:
	* D0 is the actual X, check really displayed truck width (has to be clipped right)
	*move.w	big_machine_width,d6	| full truck size
	*lsl.w	#3,d6			| in pixels
	move.w	#NB_BYTES_PER_SCREEN_ROW*8+16,d6	| truck/train is wider than screen anyway
	sub.w 	d0,d6
	
	* start of truck will "benefit" from the shifted / rotated bits
	* because end of bitplane data is clipped off. We can use a different bltafwm
	* to workaround this
	* to full mask: this is a corner case
	move.l	#0xFFFF0000,bltamask_long_value
	
do_truck_draw:
	move.w	#NB_BYTES_PER_SCREEN_ROW*8+32,d2
	cmp.w	d6,d2
	jcc		11f
	move.w	d2,d6		| maxing out displayed width
11:

	move.l	big_machine_planes,a0
	move.w	big_machine_width,d2			| real object size
	move.w  big_machine_height,d4
	move.l	(4*NB_PLAYFIELD_PLANES,a0),a3	| mask
	
	* displayed width is positive: okay display something
	lsr.w	#3,d6	| re-convert width to bytes
	jeq		2f		| zero width: don't draw anything
	jcc		1f
	addq	#1,D6	| round to highest even
1:
	move.w	truck_y_pos,d1		| Y-pos: fixed

	* we have to take into account primary scroll value as we only have 1 layer
	add.w	x_background_scroll_value,d0
	* store the restore clip values for later
	
	st.b	truck_previously_drawn
	move.w	d0,(a1)+	| X
	move.w	d6,(a1)+	| real width
	move.w	x_secondary_scroll_value,(a1)	| note truck position
	move.l 	fg_drawed_screen_ptr,a1
	* now big optim: no need to cookie cut/draw all planes!!
	* so avoid last blit or even 2 last blits (if background is 16 colors)
	move.w	nb_tile_planes_24da,d3
	jbsr	blit_planes_any_internal_cookie_cut
	

	move.l	big_machine_extra_planes,d1
	jeq		2f
	move.w	x_secondary_scroll_value,d0
	jeq		2f
	cmp.w	#MIN_TRAIN_X_TOP_DRAW,d0
	jcc		2f
	neg		d0
	move.w	big_machine_extra_pic_width,d2
	add.w	#MIN_TRAIN_X_TOP_DRAW-80,d0

	
	move.l	d1,a0
	move.w	truck_y_pos,d1		| Y-pos: fixed
	move.w	big_machine_extra_pic_height,d4
	sub.w	d4,d1
	move.l	(4*NB_PLAYFIELD_PLANES,a0),a3	| mask
	add.w	x_background_scroll_value,d0
	move.l 	fg_drawed_screen_ptr,a1
	move.w	nb_tile_planes_24da,d3
	moveq	#0,d5
	moveq	#0,d6
	jbsr	blit_planes_any_internal_cookie_cut
	
	
2:
	rts
	
osd_flush_caches:
	tst.l	_resload
	jeq		0f
	move.l	_resload,a2
	jsr		(resload_FlushCache,a2)
	rts
0:
	move.l	4,a6
	jsr	(_LVOCacheClearU,a6)
	rts
	
* < A0: trap function
* < D0: trap number
osd_install_trap:
	move.l	a1,-(a7)
	lea	0x80.W,a1
	* ATM only whdload game so no need to read VBR
	move.l	a0,(a1,d0.w*4)
	move.l	(a7)+,a1
	rts
	
* < D0: operation size
* < D1: operation type read/write
* < A6: address
* <> D7: input/output

special_memory_op:
	movem.l	d2-d3/a0-a1,-(a7)	
	* hash the address
	move.l	a6,d2
	swap	d2		| 24, 30, 31
	sub.w	#0x24,d2
	jeq		video_ram_op
	cmp.w	#0x30-0x24,D2
	jeq		ports_ram_op
	.ifndef RELEASE
	cmp.w	#0x31-0x24,D2
	jeq		palette_and_sprites_ram_op
	add.w	#0x24,d2
	BREAKPOINT	"virtual access violation (address in D2)"
	jra		special_memory_op_out
	.endif
	jra		palette_and_sprites_ram_op
special_memory_op_out:
	movem.l	(a7)+,d2-d3/a0-a1
	rts
	
* virtual address 0x24xxxx
video_ram_op:
	.ifndef RELEASE
	add.w	#0x24,d2
	.endif
	swap	d2
	move.w	d2,d3
	and.w	#0xF000,d3
	rol.w	#4,d3
	lea		addr_24xxxx_table_op,a0
	jsr		([a0,d3.w*4])
	
	jra		special_memory_op_out
	
* virtual address 0x30xxxx
ports_ram_op:
	.ifndef RELEASE
	add.w	#0x24,d2
	.endif

	swap	d2
	move.w	d2,d3
	and.w	#0xC000,d3
	jeq		an_ports
	* 0x30Cxxx, 0->0x19: atm do nothing
	and.w	#0x1F,d2
	lea		addr_30c0xx_table_op,a0
	jsr		([a0,d2.w*4])

	jra		special_memory_op_out
an_ports:
	* not used! (analogue ports?)
	BREAKPOINT		"an ports"
	jra		special_memory_op_out

* virtual address 0x31xxxx
* track in mame: wpset 3103e0,20,W
palette_and_sprites_ram_op:
	.ifndef RELEASE
	add.w	#0x31-0xD,d2
	.endif

	swap	d2
	cmp.w	#0x3E0,d2
	jne		1f
	move.l	a0,-(a7)
	* boss 2 color change? could be
	move.l	rom_base,a0
	add.w	#0x117C+2,a0		| a1 is post-incremented
	cmp.l	a0,a1
	jne		0f
	* writing to palette with 117C as source: boss 2 colors
	* (reds => purples)
	lea		level_2_boss_color_change(pc),a0
	jbsr	change_palette
	jra		10f
0:
	move.l	rom_base,a0
	add.w	#0x127C+2,a0		| a1 is post-incremented
	cmp.l	a0,a1
	jne		0f
	lea		level_3_boss_color_change(pc),a0
	jbsr	change_palette
	jra		10f
0:
	move.l	rom_base,a0
	add.l	#0x51abc+4+2,a0		| a1 is post-incremented
	cmp.l	a0,a1
	jne		0f
	lea		level_5_boss_color_change(pc),a0
	jbsr	change_palette
	jra		10f
0:
	move.l	rom_base,a0
	add.w	#0x1258+4+2,a0		| a1 is post-incremented
	cmp.l	a0,a1
	jne		0f
	lea		level_6_boss_color_change(pc),a0
	jbsr	change_palette
	jra		10f
0:
	nop

10:
	move.l	(a7)+,a0
1:
	jra		special_memory_op_out
	
* actual inputs
addr_30c000_op:
	jbsr	read_controls
	move.w	d0,d7
	rts
	
* system (start/coin and also vblank - which is stubbed)
addr_30c002_op:
	tst.b	D1
	jne		0f
	jbsr	read_system_inputs
	move.b	d0,d7		| make sure sync flag set (bit 7 cleared)
	
	rts
0:
	BREAKPOINT	"unexpected write to 30c002"
	rts
	
	
addr_30c0xx_op:
	rts
	
addr_24xxxx_table_op:
	.long	addr_240xxx_op
	.long	addr_unmapped_op
	.long	addr_242xxx_op
	.long	addr_unmapped_op
	.long	addr_244xxx_tile_layer_op
	.long	addr_245xxx_tile_layer_op
addr_246xxx_tile_layer_op_address:
	.long	addr_246xxx_op
	.long	addr_unmapped_op
	.long	addr_248xxx_op
	.long	addr_unmapped_op
addr_24Axxx_tile_layer_op_address:
	.long	addr_24Axxx_tile_layer_op
	.long	addr_unmapped_op
	.long	addr_24Cxxx_op
addr_24Dxxx_tile_layer_op_address:
	.long	addr_24Dxxx_tile_layer_op
	.long	addr_unmapped_op
	.long	addr_unmapped_op
	
addr_30c0xx_table_op:
	.long	addr_30c000_op   | 0x00
	.long	addr_30c0xx_op   | 0x01
	.long	addr_30c002_op   | 0x02
	.long	addr_30c0xx_op   | 0x03
	.long	addr_30c0xx_op   | 0x04
	.long	addr_30c0xx_op   | 0x05
	.long	addr_30c0xx_op   | 0x06
	.long	addr_30c0xx_op   | 0x07
	.long	addr_30c0xx_op   | 0x08
	.long	addr_30c0xx_op   | 0x09
	.long	addr_30c0xx_op   | 0x0a
	.long	addr_30c0xx_op   | 0x0b
	.long	addr_30c0xx_op   | 0x0c
	.long	addr_30c0xx_op   | 0x0d
	.long	addr_30c0xx_op   | 0x0e
	.long	addr_30c0xx_op   | 0x0f
	.long	addr_30c0xx_op   | 0x10
	.long	addr_30c0xx_op   | 0x11
	.long	addr_30c0xx_op   | 0x12
	.long	addr_30c0xx_op   | 0x13
	.long	addr_30c014_op   | 0x14
	.long	addr_30c015_op   | 0x15
	.long	addr_30c0xx_op   | 0x16
	.long	addr_30c0xx_op   | 0x17
	.long	addr_30c0xx_op   | 0x18
	.long	addr_30c0xx_op   | 0x19
	.long	addr_30c0xx_op   | 0x1a
	.long	addr_30c0xx_op   | 0x1b
	.long	addr_30c0xx_op   | 0x1c
	.long	addr_30c0xx_op   | 0x1d
	.long	addr_30c0xx_op   | 0x1e
	.long	addr_30c0xx_op   | 0x1f

addr_30c014_op:
	move.w	d0,-(a7)
	move.w	d7,d0
	jbsr	osd_sound_start
	move.w	(a7)+,d0
	rts

addr_30c015_op:
	cmp.b	#5,d7
	jeq		0f
	BREAKPOINT	"unexpected write value in 30c0015"
0:
	move.w	d0,-(a7)
	move.w	#CREDIT_SND,d0
	jbsr	osd_sound_start
	move.w	(a7)+,d0
	rts
	
addr_unmapped_op:
	BREAKPOINT		"unmapped memory (in d2)"
	rts

addr_240xxx_op:
	rts		| to_implement
addr_242xxx_op:
	* for level 1, we're interested only in a lower row
	* where all objects have some bytes written
	cmp.w	#0x2404,d2
	jne		0f
	* D7 holds scroll value
	move.w	d7,front_objects_x_scroll
0:
	rts
	
* those values have been computed by dumping the tilesheet
* for level 2 before and after boss color change, then matches
* the quantized colors (so aren't the actual colors but very close)
* we cannot use the original palette change commands as the order
* and count don't match. This is trial and error based on mockup sprites
* captured during boss fight, and manual adjustments
level_2_boss_color_change:
	.word	0x500,0x306 | purple #3, slightly conflicts with bad dudes but doesn't matter
	.word	0x700,0x408 | purple #2: careful!! hit color
	.word	0xd00,0x62b	| purple #1
	.word	0x400,0x204
	
*	.word	0x600,0x306 | purple #3, slightly conflicts with bad dudes but doesn't matter
*	.word	0x800,0x408 | purple #2
*	.word	0xb00,0x62b	| purple #1
	*.word	0xeee,0x707   | conflicts with bad dudes trousers after quantizing, leaving white...
	*.word	0xc62,0xb75	 | those diffs seem not to have any effect, drop them
	*.word	0x953,0x853
	*.word	0x444,0x555
	*.word	0x731,0x631
	*
	*.word	0xd86,0xd97
	.long	-1		| end
	
level_3_boss_color_change:
	.word	0xC00,0x363
	.word	0x700,0x242  | 0x700,0xE00,0x900 used for hit sprite
	.word	0x400,0x020
	.word	0x500,0x131
	.long	-1		| end
level_6_boss_color_change:
	.word	0xC00,0x440
	.word	0x700,0x330
	.word	0x400,0X110
	.word	0x500,0x220
	.word	0x332,0x444
	.long	-1		| end

level_5_boss_color_change:   | TEMP not the proper colors probably
	.word	0xB00,0x464
	.word	0x400,0x121
	.word	0x500,0x232
	.word	0x700,0x343
	.long	-1		| end

	
* 8x8 tile layer, for osd (not scrolled) but also row scrolled
* for front objects (lamps...)
addr_245xxx_tile_layer_op:
addr_244xxx_tile_layer_op:
	and.w	#0x1FFF,d2

	cmp.b	#2,d0
	jne		0f
	swap	d7	
0:
	subq	#1,d0
	jpl		0f

	* byte op
	tst.b	d1
	jne		1f		| write
	BREAKPOINT	"byte read from 244xxx (in D2)"
	rts
1:
	* write byte: equivalent to write word with attr+code
	lea		video_ram_244000,a6
	bclr	#0,d2
	jeq		11f
	* this is not working properly!
	* odd: get even MSB value
	BREAKPOINT	"write byte 244xxx"
	rol.w	#8,d7
	move.b	(a6,d2.w),d7
	rol.w	#8,d7
	jra		12f
11:
	* even: get odd LSB value
	rol.w	#8,d7
	move.b	(1,a6,d2.w),d7
12:
	moveq	#1,d0		| word operation
	lea		0x244000,a6
	add.w	d2,a6
	jra		addr_244xxx_tile_layer_op
2:
	rts
0:
	* word write
	movem.l	a0-a5/d2-d6,-(a7)
10:
	move.w	d2,-(a7)
	lea		video_ram_244000,a0
	add.w	d2,a0
	tst.b	d1
	jne		0f		| write
	BREAKPOINT	"word read from 244xxx (in D2)"
	* read: TODO check read size
	move.w	(a0),d7
	jra		101f
0:
	cmp.w	(a0),d7
	jeq		100f	| already the proper value
	
*	cmp.w	#0x72,d7
*	jne		111f
*	TMPBREAK
*111:
*	cmp	#0,d7
*	jne		112f
*	cmp.w	#0x72,(A0)
*	jne		112f
*	TMPBREAK
*112:
	move.w	d7,(a0)	| set value in memory first

	* > 0x244800: just write, don't do anything
	* (used only scrolled for front objects)
	cmp.w	#0x800,d2
	jcs		0f
	addq	#2,a7
	jra		101f
0:
	* special cases: on some special tiles, 
	* blit the whole pic (big dudes in intro)
	cmp.w	#CTX_INTRO,global_context
	jne		16f
	cmp.w	#0x5526,d7	| written at 244398
	jne		15f
	move.w	#1,display_dudes
	jra		100f
15:
	cmp.w	#0x541E,d7
	jne		16f
	move.w	#2,display_dudes
	jra		100f
16:
	* then draw the 8x8 tile
	move.w	d2,d3
	and.w	#0x3F,D3		| this is X
	lsr.w	#1,d3			| divide by 2
	lsr.w	#6,D2			| this is Y
	subq	#1,d2
	jmi		100f
	lsl.w	#3,d2			| times 8
	cmp.w	#512,d2
	jcc		100f

	cmp.w	#CTX_GAME,global_context
	jeq		write_osd_layer

	
	move.l	fg_drawed_screen_ptr,a1
	move.l	background_restore_buffer,a5
	lea		mulNB_BYTES_PER_ROW_table,a2
	add.w	(a2,d2.w*2),d3
	add.w	d3,a1			| screen dest address on bg playfield
	add.w	d3,a5
	move.w	d7,d6			| tile code
	and.w	#0x7FF,d6
	jeq		erase_tile_8
	
	jbsr	pick_8x8_tile_code
	jeq		100f		| ignored

	add.l	d6,a0	| select tile clut
	
	move.w	nb_tile_planes_24da,d6
	subq	#1,d6
	
	move.l	a0,a3			| base ptr
	move.l	(NB_PLAYFIELD_PLANES*4,a0),d2		| where the mask is
	jne		1f
	* mask of zeroes: this is an inverted mask
	lea		eight_zeroes,a4
	jra		0f
1:
	move.l	d2,a4
	add.l	a3,a4
	* cookie cut loop against background
0:
	move.l	(a0)+,d2
	jeq		2f		| restore background, remove mask bits
	lea		(a3,d2.l),a2
	* plane contains data: copy it
	.set	offset,0
	.rept	8
	move.b	(a4)+,d3			| get mask line
	and.b	(offset,a5),d3		| read pristine backbuffer/remove bits (cookie cut) 
	or.b	(a2)+,d3			| insert tile bits
	move.b	d3,(offset,a1)		| put in destination
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	subq	#8,a4
1:
	lea		(SCREEN_PLANE_SIZE,a1),a1
	lea		(RESTORE_SCREEN_PLANE_SIZE,a5),a5
	dbf		d6,0b
	* plain copy loop on the planes without background (if any!)
	move.w	#NB_PLAYFIELD_PLANES,d6
	sub.w	nb_tile_planes_24da,d6
	jeq		100f			| 6 planes for tiles, nothing to do
	subq	#1,d6
	
0:	
	move.l	(a0)+,d2
	jeq		3f		| erase plane
	lea		(a3,d2.l),a2
	* plane contains data: copy it
	.set	offset,0
	.rept	8
	move.b	(a2)+,(offset,a1)		| put in destination
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	subq	#8,a4
11:
	lea		(SCREEN_PLANE_SIZE,a1),a1

	dbf	d6,0b
	
100:	
	move.w	(a7)+,d2
	* preparing for longword write
	addq.w	#2,d2
	swap	d7
	dbf		d0,10b		| next word (if longword write)
101:
	movem.l	(a7)+,a0-a5/d2-d6
	rts
2:
	* just cut this plane using mask (no data to OR with)
	.set	offset,0
	.rept	8
	move.b	(a4)+,d3			| get mask line
	and.b	(offset,a5),d3		| read pristine backbuffer/remove bits (cookie cut) 
	move.b	d3,(offset,a1)		| put in destination
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	subq	#8,a4
	jra		1b
3:
	* just erase this plane
	.set	offset,0
	.rept	8	
	clr.b	(offset,a1)		| put in destination
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	jra		11b
	
pick_8x8_tile_code:
	move.w	d7,d5			| save code
	rol.w	#4,d5
	and.w	#0xF,d5			| tile clut

	.ifne	OPT_ENABLE_LOGGING
	move.l	#video_ram_244000,0x14
	lea		tile_log_table_244000,a2
	move.l	a2,0x10		| store address in zero page
	move.w	d6,-(a7)
	lsl.w	#4,d6		| 16 cluts
	add.w	d5,d6		| clut offset
	st.b	(a2,d6.w)
	move.w	(a7)+,d6
	.endif

	* this is rather tricky
	* 1) "cookie cut" or "clear mask" data for first planes (which contain background)
	* 2) "copy data" or "clear" for the last planes
	move.l		tile_data_244000,a0

	add.l	(a0,d6.w*4),a0	| select tile code
	.ifndef	RELEASE
	cmp.l	#0,a0
	jne		0f
	BREAKPOINT	"no 8x8 tiles loaded"
	moveq	#0,d6
	rts
0:
	.endif
	move.l	(a0,d5.w*4),d6
	rts
	
erase_tile_8:
	move.w	nb_tile_planes_24da,d6
	subq	#1,d6
0:
	.set	offset,0
	.rept	8
	move.b	(offset,a5),(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	lea		(SCREEN_PLANE_SIZE,a1),a1
	lea		(RESTORE_SCREEN_PLANE_SIZE,a5),a5
	dbf		d6,0b
	
	move.w	#NB_PLAYFIELD_PLANES,d6
	sub.w	nb_tile_planes_24da,d6
	jeq		100b
	subq	#1,d6
0:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	lea		(SCREEN_PLANE_SIZE,a1),a1
	dbf 	d6,0b
	
	jra		100b
	rts

eight_zeroes:
	.skip	8
	
* assuming word write ATM
* < D3: X (in bytes displacement vs screen)
* < D2: Y (in number of rows aka real coords not tile coords!)
* this routine dispatches the data across the various static HW
* sprites on screen

write_osd_layer:

	move.w	d7,d6			| tile code+clut



	jbsr	pick_osd_sprite
	jeq		write_osd_layer_out
	
	and.w	#0x7FF,d6		| only tile code
	jeq		erase_tile_on_sprite

	
	move.w	d6,d7			| clut 0, we do colors manually

	jbsr	pick_8x8_tile_code
	jeq		write_osd_layer_out
	add.w	d6,a0	| select tile clut (should be zero anyway)
	move.l	a0,a2			| save base ptr (we use relative pointers)
	

	
0:
	move.l	(a0)+,d2
	jne		1f
	move.l	#blank_area,d2
	sub.l	a2,d2
1:
	move.l	(a0)+,d3
	jne		1f
	move.l	#blank_area,d3
	sub.l	a2,d3
1:
	lea		(a2,d2.l),a0	| first sprite plane
	lea		(a2,d3.l),a1	| second sprite plane

23:
	* plane contains data: copy it
	.set	offset,0
	.rept	8
	COPY_SPRITE_TILE_ROW
	.endr	
	
write_osd_layer_out:
	move.w	(a7)+,d2
	jra		101b		| exit
	

tempx:
	.byte 0
tempy:
	.byte 0
tempcode:
	.byte 0
	.align 2
	
erase_tile_on_sprite:
	.set	offset,0
	.rept	16
	CLEAR_SPRITE_TILE_ROW
	.endr	
	jra		write_osd_layer_out


* given D3/D2 as X/Y select location to start writing to sprite

pick_osd_sprite:	
	cmp.w	#17,d2
	jcc		not_upper_osd
	cmp.w	#8+1,d3
	jcc		0f
	* "1UP" + player score
	lea		osd_left_sprite+16-1,A3
	add.w	d3,a3		| add X offset
	.ifndef	RELEASE
	* ability to display debug messages
	cmp.w	#8,d2
	jeq		1f
	add.w	#NB_BYTES_PER_SPRITE_ROW*2*8,a3
1:
	moveq	#1,d2		| success
	rts
0:
	cmp.w	#16+1,d3
	jcc		0f
	* end of player score + high
	lea		osd_left_center_sprite+16-9,A3
	add.w	d3,a3		| add X offset
	cmp.w	#8,d2
	jeq		1f
	add.w	#NB_BYTES_PER_SPRITE_ROW*2*8,a3
1:
	moveq	#1,d2		| success
	rts
0:	
	cmp.w	#24+1,d3
	jcc		0f
	* end of player score + high
	lea		osd_right_center_sprite+16-17,A3
	add.w	d3,a3		| add X offset
	cmp.w	#8,d2
	jeq		1f
	add.w	#NB_BYTES_PER_SPRITE_ROW*2*8,a3
1:
	moveq	#1,d2		| success
	rts
0:
	cmp.w	#32+1,d3
	jcc		0f
	* player 2 score / push button
	lea		osd_right_sprite+16-25,A3
	add.w	d3,a3		| add X offset
	.ifndef	RELEASE
	* ability to display debug messages
	cmp.w	#8,d2
	jeq		1f
	add.w	#NB_BYTES_PER_SPRITE_ROW*2*8,a3
1:
	.endif
	
	moveq	#1,d2		| success
	rts
0:
10:
	moveq	#0,d2		| not displayed
	rts
	
not_upper_osd:
	cmp.w #0xE8,d2
	jcc		10b
	cmp.w #0xD8,d2
	jcc		lower_osd
	jra		10b		| center parts TODO
lower_osd:
	cmp.w	#11,d3
	jcc		2f		| TEMP center low
	* "1-LIFE" + status
	lea		osd_bottom_left_sprite+16,A3
	add.w	d3,a3		| add X offset
	cmp.w	#0xD8,d2
	jeq		1f
	* second row
	add.w	#NB_BYTES_PER_SPRITE_ROW*2*8,a3
1:
	moveq	#1,d2		| success
	rts
0:
	moveq	#0,d2
	rts
2:
	cmp.w	#22+1,d3
	jcs		0f		| center low
	cmp.w	#30,d3
	jcc		10b		| ignore
	* "2-LIFE" + status
	lea		osd_bottom_right_sprite+16-23,A3
	add.w	d3,a3		| add X offset
	cmp.w	#0xD8,d2
	jeq		1f
	* second row
	add.w	#NB_BYTES_PER_SPRITE_ROW*2*8,a3
1:
	moveq	#1,d2		| success
	rts
0:
	* boss energy on 2 sprites (also "continue" message)
	
	cmp.w	#0xB,d3
	jcs		10b			| ignore before
	cmp.w	#0x13,d3	
	jcc		0f
	lea		osd_bottom_left_center_sprite+16-11,a3
	add.w	d3,a3
	cmp.w	#0xD8,d2
	jeq		1f
	* second row
	add.w	#NB_BYTES_PER_SPRITE_ROW*2*8,a3
1:
	moveq	#1,d2		| success
	rts
	
0:
	* boss second sprite
	lea		osd_bottom_right_center_sprite+16-19,a3
	add.w	d3,a3
	cmp.w	#0xD8,d2
	jeq		1f
	* second row
	add.w	#NB_BYTES_PER_SPRITE_ROW*2*8,a3
	jra		1b		| success
1:

	moveq	#0,d2
	rts

	
blank_area:
	.skip	8
	
addr_248xxx_op:
	cmp.w	#0x841C,d2
	jeq		set_road_layer_scroll_value
	rts
	

* scroll registers of layer at 24D000
* 0024C010: X-scroll (used 0-0x400 4 screens in a row mode, truck, train)
* 0024C012: Y-scroll
addr_24Cxxx_op:
	cmp.w	#0xC010,d2
	jeq		0f
	cmp.w	#0xC012,d2
	jeq		1f
	* unsupported, also not useful & ignored
	rts
0:
	move.w	d7,d0
	jbsr	set_scroll_x_24d000_layer
	rts
1:
	move.w	d7,d0
	jbsr	set_scroll_y_24d000_layer
	rts
	
* scroll registers of layer at 24A000
* level 3 uses that global scroll (unlike for road in level 2)
* to scroll the whole screen and get the running water effect
addr_246xxx_op_level_3:
	cmp.w	#0x6010,d2
	jeq		set_road_layer_scroll_value
	rts
set_road_layer_scroll_value:
	and.w	#0x1FF,d7
	move.w	d7,x_road_layer_scroll_value
	rts

* scroll registers of layer at 24A000
* 00246010: X-scroll (wraps at 0x200 on 4x4 screen mode)
* 00246012: Y-scroll (wraps at 0x200 on 4x4 screen mode)
addr_246xxx_op:
	cmp.w	#0x6010,d2
	jeq		0f
	cmp.w	#0x6012,d2
	jeq		1f
	
	* unsupported, also not useful & ignored
	rts
0:
	move.w	d7,d0
	move.w	d7,contents_of_x_scroll_246010
	jbsr	set_scroll_x_24a000_layer
	rts
1:
	move.w	d7,d0
	move.w	d7,contents_of_y_scroll_246012
	jbsr	set_scroll_y_24a000_layer
	rts
	
	.macro	NEXT_PLANES
	lea		(SCREEN_PLANE_SIZE,a1),a1
	lea		(RESTORE_SCREEN_PLANE_SIZE,a4),a4	
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	lea		(SCREEN_PLANE_SIZE,a5),a5
	.endif	
	.endm
	
	.macro	CLR_PLANE
	.set	offset,0
	.rept	16
	clr.w	(offset,a1)
	clr.w	(offset,a4)
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	clr.w	(offset,a5)
	.endif	
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.endm

	.macro	CLR_MIRROR_PLANE
	.set	offset,0
	.rept	16
	clr.w	(offset+NB_BYTES_PER_SCREEN_ROW*2,a1)
	clr.w	(offset+NB_BYTES_PER_SCREEN_ROW*2,a4)
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	clr.w	(offset+NB_BYTES_PER_SCREEN_ROW*2,a5)
	.endif	
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.endm
	
* 16x16 tile layer
addr_24Axxx_tile_layer_op:
	and.w	#0x7FF,d2


	cmp.b	#2,d0
	jne		0f
	swap	d7	
0:
	subq	#1,d0
	jpl		0f
	* byte op: ignore
	rts
0:
	movem.l	a0-a5/d2-d6,-(a7)
10:

	move.w	d2,-(a7)
	lea		video_ram_24a000,a0
	add.w	d2,a0
	tst.b	d1
	jne		0f		| write
	BREAKPOINT	"word read from 24axxx (in D2)"
	move.w	(a0),d7
	jra		102f
0:
	cmp.w	(a0),d7
	jeq		100f	| already the proper value
	move.w	d7,(a0)	| set value in memory first

	jbsr	preprocess_16x16_tile
	jeq		100f
	move.w	d7,d5			| save code
	move.w	d7,d6			| tile code
	and.w	#0x7FF,d6
	jne		0f
	jbsr	erase_16x16_tile
	jra		100f
0:
	rol.w	#4,d5
	and.w	#0xF,d5			| tile clut

	.ifne	OPT_ENABLE_LOGGING
	cmp.w	#0x800,d6			| when logging on title: 1FF, else increase!
	jcc		0f
	lea		tile_log_table_24a000,a2
	move.l 	#video_ram_24a000,0xC
	move.w	d6,-(a7)
	lsl.w	#4,d6		| 16 cluts
	add.w	d5,d6		| clut offset
	st.b	(a2,d6.w)
	move.w	(a7)+,d6
0:
	.endif


	move.l	tile_data_24a000,a0
	move.w	nb_tile_planes_24da,d2

	.ifndef	RELEASE
	cmp.l	#0,a0
	jeq 	102f     | no tiles loaded, let logging work
	.endif

	jbsr	write_16x16_tile
100:		
	move.w	(a7)+,d2
	* preparing for longword write
	addq.w	#2,d2
	swap	d7
	dbf		d0,10b		| next word (if longword write)
101:
	movem.l	(a7)+,a0-a5/d2-d6
	rts
102:
	move.w	(a7)+,d2
	jra		101b

	
* compute X/Y tile and quadrant (internal routine)
* < D2: memory address low part 
* > D2/D3/D4/A1/A4/A5 
preprocess_16x16_tile:
	* then draw the 16x16 tile
	moveq	#0,d3			| D3.L!!
	move.w	d2,d3
	and.w	#0x1E,D3		| this is X times 2 (tiles are 16 bits wide
	move.w	d2,d4
	and.w	#0x1E0,d4
	lsr.w	#1,D4			| this is Y


	* now compute quadrant.
	sub.w	#0x200,d2
	smi		first_half_flag		| first half
	jmi		20f		| 000-200: top left quadrant: no changes
	sub.w	#0x200,d2
	jpl		21f	
	* 200-400: bottom left quadrant: add to Y
	bset	#8,d4	| add 256 to Y
	st		first_half_flag
	jra		20f
21:
	sub.w	#0x200,d2
	jpl		22f

	* 400-600: top right quadrant: add to X
	bset	#5,D3	| add 32 to X
	jra		20f
22:
	* 600_800: add to both
	bset	#5,D3	| add 32 to X
	bset	#8,d4	| add 256 to Y
20:

	cmp.w	y_min,d4
	jcs		30f
	cmp.w	y_max,d4
	jcc		30f

	move.l	fg_drawed_screen_ptr,a1
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	move.l	fg_displayed_screen_ptr,a5
	.endif
	move.l	background_restore_buffer,a4
	lea		mulNB_BYTES_PER_ROW_table,a2
	moveq	#0,d5
	move.w	(a2,d4.w*2),d5
	add.l	d3,d5
	.ifndef	RELEASE
	* check if not already too high
	cmp.w	#RESTORE_SCREEN_PLANE_SIZE-(16*NB_BYTES_PER_SCREEN_ROW*3),d5
	jcs		27f
	BREAKPOINT	"restore buffer out of bounds, D4=Y"
27:
	.endif
	add.l	d5,a4			| screen dest address on restore playfield
	
	* now make up for shifted Y scroll (levels 6 and 7) on screen
	tst.w	y_extra_offset
	jeq		25f
	add.w	#SCREEN_PLANE_SIZE/2,d5
25:
	add.l	d5,a1			| screen dest address on playfield
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	add.l	d5,a5
	.endif
	moveq	#1,d5
	rts
30:
	* out of bounds for restore buffer: ignore tile write
	moveq	#0,d5
	rts
	
* internal write tile routine, shared between 2 16x16 tile layers
* < A0: tile clut array
* < D2: number of planes
* < D5: clut index
* < D6: tile code
* checks first_half_flag

write_16x16_tile:
	add.l	(a0,d6.w*4),a0  | skip palette select tile code
	move.l	(a0,d5.w*4),d6
	jeq		1000f				| tile not found/ignored, skip

	add.l	d6,a0	| select tile clut
	move	d2,d6
	subq	#1,d6
	move.l	a0,a3			| base ptr
0:
	move.l	(a0)+,d2
	jeq		2f		| erase plane

	.ifndef	RELEASE
	cmp.l	#0x00FFFFF,d2
	jcs		22f
	
	BREAKPOINT	"invalid d2 value!"
22:
	.endif
	
	lea		(a3,d2.l),a2
	tst.b	first_half_flag
	jeq		23f

	* plane contains data: copy it
	.set	offset,0
	.rept	16
	move.w	(a2)+,d5
	move.w	d5,(offset,a1)
	move.w	d5,(offset+NB_BYTES_PER_SCREEN_ROW*2,a1)
	move.w	d5,(offset,a4)
	move.w	d5,(offset+NB_BYTES_PER_SCREEN_ROW*2,a4)
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	move.w	d5,(offset,a5)
	move.w	d5,(offset+NB_BYTES_PER_SCREEN_ROW*2,a5)
	.endif
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr	
	
	NEXT_PLANES
	dbf		d6,0b
1000:
	rts

	
23:
	* plane contains data: copy it
	.set	offset,0
	.rept	16
	move.w	(a2)+,d5
	move.w	d5,(offset,a1)
	move.w	d5,(offset,a4)
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	move.w	d5,(offset,a5)
	.endif
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr	
1:
	NEXT_PLANES
	dbf		d6,0b
	rts
2:
	CLR_PLANE
	tst.b	first_half_flag
	jeq		1b
	CLR_MIRROR_PLANE
	jra		1b
	

	
* 16x16 secondary tile layer, default: do nothing
addr_24Dxxx_tile_layer_op:
	rts
	
* sewer water tiles
addr_24Axxx_tile_layer_op_level_3:
	
	movem.l	a0-a5/d2-d6,-(a7)
	and.w	#0x7FF,d2
	lea		video_ram_24a000,a0
	add.w	d2,a0
	tst.b	d1
	jne		0f		| write
	BREAKPOINT	"word read from 24axxx (in D2)"
	move.w	(a0),d7
	jra		101f
0:
	cmp.w	(a0),d7
	jeq		100f	| already the proper value
	move.w	d7,(a0)	| set value in memory first


	jbsr	preprocess_16x16_tile
	jeq		100f

	cmp.w	#Y_WATER_MIN,d4
	jcs		100f			| don't write anything above that point!
	move.w	d7,d5			| save code
	move.w	d7,d6			| tile code
	and.w	#0x7FF,d6
	jne		0f
	jbsr	erase_16x16_tile
	jra		100f
0:
	rol.w	#4,d5
	and.w	#0xF,d5			| tile clut

	.ifne	OPT_ENABLE_LOGGING
	cmp.w	#0x800,d6			| when logging on title: 1FF, else increase!
	jcc		0f
	lea		tile_log_table_24a000,a2
	move.l 	#video_ram_24a000,0x18
1111:
	move.l	a2,0x28		| store address in zero page
	move.w	d6,-(a7)
	lsl.w	#4,d6		| 16 cluts
	add.w	d5,d6		| clut offset
	st.b	(a2,d6.w)
	move.w	(a7)+,d6
0:
	.endif

111:
	move.l	tile_data_24a000,a0
	move.w	nb_tile_planes_24da,d2

	.ifndef	RELEASE
	cmp.l	#0,a0
	jeq 	102f     | no tiles loaded, let logging work
	.endif

	jbsr	write_16x16_tile
100:		


101:
	movem.l	(a7)+,a0-a5/d2-d6
	rts
102:
	jra		101b

	
addr_24Dxxx_tile_layer_op_level_3:
	* level 3 (sewer) uses this tile layer as background, probably
	* because tile layer 24Axxx doesn't have enough tiles.
	* on the amiga, on the other hand, I don't care about that so I'm
	* redirecting a write to this layer into a write to the other layer
	* if the level uses it
	*
	* ending sequence also uses that tile layer
	and.w	#0x7FF,d2

	.ifndef		RELEASE
	cmp.w	#1,d0
	jeq		0f
	* byte/long op: ignore (not used...)
	BREAKPOINT	"24dxxx operation on byte or long not supported"
	rts
0:
	.endif
	movem.l	a0-a5/d2-d6,-(a7)
10:

	move.w	d2,-(a7)
	lea		video_ram_24d000,a0
	add.w	d2,a0
	tst.b	d1
	jne		0f		| write
	BREAKPOINT	"word read from 24axxx (in D2)"
	move.w	(a0),d7
	jra		101f
0:
	cmp.w	(a0),d7
	jeq		100f	| already the proper value
	move.w	d7,(a0)	| set value in memory first

	jbsr	preprocess_16x16_tile
	jeq		100f

	cmp.w	#Y_WATER_MIN,d4
	jcc		100f
	move.w	d7,d5			| save code
	move.w	d7,d6			| tile code
	and.w	#0x7FF,d6
	jne		0f
	jbsr	erase_16x16_tile
	jra		100f
0:
	rol.w	#4,d5
	and.w	#0xF,d5			| tile clut

	.ifne	OPT_ENABLE_LOGGING
	cmp.w	#0x800,d6			| when logging on title: 1FF, else increase!
	jcc		0f
	lea		tile_log_table_24d000,a2
	move.l 	#video_ram_24d000,0x1C
	move.l	a2,0x28		| store address in zero page
	move.w	d6,-(a7)
	lsl.w	#4,d6		| 16 cluts
	add.w	d5,d6		| clut offset
	st.b	(a2,d6.w)
	move.w	(a7)+,d6
0:
	.endif

111:
	move.l	tile_data_24d000,a0
	move.w	nb_tile_planes_24da,d2

	.ifndef	RELEASE
	cmp.l	#0,a0
	jeq 	102f     | no tiles loaded, let logging work
	.endif

	jbsr	write_16x16_tile
100:		
	move.w	(a7)+,d2

101:
	movem.l	(a7)+,a0-a5/d2-d6
	rts
102:
	move.w	(a7)+,d2
	jra		101b

erase_16x16_tile:
	move.w	nb_tile_planes_24da,d6
	subq	#1,d6
	tst.b	first_half_flag
	jne		erase_tile_twice_16x16
0:
	CLR_PLANE
	NEXT_PLANES
	dbf		d6,0b
	rts
	
erase_tile_twice_16x16:
0:
	CLR_PLANE
	CLR_MIRROR_PLANE
	NEXT_PLANES
	dbf		d6,0b
	rts


	
* < A0: text message to display in the upper right (below second player score)
osd_write_right_debug_message:
	.ifndef	RELEASE
	movem.l	d7/a6,-(a7)
	lea		0X2440EA,a6
	moveq	#0,d7
0:
	move.b	(a0)+,d7
	jeq		1f
	jbsr	osd_write_word
	addq	#2,a6
	jra		0b
1:
	movem.l	(a7)+,d7/a6
	.endif
	rts
* < A0: text message to display in the upper left (below first player score)
osd_write_left_debug_message:
	.ifndef	RELEASE
	movem.l	d7/a6,-(a7)
	lea		0X2440C3,a6
	moveq	#0,d7
0:
	move.b	(a0)+,d7
	jeq		1f
	jbsr	osd_write_word
	addq	#2,a6
	jra		0b
1:
	movem.l	(a7)+,d7/a6
	.endif
	rts
	
* < A6: virtual address (in RAM)
* > A6: real address

osd_real_ram_address:
	sub.l	#0xFF8000,a6
	.ifndef	RELEASE
	bpl.b	0f
	add.l	#0xFF8000,a6
	BREAKPOINT	"ram address out of range (in A6)"
	illegal
0:	
	.endif
	
	add.l	ram_base,a6
	rts
	
	.macro	OSD_MEM_WRITE_OP	size
	movem.l	d0/d1/d7,-(a7)
	move.w	#\size,d0
	move.w	#1,d1
	jbsr	special_memory_op
	movem.l	(a7)+,d0/d1/d7
	rts
	.endm
	
	.macro	OSD_MEM_READ_OP	size
	movem.l	d0/d1,-(a7)
	move.w	#\size,d0
	move.w	#0,d1		| read
	jbsr	special_memory_op
	movem.l	(a7)+,d0/d1
	rts
	.endm
	
osd_read_byte:
	OSD_MEM_READ_OP	0

osd_write_byte:
	OSD_MEM_WRITE_OP	0


osd_read_word:
	OSD_MEM_READ_OP	1

osd_write_word:
	OSD_MEM_WRITE_OP	1


osd_read_long:
	OSD_MEM_READ_OP	2

osd_write_long:
	OSD_MEM_WRITE_OP	2

	
osd_blitz:
	blitz
	rts
	
osd_break:
	* sends a WinUAE command to enter WinUAE debugger
	.ifndef	RELEASE
	move.l	D0,-(a7)
	pea     0.w
	* Normally it would point to where the result of the command is written, but since the last parameter (first pushed)
	* indicating the number of bytes to write is 0, nothing is written.
	pea     0.w	
	pea     1003f-1002f
	pea     1002f
	pea     -1.w
	pea     82.w
	jsr     0xf0ff60
	lea     24(sp),sp
	move.l	(a7)+,d0
	.endif
    rts
		
1002: .asciz    "AKS_ENTERDEBUGGER 1"
1003:
        .align	2



* < D0: number of 1/60Hz ticks
* can work with interrupts enabled or disabled
osd_wait:
	move.w	d0,delay_timer
	**jbsr	osd_is_vblank_interrupt_enabled
	tst.w	d0
	jne		2f
	* interrupts are disabled: timer isn't going to change
	* wait using vertical blank interrupt request (we don't need it!)
	clr.w	one_out_of_five
0:
	move.w	#0x20,_custom+intreq
	move.w	#0x20,_custom+intreq
1:
	move.w	_custom+intreqr,d0
	btst	#5,d0
	beq.b	1b
	addq.w	#1,one_out_of_five
	cmp.w	#5,one_out_of_five
	bne.b	5f
	subq.w	#1,delay_timer	
	clr.w	one_out_of_five
5:
	subq.w	#1,delay_timer
	beq.b	4f
	bpl.b	0b
4:
	rts
	
2:
	tst.w	delay_timer
	bne.b	2b
	rts




	
is_game_playing:
	movem.l	d0/a6,-(a7)
	GET_RAM_START_IN_A6
	tst.b	(0x215,a6)
	jpl		0f			| negative: game in play
	moveq	#1,d0
	jra		1f
0:
	moveq	#0,d0
1:
	movem.l	(a7)+,d0/a6
	rts
	

	
	.macro	FIX_COORD	reg
	and.w	#0x1FF,\reg   | remove attribute bits from sprite coord
	cmp.w	#0x100,\reg
	jcs		0f
	sub.w	#0x200,\reg
0:
	neg.w	\reg
	add.w	#240,\reg
	.endm
	


scroll_command_table:
	.long	0
	.long	do_scroll_down    | 4
	.long	do_scroll_down    | 8
	.long 	do_scroll_done    | 12
	.long	do_scroll_up      | 16
	.long	do_scroll_up      | 20
	.long 	do_scroll_done    | 24
	
do_scroll_done:
	* sequence complete
	addq.b	#1,nb_scroll_swaps
	clr.w	y_scroll_command
	rts
	

do_scroll_down:
	TMPBREAK
do_scroll_up:
	* scroll up: we went down too much and overtook y scroll 0x100
	* we need to copy all tiles from restore buffer upper part
	* to display buffer lower part and the other way round and offset
	* scroll value by 0x100 to simulate a wrap
	*
	* this is a very blitter expensive operation!

	move.l	fg_drawed_screen_ptr,a1	| destination: first half of screen
	sub.l	#SCREEN_PLANE_SIZE/2,a1		| make up for 0x100 Y offset
	move.l	background_restore_buffer,a0
	move.w	#0x100,d1
	
	jbsr	copy_background
	move.l	fg_drawed_screen_ptr,a1	| destination: first half of screen
	add.l	#SCREEN_PLANE_SIZE/2,a1		| add 0x100 Y offset
	move.l	background_restore_buffer,a0
	moveq	#0,d1
	jbsr	copy_background

	* we still have to erase the remaining bitplanes on visible screens
	* (non-background backuped ones)
	move.l	#draw_sprites,(a7)		| skip erase
	rts

* < A0: source
* < A1: destination (with possible offset)
* < D1: Y start
copy_background:
	moveq	#0,d0
	move.w	#NB_BYTES_PER_ROW,D2
	move.w	#256,D4		| height
	jbsr	restore_background
	rts
	
	
really_update_sprites:

	* first, check y scroll commands
	move.w	y_scroll_command,d0
	jeq		0f
	* non-null scroll command
	lea		scroll_command_table,a0
	addq.w	#4,y_scroll_command		| next scroll command
	jsr		([a0,d0.w])

0:
	move.l	bob_previous_drawed_sprites,a4
	move.w	(a4),d2		| init prev X with first val
	add.w	#16,d2			| previous += 16
	move.w	(2,a4),d3	| init prev Y with first val

	.ifdef		RELEASE
	tst.b	stop_updating_bobs
	jeq		10f
	rts
10:
	.endif
	
	.ifdef		GROUP_BACKGROUND_RESTORE
	* erase optimization pre-processing
	* scan previous positions to group the consecutive ones
	*
	* actually, lots of BOBs are 16-wide stripes grouped
	* 2 by 2 to create a big 32 bit wide character. Grouping
	* the erases saves a lot of bandwidth by not erasing the same
	* location twice
	* When erasing 2 bobs close by 16 pixels and on same Y
	* without optimization, it costs 64 bits clear per row
	* with optimization, it only costs 48 bits clear per row
	* in twice as less blits! (so less blitwaits, less computation)
	
	move.w	#NB_TARGET_SPRITES-2,d7
0:
	addq	#8,a4			| next entry
	move.w	(2,a4),d1		| Y
	beq.b	12f				| Y=0: inactive and end of list (let's hope it works!)
	move.w	(a4),d0
	cmp.w	d1,d3
	jne		1f				| different Y: out
	cmp.w	d2,d0
	jne		1f				| prev X + 16 != X: out
	* 2 consecutive 16 bit erase (composite sprite):
	* group them to save a lot of blitting
	move.w	(4,a4),d2
	subq	#2,d2			| no need to add, there's already a 16 bit margin
	add.w	d2,(-4,a4)		| merge widths instead (less bandwidth)
	* issue: propagate higher height value (which can waste bandwidth
	* but it's still better to do twice as less bigger clear blits
	move.w	(6,a4),d2
	cmp.w	(-2,a4),d2
	jcs		10f
	* previous blit erase is smaller: merge with bigger
	move.w	d2,(-2,a4)
10:
	clr.w	(4,a4)			| this width (means: cancel that erase slot)
	* do not store previous, as we don't support multi-grouping (yet)
	dbf		d7,0b
1:
	move.w	d1,d3			| y => prev y
	move.w	d0,d2			| store previous
	add.w	#16,d2			| previous += 16
	dbf		d7,0b
12:
	.endif

	
	lea		_custom,a5
	* clear previous positions
	move.w	#NB_TARGET_SPRITES-1,d7

	* compute number of remaining empty planes (after background planes)
	move.w	nb_tile_planes_24da,d5
	neg.w	d5
	addq.w	#NB_PLAYFIELD_PLANES,d5
	
	
	clr.b	nb_erased_objects	| to count erased objects
	
	move.l	bob_previous_drawed_sprites,a4
1:
	move.l	(a4),d0
	jeq		12f				| X=0 & Y=0: inactive and end of list (let's hope it works!)

	addq.b	#1,nb_erased_objects
	
	move.w	d0,d1		| Y
	swap	d0			| X
	tst		d0
	jpl		2f
	* X recorded as negative (shifted BOB blit like x=-3 happens, when
	* character is on the hard left and x_background_scroll_value is 0)
	* make it 0, doesn't matter if we don't restore the bobs there
	* it has wrapped to some high-X location and will be overwritten
	* at the time it will be displayed again
	moveq	#0,d0
2:
	and.w	#0x3F0,d0		| align on 16 lower bound (there are potentially 3 screens!)
	* clear area where the sprite was
	move.l	fg_drawed_screen_ptr,a1
	move.w	(4,a4),d2			| width in bytes (16 pixels: 4 bytes)
	jeq		111f	|  zero width: skip this entry

	move.w	(6,a4),d4		| height
	jpl		11f
	neg		d4
11:
	* restore background
	move.l	background_restore_buffer,a0
	tst.w	y_extra_offset
	jeq		25f
	* handle wrapping, but in some case we have to
	* restore the buffer in 2 operations if absolute Y+height > 0x100
	cmp.w	#0x100,d1
	jcs		24f 
	| completely wrapped, 1 restore blit only
	sub.w	#SCREEN_PLANE_SIZE/2,a0
	jra		25f
24:
	add.w	#SCREEN_PLANE_SIZE/2,a0
	move.w	d1,d6
	add.w	d4,d6		| y max
	cmp.w	#0x100,d6
	jcs		25f			| no wrap!
	* wrap!!!
	* reduce height for the first restore
	movem.w	d0-d1/d4,-(a7)
	move.w	#0x100,d4
	sub.w	d1,d4		| clipped height
	
	jbsr	restore_background
	movem.w	(a7)+,d0-d1/d4

	* now the second restore blit, wrapped around
	move.l	background_restore_buffer,a0
	*move.w	#0x100,d1
	*sub.w	d1,d6
	*move.w	d6,d4
	*jbsr	restore_background
	jra		26f
25:	
	jbsr	restore_background
26:
	* clear the rest of the planes (background can be 4 or 5 planes, we need to
	* clear the rest 1 or 2 planes)
	* a1 is returned by restore_background as the last cleared start address
	* go to next plane and use 0,0 coords to avoid more computations
	lea		(SCREEN_PLANE_SIZE,a1),a1
	moveq	#0,d0
	moveq	#0,d1
	move.w	d5,d3
	
	move.w	d5,-(a7)
	jbsr	clear_fg_planes_any_blitter_internal
	move.w	(a7)+,d5
111:
	* next erase entry
	addq	#8,a4
	dbf		d7,1b
12:	
*	tst.l	heli_planes
*	jeq		554f
*	move	#30,d0
*	move	#30,d1
*	add.w	y_background_scroll_value,d1
*	add.w	x_background_scroll_value,d0
*	move.l	heli_planes,a0
*	move.l 	fg_drawed_screen_ptr,a1
*	move.w	big_machine_width,d2
*	move.w	big_machine_height,d4
*	move.w	#NB_PLAYFIELD_PLANES,d3
*	move.l	(4*6,a0),a3
*	lea		_custom,a5
*	jbsr	blit_planes_any_internal_cookie_cut
*554:
	tst.l big_machine_planes
	jeq		555f
	
	jbsr	erase_big_machine
	jbsr	get_current_level
	cmp.b	#1,d0
	jne		50f
	jbsr	draw_truck_level_1
	jra		51f
50:
	jbsr	draw_big_machine
51:
	* reset possibly changed first word mask setting
	move.l	#-1,bltamask_long_value

	tst.l	front_objects_table
	jeq		555f
	jbsr	update_front_objects
555:

draw_sprites:
	* now compute frameskip for next time
	tst.b	frameskip_flag+3
	jne		558f
	* auto frameskip
	move.b	nb_erased_objects,d0
	lsr.b	#3,d0
	jne		556f
	* zero: 1
	moveq	#1,d0
556:
	cmp.b	#4,d0
	jcs		557f
	move.b	#3,d0		| min 17 fps
557:
	* update graphics counter to 1 (50fps), 2 (25fps), or 3 (17fps)
	* dynamically
	move.b	d0,graphics_update_counter_start
558:
	GET_RAM_START_IN_A6
	lea	(0x4000,a6),a0		| sprites
	
	.ifne		OPT_BOSS_SPRITES_MOCKUP
	cmp.w	#CTX_GAME,global_context
	jcs		600f
	jbsr	mockup_boss_palette_load
	lea		sprite_ram_mockup,a0
	
600:
	.endif
    lea _custom,A5
	move.l	bob_previous_drawed_sprites,a6
	move.l		sprite_table_base,a4
	*add.w	#(NB_TARGET_SPRITES-1)*4,a0		| start by the end (drawing priority)
	move.w	#NB_TARGET_SPRITES-1,d7
draw_bob_loop:
	move.w	(TARGET_SPRITE_Y,a0),d1  | sprite Y & attributes
	btst	#15,d1
	jeq		30f						 | if bit 15 not set, then slot is free
	
	move.w	(TARGET_SPRITE_X,a0),d0  | sprite X
	move.w	(TARGET_SPRITE_CODE,a0),d2
	and.w	#0xFFF,d2				| MAME masks the code to 1FFF, but here we go up to FFF

	move.w	d0,d3
	rol.w	#4,d3
	and.w	#0xF,d3		| color code


	.ifne	OPT_ENABLE_LOGGING
	lea		sprite_log_table_ffc000,a2
	movem.w	d1/d2/d4,-(a7)
	lsl.w	#4,d2		| 16 cluts
	add.w	d3,d2		| clut offset
	rol.w	#8,d1
	bset	#7,d1		| probably set, but at least won't be 0
	and.l	#0xFFFF,d2	| can't go higher, but may be > 0x8000!

	move.b	(a2,d2.l),d4
	or.b	d1,d4
	cmp.b	(a2,d2.l),d4
	jeq		0f
	* called only when a new sprite config is discovered, so will flash
	* only then
	move.b	d4,(a2,d2.l)	| merge/log as used, with properties
0:
	movem.w	(a7)+,d1/d2/d4
	.endif

	move.w	d1,d6		| Y coord + attributes
	rol.w	#5,d6		| data0 height properly times 16
	and.w	#0x3,d6		| sprite height
	jeq		555f
	* height is not 1x. Add 0x1000 offset to D2 sprite
	* this is to handle the corner case where sprite tile is used
	* as 16-high in some character animation and 32-high in another... bummer!
	*
	* probably can be explained simply: the graphics engine can display consecutive
	* sprites to create columns, rows, or blocks, which is great in general (and also
	* great for the amiga port as we can perform bigger blits instead of a lot of small ones)
	* but when the sprites have the y flipped attribute, the tiles don't match
	* (wrong order) so they have to be displayed separately
	*
	* it happens when the characters perform sommersaults (main, karnov, iron ninja...)
	*
	add.w	#0x1000,d2		| high fake sprite "page"
555:


	move.l	(a4,d2.w*4),d4	| test pointer
	jeq		30f			| zero: skipped

	.ifne	OPT_ENABLE_LOGGING
	* log sprite params in zero page
	move.l	a6,-(a7)
	lea		0x30,a6
	move.w	D0,(a6)+    | sprite X and flags
	move.w	D1,(a6)+    | sprite Y and flags (bit 15 set: sprite active)
	and.w	#0xFFF,d2
	move.w	D2,(a6)+    | sprite code 0-0x1000
	move.l	D4,(a6)+	| pointer on sprite clut table
	move.w	#0xDEAD,(a6)+
	

	move.l	(a7)+,a6
	.endif
	
	* we can use scratch registers D2,D5,D6 for attribute computation

*       data2 = X.W
*       data0 = Y.W
*		const bool flash = data2 & 0x800;
*		int flipx = data0 & 0x2000;
*		parentFlipY = flipy = data0 & 0x4000;
*		const int h = (1 << ((data0 & 0x1800) >> 11));   /* 1x, 2x, 4x, 8x height */
*		const int w = (1 << ((data0 & 0x0600) >>  9));   /* 1x, 2x, 4x, 8x width */

	btst	#11,d0		| check if flashing attribute
	jeq		777f
	tst.b	flashing_flip_flop
	jne		30f			| skip to create flash effect
777:
	move.w	d1,d6		| Y coord + attributes
	move.w	d6,d2		| copy full attributes in D2
	rol.w	#5,d6		| data0 height properly times 16
	and.w	#0x3,d6

	* this game sprite system uses 16,32 and 64 (1,2,4x) heights
	* there's also a 8x possible but not there. when displaying
	* a 16-high tile, the coord is OK, but when displaying a 32-high tile
	* we need to subtract 16, and 48 for a 64-high tile
	* we cannot rely on sprite height as it could have been cropped to optimize
	* 
	* correct X/Y: 240-x

	FIX_COORD	d0
	FIX_COORD	d1

	tst		d0
	jmi		0f
	* another kludge: if X > 0x200-64 it should be negative
	* (allows to display cars fully on the left at level 2)
	cmp.w	#0x200-CLIPPED_WIDTH_MARGIN,d0
	jcs		0f
	sub.w	#0x200,d0
0:
	
	
	tst.b	d6			| single sprite: skip Y correction
	jeq		0f
	lea		y_correction_table(pc),a3
	sub.w	(a3,d6.w*2),d1
0:
	.ifne	SPRITE_Y_CORRECTION
	add.w	#SPRITE_Y_CORRECTION,d1
	.endif
	.ifne	SPRITE_X_CORRECTION
	add.w	#SPRITE_X_CORRECTION,d0
	.endif

	* sprite X coord (without scrolling value added) should be in the screen
	* or just slightly off screen (avoids redrawing BOBs the visible screen
	* for no visible effect but slowdowns...)
	tst.w	d0
	jpl		0f
	cmp.w	#-CLIPPED_WIDTH_MARGIN,d0
	jcs		30f		| too negative: no can do (slightly negative works)	
	jra		10f
0:
	cmp.w	#NB_BYTES_PER_SCREEN_ROW*8,d0
	jcc		30f
10:
	add.w	x_background_scroll_value(pc),d0
	jpl		0f
	cmp.w	#-CLIPPED_WIDTH_MARGIN,d0
	jcs		30f		| too negative: no can do (slightly negative works)	
0:
	move.l	a0,-(a7)
	move.l	d4,a0
	move.l	(a0,d3.w*4),d4	| structure
	jeq		29f				| valid sprite but not clut: skip
	move.l	d4,a0
	moveq	#0,d3
	moveq	#0,d6
	btst	#13,d2
	jeq		0f
	* X-flip
	st		d3		| x-flip on
	move.w	#6+(NB_PLAYFIELD_PLANES+1)*4,d4
	tst.w	(a0,d4.w)
	jeq		0f			| flip is not pre-computed
	* pre-computed! all right!! just add offset to plane pointers
	st		d6			| d6 != 0: means we're pre-computed
	add.w	d4,a0
0:
	move.w	(a0)+,d4		| height
	move.w	(a0)+,d5		| width
	add.w	(a0)+,d1		| add offset to Y

	tst.b	d3
	jeq		0f
	* X flip
	lea	x_correction_table(pc),a1
	
	* wider than 16 bits means grouped sprite: we have to change X
	sub.w	(a1,d5.w),d0
0:
	
	* now A0 points on the first bitplane of the bob
	tst.b	d6
	jne		0f			| pre-computed, no need to check/perform mirroring

	jbsr	mirror_sprite_planes
0:
	btst	#14,d2
	jeq		0f
	* y flip: happens when characters perform sommersault (bad dudes, karnov..)
	neg		d4
0:
	move.l		fg_drawed_screen_ptr,a1
	* D0 and D1 are already set
	move.l	(NB_PLAYFIELD_PLANES*4,a0),d2
	beq.b	29f		| mask is zero: blank tile => skip
	move.l	d2,a3	| mask bitplane
	moveq	#0,d3	| default: no y-clip
	* if negative before adding y background scroll, clip
	tst.w	d1
	jpl		32f
	add.w	d1,d4	| less high
	jmi		29f		| too much clipping: skip
	jeq		29f
	neg.w	d1
	move.w	d1,d3	| Y-clip
	mulu.w	d5,d3	| is computed in bytes offset of source
	moveq	#0,d1
32:
	cmp.w	#Y_MAX,d1
	jcc		29f		| skip if too high before adding scroll value (some coords look bogus)
	add.w	y_extra_offset,d1
	add.w	y_background_scroll_value(pc),d1
	* note down that this bob will have to be erased
	move.w	d0,(a6)+			| store current sprite attributes to previous ones
	move.w	d1,(a6)+			| store current sprite attributes to previous ones
	move.w	d5,(a6)+			| store width
	move.w	d4,(a6)+			| store height
	
	move.w	d5,d2			| width in bytes, 4 for 16 pixels+shift		
	move.l	d3,d5			| Y-offset in bytes (often 0 but supports Y clip!)
	moveq	#0,d6			| X-offset
	moveq	#NB_PLAYFIELD_PLANES,d3
	jbsr		blit_planes_any_internal_cookie_cut
29:
	move.l	(a7)+,a0
30:
	addq.w	#TARGET_SPRITE_SIZE,a0
	dbf		d7,draw_bob_loop
	
	* clear last long X/Y
	clr.l	(a6)
	
	rts

* < A0: plane list
* < D4: height
* < D5: width (bytes)
* trashes: only unused registers :)

mirror_sprite_planes:
	movem.l	d0-d2/d5/a0,-(a7)
	* bitplanes aren't pre-computed: check bitplanes current orientation and swap
	* if required. This is slow but saves memory
	lea		mirror_table,a1
	moveq	#0,d2
	moveq	#NB_PLAYFIELD_PLANES+1-1,d6
0:
	move.l	(a0)+,d1		| current plane data
	jeq		1f				| no data: skip
	move.l	d1,a2
	cmp.b	(-2,a2),d3		| 2 bytes before: mirror flag
	jeq		1f
	* not the proper orientation: change it
	move.b	d3,(-2,a2)
	move.w	d4,d1		| height
	subq	#1,d1		| minus one for dbf
11:
	move.w	d5,d0       | number of byte values (4: 16 bits + shifting)
	lea		mirror_function_table(pc),a3
	jsr		([a3,d0.w*2])
	* next bitplane
1:
	dbf		d6,0b
	movem.l	(a7)+,d0-d2/d5/a0
	rts
	
mirror_16_bit_wide:
	move.w	(a2)+,d2
	jeq		14f					| zero: optim
	move.w	(a1,d2.l*2),(-2,a2)
14:
	addq	#2,a2					    | skip zero pad
	dbf		d1,mirror_16_bit_wide		| next
	rts

mirror_32_bit_wide:	
	moveq	#0,d0
10:
	move.w	(a2)+,d2
	move.w	(a2),d0	
	move.w	(a1,d2.l*2),(a2)		| get mirror value
	move.w	(a1,d0.l*2),-(a2)		| get mirror value
	addq	#6,a2					| skip row
	dbf		d1,10b
	rts

mirror_48_bit_wide:

	moveq	#0,d0
10:
	move.w	(a2),d2
	move.w	(4,a2),d0
	* edges
	move.w	(a1,d2.l*2),(4,a2)		| get mirror value
	move.w	(a1,d0.l*2),(a2)+		| get mirror value
	* center
	move.w	(a2),d2
	move.w	(a1,d2.l*2),(a2)
	addq	#6,a2					| skip row
	dbf		d1,10b
	rts

* this is !untested!
mirror_64_bit_wide:
	
	moveq	#0,d0
10:
	move.w	(a2),d2
	move.w	(6,a2),d0
	* swap edges
	move.w	(a1,d2.l*2),(6,a2)		| get mirror value
	move.w	(a1,d0.l*2),(a2)+		| get mirror value
	* swap center words
	move.w	(a2)+,d2
	move.w	(a2),d0
	move.w	(a1,d2.l*2),(a2)
	move.w	(a1,d0.l*2),-(a2)
	addq	#8,a2					| skip row
	dbf		d1,10b
	rts

	
mirror_function_table:
	.long	nope
	.long	nope
	.long	mirror_16_bit_wide
	.long	mirror_32_bit_wide
	.long	mirror_48_bit_wide
	.long	mirror_64_bit_wide
	.long	nope		| just in case, but there are no such objects
	.long	nope

y_correction_table:
	.word	0
	.word	16
	.word	48
	.word	48

* how much must we subtract given the blit width
* when x-flip is on, knowing that we have artificially
* grouped the sprites
x_correction_table:
	.word	0	| not reached
	.word	0	| not reached
	.word	0	| 16 bits no correction
	.word	16	| 32 bits
	.word	32	| 48 bits
	.word	48	| 64 bits
	
* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
clear_fg_plane_any_blitter_internal:
	moveq	#1,d3
* < A5: custom
* < D0,D1: x,y
* < A1: foreground plane pointer (often first plane!)
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes to clear
* < D4: blit height
* trashes D0-D6, A2, A3
clear_fg_planes_any_blitter_internal:
    * pre-compute the maximum of shit here
	move.w	d1,d6
    beq.b   1f    | optim
	* check if y start + height > Y_MAX
	* (ignores case where y = 0, no risk)
	add.w	d4,d6
	sub.w	#Y_MAX,d6
	bmi.b	0f
	* y start + height > Y_MAX: clip height
	sub.w	d6,d4
	beq.b	10f
	bpl.b	0f
10:
	* null or negative height after clipping: out
	rts
0:
    lea mulNB_BYTES_PER_ROW_table,a2
	.ifdef	NO68020
    add.w   d1,d1
    move.w  (a2,d1.w),d1
	.else
    move.w  (a2,d1.w*2),d1
	.endif
1:
	moveq	#1,d5
	ror.l	#8,d5     | AKA move.l  #0x01000000,d5   | minterm useD & rect clear (0xA) 
	tst		d1
	jpl		0f
	moveq	#0,d1
0:
    asr.w   #4,d0			| X displacement in bytes
	jpl		22f
	moveq	#0,d0				| was negative: clip to 0 (erase don't need shifting)
22:
	add.w	d0,d0			| in bytes but multiple of 2
	* now clip width
	cmp.w	#NB_BYTES_PER_ROW,d0
	jcs		23f
	* too far: exit
	rts
23:
	move.w	d0,d6
	add.w	d2,d6
	sub.w	#NB_BYTES_PER_ROW,d6
	jcs		24f
	* width too big: clip height
	sub.w	d6,d2
24:
    add.w   d0,d1
	bclr	#0,d1
2:   
    add.w   d1,a1       | plane position (always even)

	move.w #NB_BYTES_PER_ROW,d0
	bclr	#0,d2		| make sure D2 is even (else strange things occur!)
    sub.w   d2,d0       | blit width => modulo

	move.w	d4,d1		| save height
	subq	#1,d1		| minus one
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

	lea		cpu_erase_table(pc),a2
    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
	
	move.l	d5,bltcon0(a5)	
    move.w  d0,bltdmod(a5)	|D modulo
	
	subq	#1,d3
3:
	BTST	#6,(dmaconr,a5)
	jne		5f
4:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(SCREEN_PLANE_SIZE,a1),a1
	dbf		d3,3b	
    rts
5:
	* blitter is busy erasing data on previous plane: do the other one with CPU
	cmp.w	#5,d2
	jcc		6f
	move.w	d1,d6			| load height counter
	move.l	a1,a3			| save bitplane pointer
	jmp		([a2,d2.w*4])	| select proper erase function

6:
	* not supporting big CPU erases (not happening in-game anyway)
	WAIT_BLIT
	jra		4b
	
cpu_erase_table:
	.long	nope
	.long	cpu_erase_16_bits
	.long	cpu_erase_32_bits
	.long	cpu_erase_48_bits
	.long	cpu_erase_64_bits
	
cpu_erase_16_bits:
0:
	clr.w	(a1)+
	add.w	d0,a1
	dbf		d6,0b
	lea		(SCREEN_PLANE_SIZE,a3),a1
	dbf		d3,3b	
    rts	
cpu_erase_32_bits:
0:
	clr.l	(a1)+
	add.w	d0,a1
	dbf		d6,0b
	lea		(SCREEN_PLANE_SIZE,a3),a1
	dbf		d3,3b	
    rts
cpu_erase_48_bits:
0:
	clr.w	(a1)+
	clr.l	(a1)+
	add.w	d0,a1
	dbf		d6,0b
	lea		(SCREEN_PLANE_SIZE,a3),a1
	dbf		d3,3b	
    rts
cpu_erase_64_bits:
0:
	clr.l	(a1)+
	clr.l	(a1)+
	add.w	d0,a1
	dbf		d6,0b
	lea		(SCREEN_PLANE_SIZE,a3),a1
	dbf		d3,3b	
    rts	
	
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source (pointer on array of planes)
* < A1: destination fg plane, also background to mix with cookie cut fg plane
* < A3: source mask for cookie cut
* < D2: width of source in bytes (inc. 2 extra for shifting)
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D5: x+y byte offset for source planes
* < D6: width of source to blit (0: means all: will use full width)
* < D7: blit mask (not considered, optim, -1 all through the game)
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1
blit_planes_any_internal_cookie_cut:
    movem.l d0-d7/a4,-(a7)
    * pre-compute the maximum of shit here
	tst.w	d1
	jpl		1f
	* Y is negative
	tst.w	d4
	bpl.b	0f
	* H and Y are negative
	sub.w	d1,d4		| reduce height
	jpl		10f		| >= 0: don't draw at all
	moveq	#0,d1
	jra		1f
0:
	* H is positive, Y is negative: clip
	add.w	d1,d4
	jeq		10f
	jmi		10f		| <= 0: don't draw at all
	moveq	#0,d1
1:
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
	tst	d6
	jeq	2f
	btst	#0,d6
	jeq	1f
	addq	#1,d6	| even and round it
1:
	* put d6 in d5 high 16 bits
	swap	d5
	move.w	d6,d5
	swap	d5
2:	
	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	swap	d1
	clr.w	d1
	swap	d1
	swap	d0
	clr.w	d0
	swap	d0

	lea		cookie_cut_blit_table,a4
	
    move.w  d0,d6
    asr.w   #3,d0			| X displacement in bytes (maybe negative)

	*bclr	#0,d0			| it will be even (unless it's negative!)
	ext.l	d0				| extend sign
    add.l   d0,d1
	
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    bclr    #0,d1
    add.l   d1,a1       | plane position (D1 can be 0x7FFF, up to 0xC000)


	move.l	bltamask_long_value,d1
	and.w   #0xF,d6			| blit shift 0-15
	.ifdef	NO68020
	add.w	d6,d6
	add.w	d6,d6
	move.l	(a4,d6.w),d7
	lea		cookie_cut_mask_blit_table,a4
	move.l	(a4,d6.w),d6
	.else
	move.l	(a4,d6.w*4),d7
	lea		cookie_cut_mask_blit_table,a4
	move.l	(a4,d6.w*4),d6
	.endif



	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0	  | negative width to draw Y-flipped
	neg.w	d4    | make d4 positive again
5:
    lsl.w   #6,d4

	swap 	d5
	tst		d5
	jeq		51f
	* D6 param non-zero. Means that we will use a custom width
	* instead of full object width
	* D2 is still full object width (needed for source modulo)
	sub.w	d5,d2		| change source modulo from full width to partial width
    sub.w   d5,d0       | reduce blit width
    lsr.w   #1,d5		| now in 16 bit words
    add.w   d5,d4       | blit height
	jra		52f
51:
    sub.w   d2,d0       | blit width
    lsr.w   #1,d2
    add.w   d2,d4       | blit height
	moveq	#0,d2		| no data skip in source (no source modulo)
52:
	* restore d5 register to get byte offset of data start
	swap	d5

	add.w	d5,a3			| apply xy offset to mask too
	
	
	
    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set
	* set mask to possibly non-zero because truck/train use it to hide start
    move.l  d1,bltafwm(a5)

	move.w d2,bltamod(a5)		|A modulo=bytes to skip between lines
	move.w d2,bltbmod(a5)		|B modulo=bytes to skip between lines
	move.l d7,bltcon0(a5)	| sets con0 and con1: full cookie cut 2 sources & 1 mask
	
    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
					
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	jbsr	start_process_1_plane
	
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,6b
7:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	jbsr	start_process_1_plane
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
10:
    movem.l (a7)+,d0-d7/a4
    rts
	
start_process_1_plane:
	move.l (a0)+,d0
	beq.b	60f
	move.l	d0,a4
	add.w	d5,a4		| add XY offset
	* non-zero: set data source & bltcon
	move.l	d7,bltcon0(a5)	| sets con0 and con1: C-A+B->D cookie cut full
	move.l	a4,bltbpt(a5)	|source graphic top left corner
	rts

60:
	* source is 0: just apply mask (less bandwidth lost) and change bltcon
	move.l	d6,bltcon0(a5)	| sets con0 and con1: C-A->D cookie cut, B fixed
 	move.w	d0,bltbdat(a5)	|B word is zero (re-use the fact that d0 = 0)
	rts


	.macro	GEN_MINTERM_TABLE	name,value
\name\()_table:
	.set	shift,0
	.rept	16
	.long	(shift<<28)+(shift<<12)+(\value<<16)
	.set	shift,shift+1
	.endr
	.endm
	
	.macro	GEN_MINTERM_TABLE_2	name,value
\name\()_table:
	.set	shift,0
	.rept	16
	.long	(shift<<28)+(\value<<16)
	.set	shift,shift+1
	.endr
	.endm
	
	GEN_MINTERM_TABLE	cookie_cut_blit,0x0FCA
	GEN_MINTERM_TABLE_2	cookie_cut_mask_blit,0x0BCA

* 2 words: first shift (as bplcon value), then
* offset in bytes



* what: blits data on bg plane, no horizontal shifting (erase)
* args:
* < A0: pristine background
* < A1: dest buffer
* < D0: X (rounded to smaller 8-multiple)
* < D1: Y
* < D2: width in bytes
* < D4: height

* > A1: last clear position address
* trashes: D0-D1

restore_background:
	movem.l	d2-d6/a0/a2-a5,-(a7)
	lea		_custom,a5
	* adjust offset X: X//8 even rounded
	tst		d0
	jpl		0f
	moveq	#0,d0		| clip to 0 if X < 0
0:
	tst		d1
	jpl		0f
	moveq	#0,d1		| clip to 0 if Y < 0
0:
	asr.w	#4,d0		| in bytes
	jpl		1f
	* clip to 0 (never happens...)
	moveq	#0,d0
1:
	add.w	d0,d0			| in bytes but multiple of 2

	* now clip width to avoid overshoot
	cmp.w	#NB_BYTES_PER_ROW,d0
	jcc		1f	| too far: do nothing

	move.w	d0,d3
	add.w	d2,d3
	sub.w	#NB_BYTES_PER_ROW,d3
	jcs		24f		| okay!
	* width too big: clip height
	sub.w	d3,d2
24:
	
	lea		mulNB_BYTES_PER_ROW_table,a4
	moveq	#0,d3
	.ifdef	NO68020
	add.w	d1,d1
	* add Y offset: Y*NB_BYTES_PER_ROW
	move.w	(a4,d1.w),d3
	.else
	move.w	(a4,d1.w*2),d3
	.endif
	
	* !!long adds, we have a big buffer > 0x8000!!
	* same offset for source and destination
	* except if X coord > 0x200 (because background restore buffer
	* doesn't duplicate like the background which needs 3 screens)
	add.l	d3,a1
	add.l	d3,a0
	
	* here we need to clip to 0x300 (NB_BYTES_PER_ROW*8) FUCK
	add.w	d0,a1	| real coord (can be > 0x2xx)
	and.w	#0x3F,d0  | THIS IS WRONG SINCE THE START!!!!
	add.w	d0,a0	| wrap source

    move.l  #0x09f00000,d3    | A->D copy, ascending mode	
	move.w	#NB_BYTES_PER_ROW,d1		| blit modulo

    sub.w   d2,d1       | blit modulo
	
	move.w	d4,d5		| store blit height
	subq	#1,d5		| one less (for possible dbf)
	
    lsl.w   #6,d4
    lsr.w   #1,d2		| blit width
    add.w   d2,d4       | blit height
	
    * always the same settings

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    move.l  #-1,bltafwm(a5)
    
    * blitter registers set

	move.l d3,bltcon0(a5)	| sets con0 and con1

    move.w  d1,bltamod(a5)	|A modulo
    move.w  d1,bltdmod(a5)	|D modulo
							
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
	move.w	nb_tile_planes_24da,d0
	subq	#2,d0


2:
	lea	(RESTORE_SCREEN_PLANE_SIZE,a0),a0
	lea	(SCREEN_PLANE_SIZE,a1),a1
	cmp.w	#4,d2
	jcc		0f

	* not too wide blits: check if blitter is active
	BTST	#6,(dmaconr,a5)
	jeq		0f
	* save regs
	move.l	a1,a3
	move.l	a0,a2
	move.w	d5,d6
	lea		cpu_copy_table(pc),a4
	jsr		([a4,d2.w*4])

	* next plane
	move.l	a3,a1
	move.l	a2,a0
	dbf		D0,2b	
	jra		1f
0:
	WAIT_BLIT
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	dbf		D0,2b
1:
	
	movem.l	(a7)+,d2-d6/a0/a2-a5
	rts

cpu_copy_table:
	.long	nope
	.long	copy_1_word_row
	.long	copy_2_word_row
	.long	copy_3_word_row
	
nope:
	rts
copy_1_word_row:
11:
	* use cpu to restore background, may work concurrently to the blitter
	* copy word by word using the CPU
	move.w	(a0)+,(a1)+
	add.w	d1,a0
	add.w	d1,a1
	dbf		d6,11b
	rts
	
copy_2_word_row:
11:
	* use cpu to restore background, may work concurrently to the blitter
	* copy word by word using the CPU
	move.l	(a0)+,(a1)+
	add.w	d1,a0
	add.w	d1,a1
	dbf		d6,11b
	rts
	
copy_3_word_row:
11:
	* use cpu to restore background, may work concurrently to the blitter
	* copy word by word using the CPU
	move.l	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	add.w	d1,a0
	add.w	d1,a1
	dbf		d6,11b
	rts
	
	
* < A5: custom
* < D0.W,D1.W: x,y, no shifting
* < A0: source (pointer on array of planes)
* < A1: destination fg plane
* < D2: width in bytes
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D5: y offset for source planes
* < D7: blit mask (not considered, optim, -1 all through the game)
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1
blit_planes_any_internal_no_cookie_cut:
    movem.l d0-d7/a4,-(a7)
    * pre-compute the maximum of shit here
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	
    asr.w   #3,d0			| X displacement in bytes

    add.w   d0,d1

	move.l  #0x09f00000,d7    | A->D copy, ascending mode
	move.l  #0x0FCA0000,d6     | D clear

    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    *bclr    #0,d1
    add.w   d1,a1       | plane position (D1 < 0x7FFF, 288*40=0x2D00)
	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0
	neg.w	d4    | make d4 positive again
5:
    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height
    * always the same settings (ATM)
	moveq	#0,d2
	
    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	move.w d2,bltamod(a5)		|A modulo=bytes to skip between lines
	
    move.w  d0,bltdmod(a5)	|D modulo
					
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	jbsr	start_process_1_plane_nocc
	
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,6b
7:
	jbsr	start_process_1_plane_nocc
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d7/a4
    rts
	
start_process_1_plane_nocc:
	move.l (a0)+,d0
	bne.b	61f

	* source is 0: just clear (less bandwidth lost) and change bltcon
	move.l	#0x01000000,bltcon0(a5)	| sets con0 and con1: clear

	rts
61:
	* non-zero: set data source & bltcon
	move.l	d7,bltcon0(a5)	| sets con0 and con1: C-A+B->D cookie cut full
	move.l d0,bltapt(a5)	| source graphic top left corner
	rts

	
bob_previous_positions_1:
	ds.b	NB_TARGET_SPRITES*PREVIOUS_SPRITE_SIZE
bob_previous_drawed_sprites:
	.long	bob_previous_positions_1
bob_previous_displayed_sprites:
	.ifeq	OPT_ENABLE_DOUBLE_BUFFERING
	.long	bob_previous_positions_1
	.else
	.long	bob_previous_positions_2	
bob_previous_positions_2:
	.skip	NB_TARGET_SPRITES*PREVIOUS_SPRITE_SIZE+4	
	.endif

sprite_registers:
	ds.l	NB_TARGET_SPRITES+2		| we need more room for background scroll regs
	
	

switch_screen_buffers:

	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	* let's switch screen buffers, background (chars)
	* toggle fg planes (double buffering)
	* also toggle previous sprite positions
	
	lea		fg_drawed_screen_ptr,a0
	lea		bob_previous_positions_1,a2
	lea		bob_previous_positions_2,a3
	move.l	fg_screen_data_1,a1
	move.l	fg_screen_data_2,a5
	* also switch previous state memory
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
	exg		a2,a3
2:
	move.l	a1,(a0)
	move.l	a5,fg_displayed_screen_ptr
	move.l	a2,bob_previous_drawed_sprites
	.endif

	jbsr		set_playfield_bitplanes
	
	rts
	
store_system:
	tst.l	_resload
	beq.b	0f
	rts
0:
	* system copper
	
	move.l	4.W,a6
	move.w	AttnFlags(a6),d0
	btst	#AFB_68010,d0
	beq.b	1f
	lea	get_vbr,a5

	jsr		_LVOSupervisor(a6)
	move.l	d0,system_vbr
1:
	

	lea	_custom,a6
	move.w	intenar(a6),old_intena
	move.w	dmaconr(a6),old_dmacon
	lea		old_sysvectors,a0
	move.l	system_vbr,a1
	move.l	(0x68,a1),(a0)+
	move.l	(0x6c,a1),(a0)+
	move.l	(0x70,a1),(a0)+
	move.l	(0x74,a1),(a0)+
	move.l	(0x78,a1),(a0)+
	move.l	(0x7C,a1),(a0)+
	rts

restore_system:
	move.l	system_vbr,a0
	lea	_custom,a6
	jsr		_mt_remove_cia

	move.w	#0x4000,intena(a6)	| ints off
	lea		old_sysvectors,a0
	move.l	system_vbr,a1
	move.l	(a0)+,(0x68,a1)
	move.l	(a0)+,(0x6c,a1)
	move.l	(a0)+,(0x70,a1)
	move.l	(a0)+,(0x74,a1)
	move.l	(a0)+,(0x78,a1)
	move.l	(a0)+,(0x7C,a1)


	bclr	#6,0xbfee01


	lea	_custom,a6
	move.w	old_intena,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0
	move.w	d0,intena(a6)		| clr bits
	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,intena(a6)		| set bits and main

	move.w	old_dmacon,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0

***		and.w	#0xfff0,d0		| preserve sound dma for now

	move.w	d0,dmacon(a6)		| clr bits



	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,dmacon(a6)		| set bits and main

	move.l	old_syscoplist,cop1lc(a6)
	move.l	_gfxbase,a6
	move.b	gb_ChipRevBits0(a6),chiprevbits+3
	move.l	old_actiview,a1
	jsr	_LVOLoadView(a6)


	moveq	#0,d0
	rts

quit_to_os:
	tst.l	_resload
	bne.b	0f
	jbsr		restore_system
	* set SR to 0 from here, so we return to OS with SR=0
	* (else it kills the system pretty quickly)
	* it works as quit_to_os is called from an interrupt
	move.w	#0,SR
	move.l	old_stack,a7
	jbsr		save_highscores
	moveq	#0,d0
	rts
0:
	pea	  TDREASON_OK
	move.l	_resload,-(a7)
	addq.l	#resload_Abort,(a7)
	rts




	
platform_init:
	jbsr		store_system
	

	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	move.w	#0x7FFF,intena(a5)
	* set blitter parameters once and for all
    move.l  #-1,bltafwm(a5)
	
*	move.l	monitor,d0
*	cmp.l	#NTSC_MONITOR_ID,D0
*	bne		0f
*	* disable extra mid-screen interrupt, as it would be too fast (NTSC)
*	move.w	#0x1FE,intreq_block
*	move.w	#0x1FE,intreq_block+4
*0:

 	*         VVHH
    move.w #0x2CA0+HW_SPRITE_SHIFT,diwstrt(a5)
    move.w #0x24A0+HW_SPRITE_SHIFT,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)

	* restrict borders: we don't see bobs on the borders!
	* try to hide color 0 on the border (except on OCS)

    move.w #(SPRITE_FMODE<<2)+BITPLANE_FMODE,fmode(a5)	| 32 bit bitplane fetch, 64 bit wide sprites

	move.w	#0,bplcon1(a5)
	.ifeq	BITPLANE_FMODE-3
	moveq	#-8+NB_BYTES_PER_ROW-40,d0
	.else
	moveq	#-4+NB_BYTES_PER_ROW-40,d0
	.endif
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)

	

	
	* set sprite registers in copperlist to blank
	jbsr	clear_all_hardware_sprites
	* neutralize forest color copper change area
	jbsr	clear_forest_background_colors

	* wait 300 lines
	move.w	#100,d0
	jbsr	beamdelay
	move.w	#100,d0
	jbsr	beamdelay
	move.w	#100,d0
	jbsr	beamdelay
	
    * init sprite, bitplane, whatever dma

    move.w #0x83E0,dmacon(a5)
 
	* install keyboard and vblank/copper handler
	move.l	system_vbr,a1
	pea		level2_interrupt
	move.l	(a7)+,(0x68,a1)
	pea		_vblank
	move.l	(a7)+,(0x6C,a1)
	pea		_nmi
	move.l	(a7)+,(0x7C,a1)

	* soundfx lib
	lea		_custom,a6
	lea		blank_sound,a0
	move.l	a0,(0xA0,a6)
	move.l	a0,(0xB0,a6)
	move.l	a0,(0xC0,a6)
	move.l	a0,(0xD0,a6)
	move.l	system_vbr,a0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	lea		0x180000,a0
	move.l	#0x20000,d0
	lea		0x100,a1
	jbsr		init_fixed_address
	jbsr		install_profiler_vbl_hook
	.endif

	
    rts
	
* < A0: filename
* > D0,D1: file pointer, file size
allocate_and_load_public_mem_file:
	jbsr	get_file_size
	move.l	D0,-(a7)
	moveq	#0,d1
	jbsr	allocate_memory
	move.l	d0,a1
	move.l	a1,-(a7)
	jbsr	load_and_decrunch_file
	move.l	(a7)+,d0
	move.l	(a7)+,d1
	rts
	
* < A0: filename
* > D0,D1: file pointer, file size
allocate_and_load_chip_mem_file:
	jbsr	get_file_size
	move.l	D0,-(a7)
	moveq	#1,d1
	jbsr	allocate_memory
	move.l	d0,a1
	move.l	a1,-(a7)
	jbsr	load_and_decrunch_file
	move.l	(a7)+,d0
	move.l	(a7)+,d1
	rts
	
* < A0: filename
* < A1: memory
load_and_decrunch_file:
	movem.l d0-d1/a0-a2,-(a7)
	move.l	_resload,a2
 	jsr	(resload_LoadFileDecrunch,a2)
	movem.l (a7)+,d0-d1/a0-a2
	rts

load_boss_music_module:
	move.l	current_tune,A1
	lea		boss_fight_music_file,a0
	jbsr	load_and_decrunch_file
	rts
	
load_win_music_module:
	move.l	current_tune,A1
	lea		stage_completed_music_file,a0
	jbsr	load_and_decrunch_file
	rts
		

* we're allocating a fixed amount of memory
* so we're able to fit the boss module in the same
* memory chunk
allocate_and_load_music_module:
	jbsr	get_file_size
	move.l	#MAX_MODULE_SIZE,d2
	cmp.l	d0,d2
	jcc		0f
	BREAKPOINT	"max module size disrepancy"
	jbsr		quit_to_os
0:
	* allocate memory
	moveq	#1,d1
	move.l	#MAX_MODULE_SIZE,d0
	jbsr 	allocate_memory
	move.l	d0,a1
	move.l	a1,-(a7)
	jbsr	load_and_decrunch_file
	move.l	(a7)+,a1

	move.l	a1,current_tune
	rts
	
* < A0: filename
* > D0: size (decrunch supported)
get_file_size:
	tst.l	_resload
	jeq		0f
	movem.l	d1/a0-a2,-(a7)
	move.l	_resload,a2
	jbsr	(resload_GetFileSizeDec,a2)
	movem.l	(a7)+,d1/a0-a2
	rts
0:
	* unsupported
	illegal
	illegal
	illegal
	rts
	
* < D0: required size
* < D1: 0 any, 1 chip
* > d0: allocated block
allocate_memory:
	movem.l	d2-d4/a0-a1,-(a7)
	tst.b	d1
	jeq		0f
	lea		chip_memory_block,a0
	lea		chip_memory_current_ptr,a1
	move.l	#TOTAL_CHIP_MEMORY_SIZE,d3
	jra		1f
0:
	lea		public_memory_block,a0
	lea		public_memory_current_ptr,a1
	move.l	#TOTAL_PUBLIC_MEMORY_SIZE,d3
1:
	and.l	#0xFFFFFFF0,d0
	add.l	#0x10,d0	| will always be aligned on 0x10 bytes
	
	move.l	(a1),d2
	move.l	d2,d4
	sub.l	a0,d2		| occupied size
	add.l	d0,d2		| next free block
	cmp.l	d3,d2		| compare to max
	jcc		out_of_memory
	add.l	d0,(a1)
	move.l	d4,d0		| return value
	movem.l	(a7)+,d2-d4/a0-a1
	rts
	

out_of_memory:
	tst.b	d1
	jeq		0f
	BREAKPOINT	"out of chip memory"
	jra		quit_to_os
0:
	BREAKPOINT	"out of memory"
	jra		quit_to_os


	

free_all_memory:
	lea		public_memory_block,a0
	move.l	a0,public_memory_current_ptr
	lea		chip_memory_block,a0
	move.l	a0,chip_memory_current_ptr
	rts
	
* < A0: palette
* < A1: copperlist
* < D0: number of colors to load
* supports bank switching (skips it)	
load_palette:
	subq.w	#1,d0
	beq.b	2f
1:
	move.w	(a1)+,d1
	* check if copperlist entry is not a bank switch
	cmp.w	#bplcon3,d1
	jeq		3f
	move.w	(a0)+,(a1)+
	dbf		d0,1b
2:
	rts
3:
	addq	#2,a1
	jra		1b		| bank switch, skip this copperlist entry
	


	

osd_is_vblank_interrupt_enabled:
	move.w	_custom+intenar,d0
	btst	#5,d0			| check vblank interrupt
	rts
	


* 60Hz VBLANK interrupt (also keyboard)
osd_enable_interrupts:
	tst.b	interrupt_mode
	beq.b	0f
	* clear SR from interrupt mode, so enable interrupts really
	* works from the game (which calls enable interrupts from interrupt)
	move.w	#0x2000,SR
0:
	move.w	#0xC038,_custom+intena
	rts
	
osd_disable_interrupts:
	tst.b	interrupt_mode
	beq.b	0f
	* if interrupts are disabled again from interrupt, re-set SR
	move.w	#0x2700,SR
0:
	move.w	#0x0030,_custom+intena
	rts



	

set_scroll_x_24a000_layer:
	and.w	#0x1FF,d0
	move.w	x_background_scroll_value,d1
	cmp.w	d1,d0
	jne		0f
	rts
0:
	exg		d0,d1
	jbsr	get_current_level
	subq	#1,d0
	exg 	d0,d1
	lea		scroll_x_24a000_table(pc),a0
	jbsr	([a0,d1.w*4])
	rts

set_scroll_y_24a000_layer:
	and.w	#0x1FF,d0
	move.w	y_background_scroll_value,d1
	cmp.w	d1,d0
	jne		0f
	rts
0:
	* we don't have chipmem room for extra Y wrap buffer in 3 screens
	* let alone restore buffer
	* we need to detect when Y scroll passes the 0x100 value in any direction
	cmp.w	#0x101,d0
	jcc		1f
	* new value <= 0x100. Check if previous value was > 0x100
	cmp.w 	#0x101,d1
	jcs		2f		| was also <= 0x100, nothing to do
	* new value below 0x100 again, old value > 0x100
	* we just crossed the 0x100 Y scroll value boundary downwards (scroll value wrapped
	* or elevator is rising)
	clr.w	y_extra_offset
	move.w	#SCROLL_DOWN,y_scroll_command
	cmp.b	#3,nb_scroll_swaps
	jne		2f
	* 3 scroll swaps means level 7 and the elevator:
	move.b	#1,level_7_load_second_part_flag
	jra		2f
1:
	* new value > 0x100: happens in levels 6 and 7. Is previous value <= 0x100?
	cmp.w	#0x101,d1
	jcc		2f		| same half: do nothing
	* we just crossed the 0x100 Y scroll value boundary
	* we have to translate everything upwards
	move.w	#-0x100,y_extra_offset
	move.w	#SCROLL_UP,y_scroll_command

2:
	move.w	d0,y_background_scroll_value
	rts

* usually set to control big objects on screen, except at level 3
* where the entire background uses this layer
set_scroll_x_24d000_layer:
	.ifndef	RELEASE
	* if debug truck/train don't let the program set the value
	tst.b	debug_truck_control
	jne		1f
	.endif
	move.w	x_secondary_scroll_value,d1
	cmp.w	d1,d0
	jne		0f
	rts
0:

	exg		d0,d1
	jbsr	get_current_level
	subq	#1,d0
	exg 	d0,d1
	lea		scroll_x_24d000_table(pc),a0
	jbsr	([a0,d1.w*4])
1:
	rts

set_scroll_y_24d000_layer:
	move.w	y_secondary_scroll_value,d1
	cmp.w	d1,d0
	jne		0f
	rts
0:
	
	move.w	d0,y_secondary_scroll_value
	rts
	
	* depending on the level, the game uses layers as background or
	* to move big objects like trucks, train and the helicopter
scroll_x_24d000_table:
	.long	move_ninjas_truck
	.long	move_long_truck
	.long	scroll_background_x
	.long	nope
	.long	move_train
	.long	nope
	.long	nope
	.long	nope

	
scroll_x_24a000_table:
	.long	scroll_background_x
	.long	scroll_background_x
	.long	nope
	.long	scroll_background_x
	.long	scroll_background_x
	.long	scroll_background_x
	.long	scroll_background_x
	.long	nope
	
move_ninjas_truck:
	* in debug mode, when debug truck display is set, don't move truck
	.ifndef		RELEASE
	tst.b	debug_truck_control
	jeq		0f
	rts
	.endif
0:
	move.w	d0,x_secondary_scroll_value
	rts
	
move_long_truck:
	move.w	d0,x_secondary_scroll_value
	rts
	
move_train:
	move.w	d0,x_secondary_scroll_value
	rts
	
scroll_background_x:
	and.w	#0x1FF,d0
	move.w	d0,x_background_scroll_value
	rts
	
set_playfield_bitplanes:
	* set bitplanes
	moveq	#0,d0
	move.w	y_background_scroll_value,d0
	add.w	y_extra_offset,d0
	
	lea		mulNB_BYTES_PER_ROW_table,a2
	move.w	(a2,d0.w*2),d0		| compute Y offset
	move.w	x_background_scroll_value,d2	

	lea		scroll_table,a2
	move.w	(a2,d2.w*4),fine_x_scroll_value
	add.w	(2,a2,d2.w*4),d0

    add.l	fg_displayed_screen_ptr,d0
    lea	bitplanes_intro+2,a0
	jbsr	set_bitplanes
	
	.ifeq	OPT_NO_BOTTOM_SCROLL
	jbsr	get_current_level
	cmp.w	#2,d0
	jeq		0f
	cmp.w	#5,d0
	jeq		0f
	cmp.w	#3,d0
	jne		1f
0:
	* level 2 level road layer
	
	move.w	x_road_layer_scroll_value,d2
	lea		scroll_table,a2
	move.w	(a2,d2.w*4),fine_x_road_scroll_value
	moveq	#0,d0
 	move.w	(2,a2,d2.w*4),d0		| truck level: y scrolling = 0
	add.l	fg_displayed_screen_ptr,d0
 	add.l	#NB_BYTES_PER_ROW*(256-32),d0

    lea	bitplanes_road+2,a0
	move.w	nb_tile_planes_24da,d1
	jbsr	set_any_bitplanes
	
1:	
	.endif
	
	rts

set_bitplanes:
    moveq #NB_PLAYFIELD_PLANES,d1
set_any_bitplanes:
	subq	#1,d1
	move.l	#SCREEN_PLANE_SIZE,d2
0:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l d2,d0		| LONG!
    dbf d1,0b
	rts
	
enable_bottom_scroll:
	.ifne	OPT_NO_BOTTOM_SCROLL
	rts
	.endif
	
    lea	bitplanes_road,a0
    move.w	nb_tile_planes_24da,d1
	subq	#1,d1
	move.w	#bplpt,d0
0:
    move.w d0,(a0)
    addq	#2,d0
    move.w d0,(4,a0)    
    addq	#2,d0
    addq.w  #8,a0
    dbf d1,0b
	
	* rest of the planes should be neutral/zeroed
	move.w	#NB_PLAYFIELD_PLANES,d1
	sub.w	nb_tile_planes_24da,d1
	jeq		1f
	subq	#1,d1
	move.w	#0x1FE,D0		| copper nop
0:
    move.w d0,(a0)
    move.w d0,(4,a0)    
    addq.w  #8,a0
    dbf d1,0b
	
1:	
	* activate shiftable bitplanes
	move.w	#bplcon1,(a0)
	* less bitplanes
	move.w	#bplcon0,(4,a0)	
	move.w	nb_tile_planes_24da,d1
	ror.w	#4,d1
	or.w	#0x200,d1
	move.w	d1,(6,a0)
	
	* also change colors of the road

	rts
	
disable_road_scroll:
    lea	bitplanes_road,a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.w	#0x1FE,d0
0:
    move.w d0,(a0)
    move.w d0,(4,a0)    
    addq.w  #8,a0
    dbf d1,0b
	* disable bplcon writes
	move.w	d0,(a0)
	move.w	d0,(4,a0)
	rts
	
set_game_bitplanes:	
	movem.l	d0-d3/a0-a2,-(a7)
	jbsr	set_playfield_bitplanes
	movem.l	(a7)+,d0-d3/a0-a2
    rts
		

award_weapon:
	move.l	a6,-(a7)
	lea		0xFFA365,a6
	jbsr	osd_real_ram_address
	move.b	d0,(a6)
	move.l	(a7)+,a6
	rts

level_completed:
	move.l	a6,-(a7)
	lea		0xFF8216,a6
	jbsr	osd_real_ram_address
	st.b	(a6)
	move.l	(a7)+,a6
	rts

boss_low_energy:
	move.l	a6,-(a7)
	lea		0xFF95C0,a6
	jbsr	osd_real_ram_address
	move.b	#1,(a6)
	move.l	(a7)+,a6
	rts



BIT_INSERT_COIN_1 = 4
BIT_INSERT_COIN_2 = 5
BIT_START_1P = 2
BIT_START_2P = 3

BIT_UP = 0
BIT_LEFT = 2
BIT_RIGHT = 3
BIT_DOWN = 1
BIT_FIRE1 = 4
BIT_FIRE2 = 5

read_system_inputs:
	move.b	#0x7F,d0		| sync flag set, always
	movem.l	a0/d1,-(a7)
	lea		keyboard_table,a0
	* misc control keys
	tst.b	(6,a0)		| "6" key like in MAME
	beq.b	0f
	bclr	#BIT_INSERT_COIN_2,d0
0:	
	tst.b	(5,a0)		| "5" key like in MAME
	beq.b	0f
	bclr	#BIT_INSERT_COIN_1,d0
0:
	tst.b	(1,a0)		| "1" key like in MAME
	beq.b	0f
	bclr	#BIT_START_1P,d0
0:
	tst.b	(2,a0)		| "2" key like in MAME
	beq.b	0f
	bclr	#BIT_START_2P,d0
0:	

	jbsr		is_game_playing
	bne.b	2f

	* if game not playing, or within "continue" loop
	* consider "fire" as insert coin
	move.l	_joypad_state,d1
	* save prev state as game loops within vblank
	* pushing fire would either lockup the game
	* or insert a lot of credits simulatenously

	* game not in play, accept start 1P game with "up"
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#BIT_START_1P,d0
0:
	* game not in play, accept start 2P game with "down"
	* temp: disabled ATM, 2P mode is buggy!
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#BIT_START_2P,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	1f
	* game not in play, accept insert coin with fire
	bclr	#BIT_INSERT_COIN_1,d0
1:
2:

	movem.l	(a7)+,a0/d1
	rts
	

save_highscores:
	rts

load_highscores:
	rts
	
read_controls:
	moveq	#-1,d0
	movem.l	a0/d1,-(a7)

	lea		keyboard_table,a0

	tst.b	(0x4C,a0)		| "up" key
	beq.b	0f
	bclr	#BIT_UP,d0
0:
	tst.b	(0x4D,a0)		| "down" key
	beq.b	0f
	bclr	#BIT_DOWN,d0
0:
	tst.b	(0x4F,a0)		| "<-" key
	beq.b	0f
	bclr	#BIT_LEFT,d0
0:
	tst.b	(0x4E,a0)		| "->" key
	beq.b	0f
	bclr	#BIT_RIGHT,d0
0:
	tst.b	(0x63,a0)		| "ctrl" key
	beq.b	0f
	bclr	#BIT_FIRE1,d0
0:
	tst.b	(0x64,a0)		| left "alt" key
	beq.b	0f
	bclr	#BIT_FIRE2,d0
0:


	* directions + fire
	move.l	_joypad_state,d1
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#BIT_UP,d0
0:
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#BIT_DOWN,d0
0:
	btst	#JPB_BTN_LEFT,d1
	beq.b	0f
	bclr	#BIT_LEFT,d0
0:
	btst	#JPB_BTN_RIGHT,d1
	beq.b	0f
	bclr	#BIT_RIGHT,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	0f
	bclr	#BIT_FIRE1,d0
0:
	btst	#JPB_BTN_BLU,d1
	beq.b	0f
	bclr	#BIT_FIRE2,d0
0:

	movem.l	(a7)+,a0/d1
	rts


	
osd_read_dsw1:
	* actual dipswitches
	move.b	dip_switches_1,d0
	not.b	d0		| active low
	rts
osd_read_dsw2:
	* actual dipswitches
	move.b	dip_switches_2,d0
	moveq	#0,d0		| ATM cleared, related to coinage
	rts
osd_read_dsw3:
	* actual dipswitches
	move.b	dip_switches_3,d0
	not.b	d0		| active low
	rts

	


	

level2_interrupt:
	jbsr		handle_keyboard
	move.w	#8,_custom+intreq
	rte
	
handle_keyboard:
	movem.l	D0/A0/A5,-(a7)
	LEA	0x00BFD000,A5
	MOVEQ	#0x08,D0
	AND.B	0x1D01(A5),D0
	jeq		1f
	MOVE.B	0x1C01(A5),D0
	NOT.B	D0
	ROR.B	#1,D0		| raw key code here
  
	CLR.B	0x1C01(A5)
  
    lea keyboard_table,a0
    bclr    #7,d0
    seq (a0,d0.w)       | updates keyboard table
    jne   2f     | we don't care about key release
	
    cmp.b   #0x19,d0	| "P" key
    bne.b   0f

    jbsr	toggle_pause
0:

	btst	#4,cheat_flags+3
	jeq		10f
	* cheat keys
	cmp.b	#0x50,d0	| F1 key
	bne.b	0f
	st.b	cheat_used
	* end current level
	jbsr 	level_completed
0:
	cmp.b	#0x51,d0	| F2 key
	bne.b	0f
	st.b	cheat_used
	jbsr	boss_low_energy
0:
	cmp.b	#0x52,d0	| F3 key
	bne.b	0f
	st.b	cheat_used
	* add 10000 points
0:
	cmp.b	#0x53,d0	| F4 key
	bne.b	0f
	st.b	cheat_used
	move.w	#0x0FF,_custom+color
	eor.b	#1,invincible_flag
0:
	cmp.b	#0x54,d0	| F5 key
	bne.b	0f
	st.b	cheat_used
	move.w	#0x0FF,_custom+color
	* award knife
	move.b	#4,d0
	jbsr	award_weapon
	jra		2f
	
0:
	cmp.b	#0x55,d0	| F6 key
	bne.b	0f
	st.b	cheat_used
	move.w	#0x0FF,_custom+color
	* award nunchuck
	move.b	#2,d0
	jbsr	award_weapon
	jra		2f
	
0:
*
10:
	.ifndef	RELEASE
	cmp.b	#34,d0
	bne		0f
	* 'D': debug scrolling display on/off
	eor.b	#1,debug_scroll_display
0:
	.ifne	OPT_ENABLE_LOGGING
	cmp.b	#17,d0
	bne		0f
	* 'W' (from QWER..): dump all logging buffers to data dir
	jbsr	dump_logs
0:
	.endif
	cmp.b	#20,d0
	bne		0f
	* 'T': toggle truck manual control on/off
	eor.b	#1,debug_truck_control
	move.b	debug_truck_control,debug_scroll_display
0:
	cmp.b	#37,d0
	bne		0f
	* 'H': toggle bobs display
	eor.b	#1,stop_updating_bobs
0:
	cmp.b	#32,d0
	bne		0f
	* 'A': move truck by 1 pixel left
	move	#-1,debug_truck_move
0:
	cmp.b	#33,d0
	bne		0f
	* 'S': move truck by 1 pixel right
	move	#1,debug_truck_move
0:
	cmp.b	#16,d0
	bne		0f
	* 'Q': move truck by 10 pixels left
	move	#-0x10,debug_truck_move
0:
	cmp.b	#17,d0
	bne		0f
	* 'W': move truck by 10 pixels right
	move	#0x10,debug_truck_move
0:
	cmp.b	#0x57,d0	| F8 key: lose all lives
	bne.b	0f
	move.w	#0x0FF,_custom+color
	move.l	a6,-(A7)
	* last life, if killed, direct game over
	GET_RAM_START_IN_A6 
	clr.b	(0x239A,A6)	| 0 lives
	move.b	#1,(0x2380,A6)	| 1 energy
	move.l	(a7)+,a6
0:
	cmp.b	#0x58,d0	| F9 key crashes game (restarts whdload)
	bne.b	0f
	illegal
	.endif
0:

	cmp.b	_keyexit,d0	| "ESC" key or whdload quitkey
	bne.b	2f
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	jbsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key
	bra		quit_to_os
2:
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	jbsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key

1:
	movem.l	(a7)+,d0/a0/a5
	rts
	
toggle_pause:
	* pause only within game
	jbsr		is_game_playing
	beq.b	0f
	eor.b   #1,pause_flag
0:
	rts

clear_forest_background_colors:
	movem.l	a0/a1/d0,-(a7)
	lea	forest_colors,a0
	lea	forest_colors_end,a1
	move.l	#0x1FE0000,d0	| nop copper
0:
	move.l	d0,(a0)+
	cmp.l	a0,a1
	jne		0b
	movem.l	(a7)+,a0/a1/d0
	rts
	
set_forest_background_colors:
	lea	forest_colors,a0
	lea	forest_colors_end,a2
	lea	forest_object_colors_block,a1
0:
	move.l	(a1)+,(a0)+
	cmp.l	a0,a2
	jne		0b
	rts
	
* set all sprites to blank, also position the sprite registers
clear_all_hardware_sprites:
	movem.l	d0-d2/a0,-(a7)
	move.l	#blank_sprite,d1
	lea		osd_upper_sprites,a0
	move.w	#sprpt,d0
	move.w	#NB_HOST_SPRITES-1,d2		| 7
0:
	move.w	d0,(a0)+
	swap	d1
	move.w	d1,(a0)+
	swap	d1
	addq	#2,d0
	move.w	d0,(a0)+
	move.w	d1,(a0)+
	
	addq	#2,d0
	dbf		d2,0b
	
	lea		osd_lower_sprites,a0
	move.w	#sprpt,d0
	move.w	#NB_HOST_SPRITES/2-1,d2		| 3
0:
	move.w	d0,(a0)+
	swap	d1
	move.w	d1,(a0)+
	swap	d1
	addq	#2,d0
	move.w	d0,(a0)+
	move.w	d1,(a0)+
	
	addq	#2,d0
	dbf		d2,0b
	
	
	movem.l	(a7)+,d0-d2/a0
	rts
	
wait_vbl:
	lea	_custom,a5
	move.w	#0x7FFF,intreq(a5)
0:
	move.w	intreqr(a5),d1
	btst	#5,d1
	beq.b	0b
	rts	
	
remove_optional_sounds:
	lea	optional_sounds,a0
	lea	sound_structs,a1
0:
	move.w	(a0)+,d0
	jmi		1f
	* zero previously loaded optional sound
	clr.l	([a1,d0.w*4])
	jra		0b
1:
	rts
	
	
osd_set_context:
	movem.l	d0-a6,-(a7)
	move.w	d0,-(a7)		| save in d7

	jbsr	wait_vbl
	jbsr	wait_vbl
	* then we can safely load the new context
	jbsr	save_interrupt_state
	jbsr	osd_disable_interrupts
	
	* we need to make sure that the sprite update interrupt is updating the
	* sprites while we're changing the sprite set, or it can cause issues
	* so first we set the flag to clear sprites from memory
	st		clear_target_sprites_flag
	* remove pointer on truck planes, this will disable any remaining truck
	* draw, and also front objects
	clr.l	sprite_table_base
	clr.l	big_machine_planes
	clr.l	big_machine_extra_planes
	clr.l	heli_planes
	move.w	#NB_BYTES_PER_SCREEN_ROW*16,big_machine_x_offset
	* no bottom scrolling
	jbsr	disable_road_scroll

	* clear scroll swap shit
	clr.b	nb_scroll_swaps
	* each level starts on Y scroll < 0x100
	* clear this to avoid swap when warping 6 -> 7
	clr.w	y_background_scroll_value
	clr.w	y_extra_offset
	* full Y range per default
	move.w	#NB_PLAYFIELD_LINES*2,y_max
	move.w	#0x0,y_min
	
	move.w	#SCROLL_NONE,y_scroll_command
	
	* free music
	clr.l	current_tune
	
	
	* level 7 part 2 loaded flag
	clr.b	level_7_load_second_part_loaded
	clr.b	level_7_load_second_part_flag
	
	* no forest background colors
	jbsr	clear_forest_background_colors
	
	* default for operation on 24Axxx => normal
	move.l	#addr_24Axxx_tile_layer_op,addr_24Axxx_tile_layer_op_address
	move.l	#addr_24Dxxx_tile_layer_op,addr_24Dxxx_tile_layer_op_address
	move.l	#addr_246xxx_op,addr_246xxx_tile_layer_op_address
	
	* default: sprites above
	move.w	#BASE_BPLCON2_VALUE,sprites_bplcon2
	* no attached sprites

	move.w	#0x1FE,attached_sprites_bplcon4
	* then we wait a little while to make sure the interrupt has run
	
	cmp.w	#CTX_GAME,d0
	jeq		0f
	cmp.w	global_context,d0
	jeq		2f		| skip if context already set (except for game)
0:
	* remove front objects
	clr.l	front_objects_table
	
	* reset road color
	lea		road_colors,a0
	move.w	#15,d0
0:
	move.l	#0x01FE0000,(a0)+
	dbf		D0,0b
	
	* clear screens
	move.l	fg_displayed_screen_ptr,a1
	move.w	#SCREEN_SIZE/16-1,d0
0:
	clr.l	(a1)+
	clr.l	(a1)+
	clr.l	(a1)+
	clr.l	(a1)+
	dbf	d0,0b
	move.l	fg_drawed_screen_ptr,a1
	move.w	#SCREEN_SIZE/16-1,d0
0:
	clr.l	(a1)+
	clr.l	(a1)+
	clr.l	(a1)+
	clr.l	(a1)+
	dbf	d0,0b
	
	* remove all front objects
	jbsr	clear_all_hardware_sprites
	* remove optional sounds
	jbsr	remove_optional_sounds
	move.l	fg_drawed_screen_ptr,fg_displayed_screen_ptr
	
	move	(a7)+,d0		| restore state
	
	* by default, no double buffering on non-game parts
	move.w	d0,global_context
	
	* remove everything dynamically loaded
	jbsr	free_all_memory
	* clean slate for logs, each context has a new log
	jbsr	clear_log_memory
	clr.l	tile_data_24a000
	clr.l	tile_data_244000
	
	lea		game_context_table,a0
	jsr		([a0,d0.w*4])
1:
	jbsr	restore_interrupt_state
	movem.l	(a7)+,d0-a6
	rts
2:
	move	(a7)+,d0		| restore state
	jra		1b
	
save_interrupt_state:
	lea	_custom,a5
	move.w	(intenar,a5),saved_intena
	rts
restore_interrupt_state:
	lea	_custom,a5
	move.w	saved_intena,d0
	bset	#15,d0
	move.w	d0,(intena,a5)
	rts
	

	
clear_log_memory:
	.ifne	OPT_ENABLE_LOGGING
	* context change: clear tile log: it is no longer relevant
	lea	tile_log_table_244000,a0
0:
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	cmp.l	#tile_log_table_end,a0
	jne	0b
	.endif
	rts
	
game_context_table:
	.long	0
	.long	set_intro_context			| CTX_INTRO
	.long	set_high_score_context		| CTX_HIGH_SCORE
	.long	set_game_intro_context	    | CTX_GAME_INTRO
	.long	set_game_context		    | CTX_GAME
	.long	set_ending_1_context	    | CTX_ENDING_1
	.long	set_ending_2_context	    | CTX_ENDING_2
	
load_tiles_file_244000:
	jbsr	allocate_and_load_public_mem_file
	move.l	d0,tiles_244000
	* set palette
	move.l	d0,a0
	add.w	#4+(56*2),a0	| skip nb planes (6) plus 56 dummy colors

	move.l	a0,tiles_palette_244000

	move.l	tiles_244000,a0
	add.w	#4+(64*2),a0	| skip nb planes (6) plus palette
	
	move.l	a0,tile_data_244000
	
	jbsr	load_tiles_palette_244000
	
	rts
	
load_tiles_file_as_sprites_244000:
	jbsr	allocate_and_load_public_mem_file
	move.l	d0,tiles_244000
	* set palette
	move.l	d0,a0
	addq.w	#4,a0	| skip header

	move.l	a0,tiles_palette_244000

	move.l	tiles_244000,a0
	add.w	#4+(4*2),a0	| skip header + 4 colors
	
	move.l	a0,tile_data_244000
		
	rts
	
load_tiles_file_24a000:
	jbsr	allocate_and_load_public_mem_file
	move.l	d0,a0
	move.w	(a0)+,d0	| nb planes
	move.w	(a0)+,d1	| nb block planes (ignored)
	move.l	a0,tiles_palette_24a000
	move.w	d0,nb_tile_planes_24da		| save it for later
	moveq	#0,d1
	bset	d0,d1
	move.w	d1,nb_tile_colors_24a000
	add.w	d1,d1
	add.w	d1,a0
	move.l	a0,tile_data_24a000	 			| save it for later
	rts
	

load_tiles_file_24d000:
	jbsr	allocate_and_load_public_mem_file
	move.l	d0,a0
	move.w	(a0)+,d0	| nb planes
	move.w	(a0)+,d1	| nb block planes (ignored)
	move.l	a0,tiles_palette_24d000
	move.w	d0,nb_tile_planes_24da		| save it for later
	moveq	#0,d1
	bset	d0,d1
	move.w	d1,nb_tile_colors_24d000
	add.w	d1,d1
	add.w	d1,a0
	move.l	a0,tile_data_24d000	 			| save it for later
	rts
	
load_tiles_palette_244000:
	move.l	tiles_palette_244000,a0
	lea		letters_palette,a1
	move.w	#8,d0
	jbsr	load_palette
	rts

* < D0: nb of background planes to save	
allocate_background_buffer:
	* max 5 planes, can be 4 too ATM 6 for convenience (8x8 fonts)
	move.l	#NB_BYTES_PER_ROW,d1
	mulu.w	d0,d1
	* depends on y min/max (allows to save memory ex train level)
	move.w	y_max,d0
	sub.w	y_min,d0
	mulu.w	d0,d1
	exg		d0,d1
	
	moveq	#1,d1
	jbsr	allocate_memory		| chip
	move.l	d0,background_restore_buffer
	rts
	
************************
* END SEQUENCE CONTEXT *
************************

set_ending_1_context:
	* ending music is much bigger than the others
	* but we have a lot of memory free in the ending sequence
	* so we can use a normal allocation
	*
	* another hack: we load the tune at start so when the context
	* changes to ending_2, we can avoid overwrite
	

	lea		ending_music_file,a0
	jbsr	allocate_and_load_chip_mem_file
	move.l	a1,current_tune
	move.l	chip_memory_current_ptr,ending_1_chipmem_start
	
	* now allocate the rest
	lea		tiles_ending_1_24a000_file,a0
	jbsr	load_tiles_file_24a000
	lea		tiles_title_244000_file,a0
	jbsr	load_tiles_file_244000
	
	move.l	tiles_palette_24a000,a0		| palette
	jbsr	load_tiles_palette

	* re-apply letter colors 56-63 (the sprites in that context only use 24 colors
	* so we're good!)
	jbsr	load_tiles_palette_244000
	
	rts
	
set_ending_2_context:
	* "allocate" chunk of memory so playing tune isn't overwritten
	move.l	ending_1_chipmem_start,chip_memory_current_ptr
	
	lea		tiles_ending_2_24d000_file,a0
	jbsr	load_tiles_file_24d000
	lea		tiles_title_244000_file,a0
	jbsr	load_tiles_file_244000
	
	move.l	tiles_palette_24d000,a0		| palette
	jbsr	load_tiles_palette

	* re-apply letter colors 56-63 (the sprites in that context only use 24 colors
	* so we're good!)
	jbsr	load_tiles_palette_244000
	
	move.l	#nope,addr_24Axxx_tile_layer_op_address
	move.l	#addr_24Dxxx_tile_layer_op_level_3,addr_24Dxxx_tile_layer_op_address

	rts
	
**********************
* GAME INTRO CONTEXT *
**********************

set_game_intro_context:
	jbsr	remove_dudes

	lea		intro_sound_file,a0
	jbsr	load_extra_sound_file
	
	lea		tiles_game_intro_244000_file,a0
	jbsr	load_tiles_file_244000

	
	lea		tiles_game_intro_24a000_file,a0
	jbsr	load_tiles_file_24a000

	move	#NB_PLAYFIELD_PLANES,d0   | all 6 planes
	jbsr	allocate_background_buffer
	
	jbsr	load_intro_palette
	
	* load a few sprites: glasses & talking mouth of the guy
	
	lea		sprites_game_intro_file,a0
	jbsr 	load_sprite_file
	
	* re-apply letter colors 56-63 (the sprites in that context only use 24 colors
	* so we're good!)
	jbsr	load_tiles_palette_244000
	rts
	
load_extra_sound_file:
	jbsr	allocate_and_load_chip_mem_file
	move.l	d0,a0

	lea		sound_structs,a2
	* now read the table, and relocate, to the shared sound table
0:
	move.l	(a0)+,d1
	jmi		1f
	move.l	(a0)+,a1
	add.l	d0,a1		| absolute sound data pointer
	* now put that in the sound table at the proper location
	move.l	a1,([a2,d1.w*4])
	jra		0b
1:	
	rts
	

* can be called separately
load_bobs_palette:
	movem.l	d0-d1/a0-a1,-(a7)
	move.l	sprites_memory,a0
	move.w	nb_bob_skipped_colors,d0
	move.l	a0,a1
	lea	(a0,d0.w*2),a0	| skip first colors
	add.w	#0x80,a1	| skip palette colors
	move.l	a1,sprite_table_base
	
	lea	base_palette,a1
	lea		(a1,d0.w*4),a1	| skip first colors
	sub.w	#64,d0
	neg.w	d0		| 32 or 48
	jbsr	load_palette
	movem.l	(a7)+,d0-d1/a0-a1
	rts
	
load_level_sprite_file:
	jbsr	get_current_level
	add.b	#48,d0
	add.b	level_7_load_second_part_flag,d0
	move.b	d0,file_level_index
	lea		sprites_game_level_file,a0
	* continues!!
load_sprite_file:
	jbsr	allocate_and_load_chip_mem_file
	move.l	d0,a0
	move.w	(a0)+,d0	| nb planes (6) ignore
	moveq	#0,d0
	move.w	(a0)+,d0	| first (skipped) colors
	
	move.w	d0,nb_bob_skipped_colors
	move.l	a0,sprites_memory
	
	jbsr	load_bobs_palette
	
	* relocate tile tables so they're no longer relative (generic blit routines
	* work like that, no need to rewrite them)
	* triple loop!
	
	move.l	sprite_table_base,a0
	move.l	a0,d1
	move.w	#0x1FFF,d7		| number of sprites (plus multi-sized)
0:
	move.l	(a0)+,d2
	jeq		1f				| not defined: skip
	add.l	d1,d2			| add to displacement: pointer becomes absolute
	move.l	d2,(-4,a0)		| store
	* now relocate each clut
	move.w	#15,d6			| number of cluts
	move.l	d2,a1
10:
	move.l	(a1)+,d3
	jeq		2f
	add.l	d2,d3			| add to displacement: pointer becomes absolute
	move.l	d3,(-4,a1)		| store
	* now relocate each bitplane
	move.l	d3,a2
	.rept	2
	move.w	#NB_PLAYFIELD_PLANES+1-1,d5  | standard + mirror (bobs) with mask
	tst.w	(a2)
	* h=0 means this orientation is not computed, ATM only last (mirror) can be
	* computed or not, so this is a bit sketchy but who cares for now
	jeq		4f			
	addq	#6,a2		| skip h,w,y offset!
20:
	move.l	(a2)+,d4
	jeq		3f
	add.l	d3,d4
	move.l	d4,(-4,a2)		| store
3:
	dbf	d5,20b
4:
	.endr
2:
	dbf	d6,10b			| next clut
1:
	dbf	d7,0b			| next sprite
	rts
	
**********************
* HIGH SCORE CONTEXT *
**********************
	
set_high_score_context:
	jbsr	remove_dudes

	lea		tiles_title_244000_file,a0
	jbsr	load_tiles_file_244000
	move.w	#NB_PLAYFIELD_PLANES,d0
	jbsr	allocate_background_buffer
	
	lea		tiles_highs_24a000_file,a0
	jbsr	load_tiles_file_24a000

	jbsr	load_intro_palette
	
	rts

****************
* GAME CONTEXT *
****************

set_game_context:
	lea		tiles_game_244000_file,a0
	jbsr	load_tiles_file_as_sprites_244000
	clr.l	background_sprite_table
	
	jbsr	get_current_level
	subq	#1,d0	
	lea		specific_level_load_table(pc),a0
	jsr		([a0,d0.w*4])
	
	move.w	nb_tile_planes_24da,d0
	jbsr	allocate_background_buffer	

	move.l	fg_screen_data_1,fg_drawed_screen_ptr
	move.l	fg_screen_data_2,fg_displayed_screen_ptr

	jbsr	install_osd_hardware_sprites
	rts

	
set_intro_context:

	* load data files for intro

	lea		tiles_title_244000_file,a0
	jbsr	load_tiles_file_244000

	
	lea		tiles_title_24a000_file,a0
	jbsr	load_tiles_file_24a000
	move.w	#NB_PLAYFIELD_PLANES,d0
	jbsr	allocate_background_buffer
	
	lea		dudes_pics_files,a0
	jbsr	allocate_and_load_chip_mem_file
	move.l	d0,dude_pics
	
	* resolve relative relocs so generic blitter routines can be used
	* and it also avoids a lot of confusion & bugs
	* if we wanted more speed we could even copy the header into fastmem after that
	* but for intro pics it's probably not worth it
	
	move.l		dude_pics,a0
	move.l	d0,a0
	* dude pic struct relative => absolute
	add.l		d0,(a0)
	add.l		d0,(4,a0)
	
	moveq	#1,d1
0:
	move.l	(a0)+,a1	| pointer on dude pic struct
	move.l	a1,d2
	add.w	#0x40+8,a1	| skip palette & size
	moveq	#6,d0		| 6 bitplanes + mask
1:
	add.l	d2,(a1)+	| relocate to absolute
	dbf		d0,1b
	dbf		d1,0b
	
	
	* set intro copperlist
	
	lea		_custom,a5
	* set them even if reset by game afterwards
	* avoiding ugly stripe bitplane effect at startup
	jbsr		set_playfield_bitplanes

	jbsr	load_intro_palette
	
	
	lea		intro_copperlist,a0
	move.l	a0,cop1lc(a5)

	rts

specific_level_load_table:
	.long	level_1_load
	.long	level_2_load
	.long	level_3_load
	.long	level_4_load
	.long	level_5_load
	.long	level_6_load
	.long	level_7_load
	
* return D0: planes, D1: extra planes (or 0)
load_big_machine:
	jbsr	allocate_and_load_chip_mem_file
	move.l	d0,big_machine_pic
	move.l	d0,a0
	move.w	(a0)+,big_machine_nb_planes
	move.w	(a0)+,big_machine_width
	move.w	(a0)+,big_machine_height
	move.w	(a0)+,truck_y_pos
	move.w	(a0)+,truck_wheels_height
	move.l	(a0)+,d0
	move.l	d0,big_machine_extra_pic
	jeq		0f
	add.l	a0,d0	| make data absolute
	move.l	d0,big_machine_extra_pic
0:
	* make data absolute
	move.w	#NB_PLAYFIELD_PLANES,d0		| + mask
	move.l	a0,d1		| base pointer
0:
	move.l	(a0)+,d2
	jeq		1f
	add.l	d1,d2
	move.l	d2,(-4,a0)
1:
	dbf		d0,0b
	move.l	d1,big_machine_planes
	
	move.l	big_machine_extra_pic,d2
	jeq		10f
	* there's an extra pic stored: get dimensions & relocate the data
	move.l	d2,a0
	move.w	(a0)+,big_machine_extra_pic_width
	move.w	(a0)+,big_machine_extra_pic_height
	* now A0 is the base for extra planes
	move.w	#NB_PLAYFIELD_PLANES,d0		| + mask
	move.l	a0,d1		| base pointer of extra pic
	move.l	d1,big_machine_extra_planes
0:
	move.l	(a0)+,d2
	jeq		1f
	add.l	d1,d2
	move.l	d2,(-4,a0)
1:
	dbf		d0,0b
10:
	rts

* < A0: filename	
load_background_file:
	jbsr	allocate_and_load_chip_mem_file
	move.l	d0,a0
	move.l	d0,background_sprite_table
	moveq	#7,d1
	* relocate
0:
	add.l	d0,(a0)+
	dbf		d1,0b
	move.l	a0,background_sprites_palette
	rts
	

* display a front object
* < D0: X
* < D2: object index (-1: blank object)
* < D3: sprite slot (0,1,2,3)
* sprite slots 0 and 1 don't multiplex to the lower sprites
* sprite slots 2 and 3 need to yield control to the lower osd sprites (TODO)
display_front_object:
	movem.l	d0-a6,-(a7)
	sub.l	a6,a6
	tst		d2
	jpl		0f
	moveq	#0,d1
	sub.l	a2,a2
	sub.l	a5,a5
	moveq	#16,d6
	jra		1f
0:
	move.l	front_objects_y_table,a0
	move.w	(a0,d2.w*2),d1
	move.l	front_objects_table,a0
	lsl.w	#4,d2
	add.w	d2,a0
	move.l	(a0),a2			| part #1
	move.l	(8,a0),a5		| part #2
	move.w	(-2,a2),d6		| height
1:	
	lea		sprite_y_table_table,a4
	move.l	(a4,d6.w*4),d6	| get proper height table
	.ifndef	RELEASE
	jne		0f
	BREAKPOINT	"unsupported sprite size (in D2)"
	illegal
0:
	.endif
	
	move.l	d6,a1
	jbsr	store_sprite_pos

	* enable multiplexed sprite for sprites 0-3 to link with upper OSD
1:

	lea		upper_osd_next_cw_table,a3
	cmp.w	#2,d3
	jcs		2f
	* not multiplexed: sprite scan starts with front object
	lea		free_front_sprites,a1
	cmp.l	a6,a2
	jne		1f
	moveq	#0,d0		| blank: don't display, don't multiplex
1:
	move.w	d3,d5
	lsl.w	#3,d5
	lea		(a1,d5.w),a1
	jra		10f 		| TEMP do nothing
	
2:
	cmp.l	a6,a2
	jne		1f
	moveq	#0,d0		| blank: don't display, but still multiplex (restore upper/lower OSD link)
1:

	* multiplexed
	move.w	d3,d5
	lsl.w	#4,d5
	add.w	d5,a3		| pick proper slots start 0-1 or 2-3
	move.l	(a3),a0
	* before overwriting the cw, save it: it is the control word
	* for lower OSD sprites
	* we have to pick the proper OSD lower sprite slot
	
	* BUG: this writes to 0 ...
	move.l	(4,a3),a1
	move.w	(8,a0),(8,a1)
	move.w	d0,(8,a0)
	swap	d0
	move.w	(a0),(a1)
	move.w	d0,(a0)
	swap	d0
	
	move.l	(8,a3),a0
	move.l	(12,a3),a1
	bset	#7,d0			| attach
	move.w	(8,a0),(8,a1)
	move.w	d0,(8,a0)
	swap	d0
	move.w	(a0),(a1)
	move.w	d0,(a0)
	
	cmp.l	a6,a2
	jeq		1f

	* position sprite in copperlist
	lea		front_object_sprites,a0
	move.w	d3,d2
	lsl.w	#4,d2
	add.w 	d2,a0			| where to put the sprpos
	move.l	a2,d0
	add.w	#16,d0			| skip CW, handled by osd sprite above
	move.w	d3,d2
	lsl.w	#3,d2
	add.w	#sprpt,d2		| starting sprite pointer

	move.w	d2,(a0)+
	swap	d0
	move.w	d0,(a0)+
	swap	d0
	addq	#2,d2
	move.w	d2,(a0)+
	move.w	d0,(a0)+
	addq	#2,d2
	
	move.l	a5,d0
	add.w	#16,d0			| skip CW, handled by osd sprite above
	move.w	d2,(a0)+
	swap	d0
	move.w	d0,(a0)+
	swap	d0
	addq	#2,d2
	move.w	d2,(a0)+
	move.w	d0,(a0)+
1:
10:
	movem.l	(a7)+,d0-a6
	rts

load_fist_of_fury:
	lea		fist_of_fury_music_file,a0
	jbsr	allocate_and_load_music_module
	rts
	
load_greased_lightning:
	lea		greased_lightning_music_file,a0
	jbsr	allocate_and_load_music_module
	rts
		


	
level_1_load:
	lea		dogs_sound_file,a0
	jbsr	load_extra_sound_file
	
	jbsr	load_fist_of_fury
	lea		tiles_level_1_24a000_file,a0
	jbsr	load_level_tiles_and_bobs

	lea		front_objects_1_file,a0
	jbsr	load_front_objects_file
	* load & relocate truck pics
	lea		truck_1_pic_file,a0
	jbsr	load_big_machine

	
	* testing front objects!!!
	*move	#55,D0
	*move	#2,d2
	*move	#0,d3
	*jbsr	display_front_object
	*move	#156,D0
	*move	#3,d2
	*move	#1,d3
	*jbsr	display_front_object
	
	*move.w	#0x100,y_min
	rts	
	
level_2_load:
	jbsr	load_greased_lightning
	lea		tiles_level_2_24a000_file,a0
	jbsr	load_level_tiles_and_bobs
	
	lea		front_objects_2_file,a0
	jbsr	load_front_objects_file

	* load & relocate truck pics
	lea		truck_2_pic_file,a0
	jbsr	load_big_machine

	
	move.b	#0xB,road_y_pos
	jbsr	enable_bottom_scroll
	
	* limit restore buffer allocation
	move.w	#0x100,y_max
	
	rts
	
level_3_load:	
	lea		clone_boss_sound_file,a0
	jbsr	load_extra_sound_file

	jbsr	load_fist_of_fury

	lea		tiles_level_3_24d000_file,a0
	jbsr	load_tiles_file_24d000
	lea		tiles_level_3_24a000_file,a0
	jbsr	load_tiles_file_24a000
	move.l	tiles_palette_24d000,a0		| palette
	jbsr	load_tiles_palette
	jbsr 	load_level_sprite_file

	* change behaviour for write to 24Axxx: this controls the running water
	* only on this level, other background tiles are using second tile layer
	move.l	#addr_24Axxx_tile_layer_op_level_3,addr_24Axxx_tile_layer_op_address
	move.l	#addr_24Dxxx_tile_layer_op_level_3,addr_24Dxxx_tile_layer_op_address
	move.l	#addr_246xxx_op_level_3,addr_246xxx_tile_layer_op_address



	move.b	#0x4,road_y_pos
	jbsr	enable_bottom_scroll

	
	* install running water palette (bottom of screen)
	lea		road_colors,a0
	move.l	tiles_palette_24a000,a1
	move.w	#15,d0
	move.w	#color,d1
0:
	move.w	d1,(a0)+
	move.w	(a1)+,(a0)+
	addq	#2,d1		| next color
	dbf		d0,0b
	rts
	
* forest level
level_4_load:
	lea		dogs_sound_file,a0
	jbsr	load_extra_sound_file
	lea		animal_sound_file,a0
	jbsr	load_extra_sound_file

	jbsr	load_fist_of_fury

	lea		tiles_level_4_24a000_file,a0
	jbsr	load_level_tiles_and_bobs

	lea		forest_sprites_file,a0
	jbsr	load_background_file

	* install forest background colors
	jbsr	set_forest_background_colors

	rts
	
level_5_load:
	jbsr	load_greased_lightning

	lea		tiles_level_5_24a000_file,a0
	jbsr	load_level_tiles_and_bobs

	* load & relocate truck pics
	lea		train_pic_file,a0
	jbsr	load_big_machine

	* seems not to follow the offset shit
	sub.w	#512,big_machine_x_offset
	
	move.b	#0xB,road_y_pos
	jbsr	enable_bottom_scroll

	* limit restore buffer allocation, fortunately
	* we only need half the screen size to restore tiles
	* which allows to load the train in one go
	* 
	* I know the memory model of this game isn't optimal
	* but the programming is complex enough without having to
	* code multi-part blits, 8 way scrolling tricks and all...
	move.w	#0x100,y_max

	rts
	
level_6_load:
	lea		dogs_sound_file,a0
	jbsr	load_extra_sound_file

	jbsr	load_fist_of_fury
	lea		tiles_level_6_24a000_file,a0
	jbsr	load_level_tiles_and_bobs

	lea		cave_sprites_file,a0
	jbsr	load_background_file

	rts
	
level_7_load:
	lea		animal_sound_file,a0
	jbsr	load_extra_sound_file

	jbsr	load_fist_of_fury
	lea		tiles_level_7_24a000_file,a0
	jbsr	load_level_tiles_and_bobs
	
	lea		heli_pic_file,a0
	jbsr	load_big_machine
	move.l	big_machine_planes,heli_planes
	clr.l	big_machine_planes
	
	rts
	
level_7_load_second_part:

	.ifne	OPT_ENABLE_LOGGING
	* clear sprite log from stuff that won't repeat in the upper
	* part of the level, saving a lot of sprite memory
	lea		sprite_log_table_ffc000,a0
	move.w	#0x3FFF,d2
10:
	clr.l	(a0)+
	dbf		d2,10b
	.endif
	* now we have to load the second part of level 7
	* reset memory pointer just before sprites were loaded
	move.l	chip_memory_before_sprites_ptr,chip_memory_current_ptr
	jbsr 	load_level_sprite_file

	lea		dogs_sound_file,a0
	jbsr	load_extra_sound_file
	lea		clone_boss_sound_file,a0
	jbsr	load_extra_sound_file
		
	clr.b	level_7_load_second_part_flag
	move.b	#1,level_7_load_second_part_loaded
	
	rts
	
load_level_tiles_and_bobs:
	jbsr	load_tiles_file_24a000
	move.l	tiles_palette_24a000,a0		| palette
	jbsr	load_tiles_palette
	* load bobs, possibly overwriting tiles
	* end of palette (the unused colors)
	move.l	chip_memory_current_ptr,chip_memory_before_sprites_ptr
	jbsr 	load_level_sprite_file
	rts
	
* inefficient but rarely called algorithm to search a color
* in the copperlist and change it by another
* < A0: palette change list (ends by -1.L)
change_palette:
	* first, reset palette as it was at start of the level
	* (not useful, except for last level boss rush)
	jbsr	load_bobs_palette

	movem.l	d0-d2/a1,-(a7)
0:
	move.l	(a0)+,d2
	jmi	3f
	swap	d2		| search key D2.W
	* from end of color
	lea	base_palette_end-4,a1
	move.w	#63,d0
1:
	move.w	(a1)+,d1
	* check if copperlist entry is not a bank switch
	cmp.w	#bplcon3,d1
	jeq		4f
	move.w	(a1)+,d1
	cmp.w	d1,d2
	jne		2f
	* found a matching color: replace by the other one
	swap	d2
		
	move.w	d2,(-2,a1)

	* next color to replace
	jra	0b
2:
	subq	#8,a1
	dbf		d0,1b
	jra		0b		| next search entry
3:
	movem.l	(a7)+,d0-d2/a1
	rts
4:
	subq	#6,a1
	jra		1b		| bank switch, skip this copperlist entry

	
load_front_objects_file:
	jbsr	allocate_and_load_chip_mem_file
	move.l	D0,front_objects_palette
	move.l	d0,a0
	add.w	#0x20,a0
	move.w	(a0)+,d0
	move.w	d0,nb_front_objects
	move.l	a0,front_objects_y_table
	lea		(a0,d0.w*2),a0
	move.l	a0,front_objects_table
	move.l 	a0,d2		| base
	move.w	nb_front_objects,d0
	add.w	d0,d0
	add.w	d0,d0		| 4 pointers per object
	subq	#1,d0
	* make it absolute
0:
	add.l	d2,(a0)+
	dbf		d0,0b
	
	* install palette
	move.l	front_objects_palette,a1
	* set color registers for attached sprites palette
	lea		front_object_colors+2,a0
	move.w	#15,d0
0:
	move.w	(a1)+,(a0)
	addq	#4,a0
	dbf		d0,0b
	
	* enable attached sprite colorbank
	move.w	#bplcon4,attached_sprites_bplcon4
	rts
	
copy_osd_sprite_palette:
	* 2 first sprites (upper part)
	moveq	#3,d1
1:
	move.l	tiles_palette_244000,a1
	moveq	#3,d0
0:
	move.w	(a1)+,(a0)
	addq	#4,a0
	dbf		d0,0b
	dbf		d1,1b
	rts
	
install_osd_hardware_sprites:
	* same palette for sprites, but separate slots
	* so we can use separate palette for background objects
	lea		sprites_palette_even+2,a0
	jbsr	copy_osd_sprite_palette
	
	lea		sprites_palette_odd+2,a0
	jbsr	copy_osd_sprite_palette
	
	* now put them on screen
	lea		osd_upper_sprites,a0
	lea		osd_left_sprite,a2
	move.l	a2,a3
	move.w	#40+HW_SPRITE_SHIFT,d0
	move.w	#32,d1
	move.w	#sprpt,d2
	jbsr	install_osd_sprite
	lea		osd_left_center_sprite,a2
	move.l	a2,a3
	move.w	#40+64+HW_SPRITE_SHIFT,d0
	move.w	#32,d1
	jbsr	install_osd_sprite
	lea		osd_right_center_sprite,a2
	move.l	a2,a3
	move.w	#40+64*2+HW_SPRITE_SHIFT,d0
	move.w	#32,d1
	jbsr	install_osd_sprite
	
	lea		osd_right_sprite,a2
	move.l	a2,a3
	move.w	#40+64*3+HW_SPRITE_SHIFT,d0
	move.w	#32,d1
	jbsr	install_osd_sprite
	
	* lower part reuse the same sprites 0-3 as multiplexed
	* which leaves sprites 4-7 free for other things
	
	move.w	#sprpt,d2		| start from sprite 0 again
	lea		upper_osd_next_cw_table,a4
	lea		osd_lower_sprites,a0
	lea		osd_bottom_left_sprite+16,a2
	move.l	(a4)+,a3
	move.w	#32+HW_SPRITE_SHIFT,d0
	move.w	#240,d1
	jbsr	install_osd_sprite
	
	lea		osd_bottom_left_center_sprite+16,a2
	move.l	(a4)+,a3
	move.w	#96+32+HW_SPRITE_SHIFT,d0
	move.w	#240,d1
	jbsr	install_osd_sprite
	
	lea		osd_bottom_right_center_sprite+16,a2
	move.l	(a4)+,a3
	move.l	a2,a3
	move.w	#96+32+64+HW_SPRITE_SHIFT,d0
	move.w	#240,d1
	jbsr	install_osd_sprite
	
	lea		osd_bottom_right_sprite+16,a2
	move.l	(a4)+,a3
	move.w	#216+HW_SPRITE_SHIFT,d0
	move.w	#240,d1
	jbsr	install_osd_sprite	
	

	* if forest or cave, we're already sprites 4 to 7
	* for static background
	move.l	background_sprite_table,d0
	jeq		10f

	lea		background_sprites,a0
	
	* change sprites vs bitplanes priority (partially)
	* sprites above for sprites 0-3, below for 4-7
	move.w	#SPRITES_BELOW_BPLCON2_VALUE,sprites_bplcon2
	
	* install palette for sprites 4,5,6,7 (background

	move.l	background_sprites_palette,a3
	lea		sprites_palette_even+2+32,a1	| colors for sprite 4
	lea		sprites_palette_odd+2+32,a2  | colors for sprite 5
	.rept	4
	move.w	(a3),(a1)
	addq	#4,a1
	move.w	(a3)+,(a2)		| odd
	addq	#4,a2
	.endr
	move.l	background_sprites_palette,a3
	.rept	4
	move.w	(a3),(a1)
	addq	#4,a1
	move.w	(a3)+,(a2)		| odd
	addq	#4,a2
	.endr

	
	* now install the sprites themselves
	move.l	d0,a4
	moveq	#32+HW_SPRITE_SHIFT,d0
	moveq	#0,d1
	moveq	#3,d7
0:
	movem.w	d0-d1,-(a7)
	lea		HW_SpriteYTable_240,a1
	move.l	(a4),a3
	move.l	a3,a2
	jbsr	install_any_sprite
	addq	#8,a1		| next sprite
	movem.w	(a7)+,d0-d1
	addq	#8,A4
	add		#64,d0		| next X
	dbf		d7,0b


10:	
	rts

	
* < A2: sprite start
* < A3: sprite control word (can be A2 or other for multiplexing)
* < D2: current sprpt
install_osd_sprite:
	lea		HW_SpriteYTable_16,a1
	subq	#1,d0		| apply small offset
install_any_sprite:
	move.l	a2,d3
	move.w	d2,(a0)+	| sprite pointer high address
	swap	d3
	move.w	d3,(a0)+	| high 16 bits address
	swap	d3
	addq	#2,d2
	move.w	d2,(a0)+	| sprite pointer low address
	move.w	d3,(a0)+	| low 16 bits address
	addq	#2,d2
	* position fixed
	jbsr	store_sprite_pos
	move.w	d0,8(a3)
	swap	d0
	move.w	d0,(a3)
	rts
	
	* set game intro palette
load_intro_palette:
	move.l	tiles_palette_24a000,a0		| palette
load_tiles_palette:
	lea		base_palette,a1
	move.w	nb_tile_colors_24a000,d0
	jbsr	load_palette
	rts
	

get_current_level:
	move.l	a6,-(a7)
	lea	0xff821d,a6
	moveq	#0,d0
	jbsr	osd_real_ram_address
	move.b	(a6),d0
	move.l	(a7)+,a6
	rts
	
remove_dudes:
	* clear dudes pics (basically lower part of screen)

	
* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
	lea	_custom,a5
	moveq	#0,d0
	move.w  #120,d1
	move.w	#256,d4
	sub.w	d1,d4
	move.w	#NB_BYTES_PER_ROW,d2
	move.w	#NB_PLAYFIELD_PLANES,d3		| all planes
	move.l	fg_drawed_screen_ptr,a1
	jbsr	clear_fg_planes_any_blitter_internal
	
	moveq	#0,d0
	move.w  #120,d1
	move.w	#256,d4
	sub.w	d1,d4
	move.w	#NB_BYTES_PER_ROW,d2
	move.w	#NB_PLAYFIELD_PLANES,d3
	move.l	fg_drawed_screen_ptr,a1
	jbsr	clear_fg_planes_any_blitter_internal
	

	
	WAIT_BLIT
	rts	
	
* < D0: numbers of vertical positions to wait
beamdelay:
0:
	move.w  d0,-(a7)
    move.b	0xdff006,d0	| VPOS
1:
	cmp.b	0xdff006,d0
	beq.s	1b
	move.w	(a7)+,d0
	dbf	d0,0b
	rts

osd_music_stop:

	tst.b	music_playing
	jne		force_sound_stop
	rts

force_sound_stop:
	movem.l	d0-d1/a0/a6,-(a7)
	lea		_custom,a6
	move.b	#-1,music_track_start_number
    clr.w   music_tick   | not playing anymore
	clr.b	music_playing
	clr.b	looped_sound_enabled
    jsr		_mt_end
0:
	movem.l	(a7)+,d0-d1/a0/a6
	rts
	
osd_sound_start:
	movem.l	d0/d1/a0/a6,-(a7)
	lea		_custom,a6
	and.w	#0xFF,d0
	jne		0f
	* null sound: stop
	jbsr	osd_music_stop
	jra		10f
0:



	lsl.w	#3,d0
	lea		sound_table,a0

	move.w	(a0,d0.w),d1	| sound type
	beq.b	10f		| no sound

2:
	cmp.w	#1,d1
	bne.b	4f		| music module
	move.w	(2,a0,d0.w),d1
	move.l	(4,a0,d0.w),a0
	tst.l	(a0)
	jeq		10f			| sound not loaded

	lea		_custom,a6
	tst.w	d1
	beq.b	3f
	tst.b	looped_sound_enabled
	bne.b	3f
	* looped sound
	st.b	looped_sound_enabled
	jsr		_mt_loopfx
	bra.b	10f
3:
	jsr		_mt_playfx
10:
	movem.l	(a7)+,d0/d1/a0/a6
	rts

	* music
4:
	* don't play if already playing
	* (music_tick value is not important for looped tunes
	* as long as it's not zero)


	* here we allow music to override another looping music
	*tst.w	music_tick
	*bne.b	10b
	* play the proper module pattern
	* load up the countdown if loop
	
	move.w	(2,a0,d0.w),d1	| pattern number in .mod file
	* since it's not zero, next vbl tick will play the music
	
	*cmp.b	music_track_start_number(pc),d1
	*beq.b	10b		| same track, skip

    movem.l d0-a6,-(a7)
	jbsr		force_sound_stop
	tst.l	current_tune
	jeq		5f
 	movem.l	d0/a0,-(a7)
    lea _custom,a6
	jbsr	handle_tune_switch
	move.l	current_tune,a0
	
	move.b	d1,music_track_start_number
	move.w	d1,d0
    sub.l   a1,a1		| samples are in the module
    jsr _mt_init
	movem.l	(a7)+,d0/a0

    * set master volume a little less loud if needed
	move.b	(6,a0,d0.w),music_volume
	move.b	(7,a0,d0.w),music_loops
	move.w	(2,a0,d0.w),music_pattern	| pattern number in .mod file
	move.w	(4,a0,d0.w),d2

	move.w	d2,music_duration
	move.w	d2,music_tick

    moveq	#0,d0
	move.b	music_volume(pc),d0
    jsr	_mt_mastervol
	st.b	music_playing
    jsr _mt_start
5:
    movem.l (a7)+,d0-a6
	
6:
	jra	10b
	.ifne	OPT_ENABLE_LOGGING
dump_logs:
	movem.l	d0-a6,-(a7)
	move.l	_resload(pc),a2
	lea		sprite_log_table_ffc000,a1
	lea		sprite_log_name(pc),a0
	lea		sprite_log_name_index(pc),a3
	move.l	#0x10000,d1
	jbsr	dump_sprite_log
 	lea		tile_log_table_24a000,a1
	lea		tile_24a000_log_name(pc),a0
	lea		tile_24a000_log_name_index(pc),a3
	move.l	#0x8000,d1
	jbsr	dump_log
 	lea		tile_log_table_24d000,a1
	lea		tile_24d000_log_name(pc),a0
	lea		tile_24d000_log_name_index(pc),a3
	move.l	#0x8000,d1
	jbsr	dump_log
	
	GET_RAM_START_IN_A6
	lea		sprites_ram_name(pc),a0
	lea	(0x4000,a6),a1		| sprites
	move.l	#0x800,d0
	jbsr	resload_SaveFile(a2)
	
    movem.l (a7)+,d0-a6
	rts
	
handle_tune_switch:
	cmp.w	#BOSS_TUNE_SND*8,d0
	jeq		110f
	cmp.w	#KARNOV_TUNE_SND*8,d0
	jne		111f
110:
	* both same module, in both cases module not loaded
	* but level tune loaded.
	* reuse memory
	jbsr	load_boss_music_module
	rts
111:
	cmp.w	#WIN_TUNE_SND*8,d0
	jne		112f
	jbsr	load_win_music_module
	
	
112:
	rts
	
dump_log:
	jbsr	get_current_level
	add.b	#0x30,d0
	move.b	d0,(a3)
	move.l	d1,d0
	jbsr	resload_SaveFile(a2)
	rts
	
dump_sprite_log:
	jbsr	get_current_level
	add.b	#0x30,d0
	add.b	level_7_load_second_part_loaded,d0
	move.b	d0,(a3)
	move.l	d1,d0
	jbsr	resload_SaveFile(a2)
	rts

sprites_ram_name:
	.asciz	"sprite_ram"
tile_24a000_log_name:
	.ascii	"level_"
tile_24a000_log_name_index:
	.asciz	"1_24a000"
tile_24d000_log_name:
	.ascii	"level_"
tile_24d000_log_name_index:
	.asciz	"1_24d000"
	
sprite_log_name:
	.ascii	"game_level_"
sprite_log_name_index:
	.asciz	"1"
	.align	2
	.endif

	

	
music_playing:
	.byte	0
looped_sound_enabled:
	.byte	0
music_loops:
	.byte	0
music_volume:
	.byte	0
music_track_start_number:
	.word	0
music_pattern:
	.word	0
music_tick:
	.word	0

music_duration:
	.word	0	
	
	MUL_TABLE	NB_BYTES_PER_ROW,512
	*MUL_TABLE	NB_BYTES_PER_SCREEN_ROW,512

	.align	4		| leave this long word alignment
program_args:	ds.l	64,0
program_args_end:
	.long	0		| add a longword else it overwrites the read args string in kick 1.3!
	.align	4
read_args_string:
	.byte	read_args_string_end-read_args_string
	.ascii	"INVINCIBLE/S,INFLIVES/S,STARTLEVEL/S,"
	.ascii	"CHEATKEYS/S,STARTLIVES/K/N"
read_args_string_end:
	.align	2


	.ifndef	RELEASE

write_videoram_out_of_range_error:
	.asciz	"write videoram out of range"
game_tile_not_registered_error:
	.asciz	"game tile (in D2) not registered"
title_tile_not_registered_error:
	.asciz	"title tile (in D2) not registered"
	
	.align	2
	.endif

old_intena:
	.long	0
old_dmacon:
	.long	0
old_sysvectors:
	ds.l	10
old_vbr:
	.long	0
old_syscoplist:
	.long	0
old_actiview:
	.long	0
old_stack:
	.long	0
return_address:
	.long	0
current_tune:
	.long	0
global_context:
	.word	0
display_dudes:
	.word	0
bltamask_long_value:
	.long	-1
front_objects_x_scroll:
	.word	0
x_background_scroll_value:
	.word	0
y_background_scroll_value:
	.word	0
y_extra_offset:
	.word	0
y_max:
	.word	0
y_min:
	.word	0
nb_bob_skipped_colors:
	.word	0
contents_of_x_scroll_246010:
	.word	0
contents_of_y_scroll_246012:
	.word	0
x_secondary_scroll_value:
	.word	0
y_secondary_scroll_value:
	.word	0
x_road_layer_scroll_value:
	.word	0
y_scroll_command:
	.word	0
first_half_flag:
	.byte	0
level_7_load_second_part_flag:
	.byte	0
level_7_load_second_part_loaded:
	.byte	0
clear_target_sprites_flag:
	.byte	0
nb_scroll_swaps:
	.byte	0
	.align	2
_tag:
		.long	WHDLTAG_MONITOR_GET
monitor:
		.long	0
		.long	WHDLTAG_CHIPREVBITS_GET
chiprevbits:
		.long	0
		.long	WHDLTAG_CUSTOM1_GET
cheat_flags:
		.long	0
		.long	WHDLTAG_CUSTOM2_GET
frameskip_flag:
		.long	0

		.long	WHDLTAG_CUSTOM3_GET
debug_options:
		.long	0
		.long	WHDLTAG_CUSTOM4_GET
dip_switch_start_level:
		.long	0
		.long	WHDLTAG_CUSTOM5_GET
dip_switch_start_lives:
		.long	0
	.long	0
dip_switches_1:
		.byte	0
dip_switches_2:
		.byte	0
dip_switches_3:
		.byte	0
current_gfx_bank:
	.byte	-1

mid_screen_interrupt:
	.byte	0
mid_screen_interrupt_count:
	.byte	0
	.align	2
system_vbr:
	.long	0

nb_erased_objects:
	.byte	0
flashing_flip_flop:
	.byte	0
graphics_update_counter_start:
	.byte	0
graphics_update_counter:
	.byte	0
truck_flip_flop:
	.align	2

host_sprites:
	ds.b	8*SPRITE_SIZEOF
keyboard_table:
	ds.b	0x100

	
interrupt_mode:
	.byte	0
	.align	2
	
pause_flag:
	.word	0

saved_intena:
	.word	0
vbl_counter:
	.word	0
_resload:
	.long	0
_joypad_state:
	.long	0
_previous_joypad_state:
	.long	0
_gfxbase:
	.long	0
_dosbase:
	.long	0

delay_timer:
	.word	0
one_out_of_five:
	.word	0
fg_screen_data_1:
	.long	0
fg_screen_data_2:
	.long	0
	

fg_drawed_screen_ptr:
	.long	0
fg_displayed_screen_ptr:
	.long	0


	.include	"sound_entries.68k"

update_tile_function:
	.long	0
_keyexit:
	.byte	0x45	| ESC by default unless whdload overwrites it

main_scroll_value:
	.byte	0

	
cheat_used:
	.byte	0
	.ifndef	RELEASE
debug_truck_control:
	.byte	0
stop_updating_bobs:
	.byte	0
debug_scroll_display:
	.byte	0
	.align	2
debug_truck_move:
	.word	0
* in 244758
	.ifndef	RELEASE
boss_life:
      .word	0x006A,0x0068,0x006B,0x069,0x006F,0x006F,0x006F,0x006F,0x006F,0x006F,0x006D,0
	.endif
	

	.ifne		OPT_BOSS_SPRITES_MOCKUP

mockup_palette_loaded:
	.word	0

mockup_boss_palette_load:
	tst.b	mockup_palette_loaded
	jne		0f
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-2
	lea		level_2_boss_color_change(pc),a0
	.endif
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-3
	lea		level_3_boss_color_change(pc),a0
	.endif
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-5
	lea		level_5_boss_color_change(pc),a0
	.endif
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-4
	jra		0f		| no color change
	.endif
	jbsr	change_palette
	st		mockup_palette_loaded
0:
	rts
	
sprite_ram_mockup:
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-2
	.include	"mockup/boss_2.68k"
	.endif
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-3
	.include	"mockup/boss_3.68k"
	.endif
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-4
	.include	"mockup/boss_4.68k"
	.endif
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-5
	.include	"mockup/boss_5.68k"
	.endif
	.ifeq		OPT_BOSS_SPRITES_MOCKUP-6
	.include	"mockup/boss_6.68k"
	.endif
	.endif

debug_truck_message:
	.asciz	"TPOS 000000"
	.endif
debug_scroll_message:
	.asciz	"SCRO 000000"
	.endif
intro_sound_file:
	.asciz	"intro_sounds.bin"
clone_boss_sound_file:
	.asciz	"clone_boss_sounds.bin"
animal_sound_file:
	.asciz	"animal_sounds.bin"
dogs_sound_file:
	.asciz	"dog_sounds.bin"
boss_fight_music_file:
	.asciz	"bd-bossfight.mod"
ending_music_file:
	.asciz	"bd-ending.mod"
stage_completed_music_file:
	.asciz	"bd-clear.mod"
fist_of_fury_music_file:
	.asciz	"bd-fist_of_fury.mod"
greased_lightning_music_file:
	.asciz	"bd-greasedlight.mod"
forest_sprites_file:
	.asciz	"forest.bin"
cave_sprites_file:
	.asciz	"cave.bin"
front_objects_1_file:
	.asciz	"front_objects_1.bin"
front_objects_2_file:
	.asciz	"front_objects_2.bin"
heli_pic_file:
	.asciz	"helicopter.bin"
truck_1_pic_file:
	.asciz	"truck_1.bin"
truck_2_pic_file:
	.asciz	"truck_2.bin"
train_pic_file:
	.asciz	"train.bin"
sprites_game_level_file:
	.ascii	"sprites_game_level_"
file_level_index:
	.asciz	"1.bin"
tiles_ending_1_24a000_file:
	.asciz	"tiles_ending_1_24a000.bin"
tiles_ending_2_24d000_file:
	.asciz	"tiles_ending_2_24d000.bin"
sprites_game_intro_file:
	.asciz	"sprites_game_intro.bin"
tiles_title_244000_file:
	.asciz	"tiles_title_244000.bin"
tiles_game_intro_244000_file:
	.asciz	"tiles_game_intro_244000.bin"
tiles_game_244000_file:
	.asciz	"tiles_game_244000.bin"
tiles_title_24a000_file:
	.asciz	"tiles_title_24a000.bin"
tiles_game_intro_24a000_file:
	.asciz	"tiles_game_intro_24a000.bin"
tiles_highs_24a000_file:
	.asciz	"tiles_highs_24a000.bin"
tiles_level_1_24a000_file:
	.asciz	"tiles_level_1_24a000.bin"
tiles_level_2_24a000_file:
	.asciz	"tiles_level_2_24a000.bin"
tiles_level_3_24d000_file:
	.asciz	"tiles_level_3_24d000.bin"
tiles_level_3_24a000_file:
	.asciz	"tiles_level_3_24a000.bin"
tiles_level_4_24a000_file:
	.asciz	"tiles_level_4_24a000.bin"
tiles_level_5_24a000_file:
	.asciz	"tiles_level_5_24a000.bin"
tiles_level_5_24d000_file:
	.asciz	"tiles_level_5_24d000.bin"
tiles_level_6_24a000_file:
	.asciz	"tiles_level_6_24a000.bin"
tiles_level_7_24a000_file:
	.asciz	"tiles_level_7_24a000.bin"
dudes_pics_files:
	.asciz	"dudes.bin"
rom_file:
	.asciz	"bad_dudes.bin"
dosname:
	.asciz	"dos.library"
graphicsname:
	.asciz	"graphics.library"
floppy_file:
	.asciz	"floppy"
temp_filename_buffer:
	.skip	255
	
  

	.align 2


	
* < d0.w: x
* < d1.w: y
* < a1: sprite pos table (depending on height)
* > d0.L: control word
store_sprite_pos:
	tst.w	d1
	jmi	0f
	cmp.w	#Y_MAX_SPRITE,d1
	jcc	0f

    move.l  a0,-(a7)

    lea	HW_SpriteXTable(pc),a0
	
	.ifdef	NO68020
    add.w	d0,d0
    add.w	d0,d0
    move.l	(a0,d0.w),d0
	move.w	d1,-(a7)
    add.w	d1,d1
    add.w	d1,d1
    or.l	(a1,d1.w),d0
	move.w	(a7)+,d1
	.else
    move.l	(a0,d0.w*4),d0
    or.l	(a1,d1.w*4),d0	
	.endc
    move.l  (a7)+,a0
    rts
0:
	moveq	#0,d0
	rts
	
	
HW_SpriteXTable:
	.set	reptn,0
	.rept 320
	.set	x,reptn+0x80
	.set reptn,reptn+1
    .byte  0,x>>1,0,x&1
  .endr

	.macro DEF_HW_SPRITE_Y_TABLE	height
HW_SpriteYTable_\height:
  .set	reptn,0
  .rept Y_MAX_SPRITE
	.set	ys,reptn+0x1c
	.set	ye,ys+\height
    .byte  ys&255, 0, ye&255, ((ys>>6)&4)+((ye>>7)&2)
	.set	reptn,reptn+1
  .endr
	.endm

	* only sprites with this height can be displayed
	DEF_HW_SPRITE_Y_TABLE	8
	DEF_HW_SPRITE_Y_TABLE	16
	DEF_HW_SPRITE_Y_TABLE	32
	DEF_HW_SPRITE_Y_TABLE	48
	DEF_HW_SPRITE_Y_TABLE	184
	DEF_HW_SPRITE_Y_TABLE	240

	.macro	STORE_SPRITE_Y_ENTRY	offset
	lea	HW_SpriteYTable_\offset,a1
	move.l	a1,(\offset*4,a0)
	.endm
	
init_sprite_y_table_table:
	lea	sprite_y_table_table,a0
	
	STORE_SPRITE_Y_ENTRY	8
	STORE_SPRITE_Y_ENTRY	16
	STORE_SPRITE_Y_ENTRY	32
	STORE_SPRITE_Y_ENTRY	48
	STORE_SPRITE_Y_ENTRY	184
	rts
	
public_memory_current_ptr:
	.long	0
chip_memory_current_ptr:
	.long	0
chip_memory_before_sprites_ptr:
	.long	0
ending_1_chipmem_start:
	.long	0
	
	* format of the file is first palette (32 bytes)
	* then main tile table that points to tile cluts, .. and
	* so on. It is readable in the tiles_0.68k file which is
	* pre-assembled so several tile files can be loaded depending
	* on the game phase
tiles_244000:		| address 0x244000
	.long	0
tiles_palette_24a000:		| address 0x24A000
	.long	0
tiles_palette_24d000:		| address 0x24D000
	.long	0
dude_pics:
	.long	0
big_machine_pic:
	.long	0
big_machine_extra_pic:
	.long	0
sprites_memory:
	.long	0
tile_data_24a000:
	.long	0
tile_data_244000:
	.long	0
nb_tile_planes_24da:
	.word	0

background_restore_buffer:
	.long	0
nb_tile_colors_24a000:
	.word	0
nb_tile_colors_24d000:
	.word	0
tiles_palette_244000:
	.long	0
sprite_table_base:
	.long	0
tile_data_24d000:
	.long	0
big_machine_planes:
	.long	0
big_machine_extra_planes:
	.long	0
heli_planes:
	.long	0
truck_nb_planes:
	.word	0
background_sprites_palette:
	.long	0
front_objects_palette:
	.long	0
front_objects_table:
	.long	0
background_sprite_table:
	.long	0
front_objects_y_table:
	.skip	8*2		| hopefully will be enough
nb_front_objects:
	.word	0
big_machine_nb_planes:
	.word	0

big_machine_x_offset:
	.word	0
big_machine_width:
	.word	0
big_machine_height:	
	.word	0
big_machine_extra_pic_width:
	.word	0
big_machine_extra_pic_height:	
	.word	0
truck_y_pos:	
	.word	0
truck_wheels_height:	
	.word	0
prev_truck_params:
	.skip	8
truck_previously_drawn:
	.byte	0
	.align	2
	
* copperlist data for forest level
BROWN_COLOR_1 = 0x210
BROWN_COLOR_2 = 0x320
BROWN_COLOR_3 = 0x431
	* optional color change for forest background, copperlist bit copied
	* in copperlist only at level 4
forest_object_colors_block:
	DECL_COLOR_BANK	2
	.word	0x2C01+0x3200,0xFFFE
	.word	color+2+8*2,BROWN_COLOR_1	| color 1 sprite 4
	.word	color+4+8*2,BROWN_COLOR_2	| color 2 sprite 4
	.word	color+6+8*2,BROWN_COLOR_3	| color 3 sprite 4
	
	.word	0x2C01+0x3800,0xFFFE
	.word	color+2+12*2,BROWN_COLOR_1	| color 1 sprite 4
	.word	color+4+12*2,BROWN_COLOR_2	| color 2 sprite 4
	.word	color+6+12*2,BROWN_COLOR_3	| color 3 sprite 4

	.word	color+2+24*2,BROWN_COLOR_1	| color 1 sprite 6
	.word	color+4+24*2,BROWN_COLOR_2	| color 2 sprite 6
	.word	color+6+24*2,BROWN_COLOR_3	| color 3 sprite 6
	
	.word	color+2+28*2,BROWN_COLOR_1	| color 1 sprite 6
	.word	color+4+28*2,BROWN_COLOR_2	| color 2 sprite 6
	.word	color+6+28*2,BROWN_COLOR_3	| color 3 sprite 6
forest_object_colors_block_end:

* 2 words: first shift (as bplcon value), then
* offset in bytes
scroll_table:
	.ifeq	BITPLANE_FMODE-3
	.include	"scroll_table_64.68k"
	.else
	.include	"scroll_table_32.68k"	
	.endif
* 65536 word values to flip bits. Costs 128k of memory but worth it
* as it saves a lot of chip and it's way faster than byte per byte swap
mirror_table:
	.include	"mirror_table.68k"
	.ifndef	RELEASE
	* easier to debug game to have memory aligned on 0x10000
	.ifne	OPT_ENABLE_LOGGING
	.section	.bss
tile_log_table_244000:
	* 16 cluts, 2048 tiles
	* a lot of combinations aren't used (fortunately!)
	.skip	0x8000
tile_log_table_24a000:		| make sure it's contiguous to prev table
	* 16 cluts, 2048 tiles
	* a lot of combinations aren't used (fortunately!)
	.skip	0x8000
tile_log_table_24d000:		| make sure it's contiguous to prev table
	* 16 cluts, 2048 tiles
	* a lot of combinations aren't used (fortunately!)
	.skip	0x8000
sprite_log_table_ffc000:
	* 16 cluts, 4096 tiles
	* a lot of combinations aren't used (fortunately!)
	.skip	0x10000
tile_log_table_end:
	.endif
	.endif




upper_osd_next_cw_table:
	.long	osd_left_next_cw
	.long	osd_left_center_next_cw
	.long	osd_right_center_next_cw
	.long	osd_right_next_cw

*lower_osd_cw_table:
*	.long	osd_bottom_left_sprite
*	.long	osd_bottom_left_center_sprite
*	.long	osd_bottom_right_center_sprite
*	.long	osd_bottom_right_sprite

	.section	.datachip


	



blank_sound:
	ds.l	4
	
blank_sprite:
	.skip	16+16*16+16
	
debug_copperlist:
	dc.w	bplcon0,0x200
	dc.w	color
debug_color:
	dc.w	0
	dc.l	-2
	


	
	* intro copperlist
intro_copperlist:
	.word	bplcon0,0x6200+BORDERBLANK | 6 bitplanes, borderblank

	* all sprites have the same palette no need to specify odd or even
	* on color bank 2 (64-)
	
	DECL_COLOR_BANK	2
sprites_palette_even:
	DECL_COLORS	0,16
sprites_palette_odd:
	DECL_COLORS	16,16

bitplanes_intro:
	DECL_BITPLANES	0,NB_PLAYFIELD_PLANES

	.word	bplcon1
fine_x_scroll_value:
	.word	0

	.word	bplcon4
	.word	BASE_BPLCON4_VALUE
	.word	bplcon2
sprites_bplcon2:
	.word	BASE_BPLCON2_VALUE
osd_upper_sprites:
	DECL_SPRITES	4
	* must follow !!!!
free_front_sprites:
background_sprites:
	DECL_SPRITES	4

	DECL_COLOR_BANK 0
base_palette:
	DECL_COLORS	0,32
	* now set color bank 1
	DECL_COLOR_BANK	1
dudes_palette:
	DECL_COLORS	0,24
letters_palette:
	DECL_COLORS	24,8
base_palette_end:

	.word	0x2C01+0x1800,0xFFFE

	* yellow color for time seconds
	DECL_COLOR_BANK	2
	.word	color+2*3+32,0xDD0      | time seconds 10ths
	.word	color+2*3+8,0xDD0		| time seconds unit
	
	* wait 16 lines to declare multiplexed/attached sprites
	* (front objects) in levels 1 and 2
	.word	0x2C01+0x2700,0xFFFE
	* change bplcon4 to point on another palette range
	* for 16-color attached sprites: bank 3
attached_sprites_bplcon4:
	.word	0x1FE
	.word	0x66
	DECL_COLOR_BANK	3
front_object_colors:
	DECL_COLORS	0,16
front_object_sprites:
	DECL_SPRITES	8

	* optional color change for forest background

forest_colors:
	.skip	forest_object_colors_block_end-forest_object_colors_block
forest_colors_end:
	
	* mid-line wait & extra interrupt
	.word	0x8001,0xFFFE
intro_intreq_block:
	* now wait some lines until we're sure bitmap only contains
	* non-black: we can set color 0 to light blue now
	.word	 intreq,0x8014  | call copper interrupt in the middle of a frame, also flag so copper interrupt knows that we're going to call copper int

	* pal limit
    .word  0xFFDF,0xFFFE       | PAL wait

	* set road scroll
road_y_pos:
	.word	0x0401,0xFFFE
bitplanes_road:
	DECL_BITPLANES	0,NB_PLAYFIELD_PLANES
	.word	0x1FE		| room for bplcon1
fine_x_road_scroll_value:
	.word	0
	* must follow the above!!
	.word	0x1FE,0		| room for bplcon0
	DECL_COLOR_BANK	0
road_colors:
	.rept	16
	.long	0x01FE0000
	.endr
	
osd_lower_sprites:
	DECL_SPRITES	4
	
	* change palette for lower OSD sprites (lives & energy)
	.word	0x0C01,0xFFFE
	* re-set palette for non-attached sprites
	.word	bplcon4,BASE_BPLCON4_VALUE
	.word	 intreq,0x8010	| no bobs from now on

	DECL_COLOR_BANK	2
	
	* restore from yellow color for time seconds
	DECL_COLOR_BANK	2
	.word	color+2*3+32,0xEEE
	.word	color+2*2+32,0xB29
	
	.word	color+2*2,0xEBB		| flesh pink
	.word	color+2*3,0xE9A		| flesh pink #2
	.word	0x1401,0xFFFE
	.word	color+2*3,0xEEE		| back to white for "LIFE" letters
	.word	color+2*2,0xB29		| magenta for dots
	.word	color+2*6,0xB29		| magenta for dots (right part of "enemy" dots)

	
    .long    -2
	.ifndef	RELEASE
	.ascii	"ENDCPLST"
	.endif
	

	.section	.bsspublic

sprite_y_table_table:
	.skip	Y_MAX*4


program_space:
	.ifndef	RELEASE
	.skip 	0x10000		| so we can align for debug
	.endif
	.skip	PROGRAM_SIZE
	
public_memory_block:
	.skip	TOTAL_PUBLIC_MEMORY_SIZE
	
	
	
	* aligning on 8 bytes so .align will work
	* in the next datachip sections
	.align	8
	
		.section .bsschip
	.align	8		| if not aligned, this is catastrophic for 64-bit wide fmode=3 sprites
		.macro		RESERVE_SPRITE	name
osd_\name\()_sprite:
	.skip	16		| control word
	.skip	16*16	| 16 rows of 2*8 bits (2 bitplanes)
osd_\name\()_next_cw:
	.skip	16	
	.endm

	RESERVE_SPRITE	left
	RESERVE_SPRITE	right
	RESERVE_SPRITE	left_center
	RESERVE_SPRITE	right_center
	RESERVE_SPRITE	bottom_left
	RESERVE_SPRITE	bottom_right
	RESERVE_SPRITE	bottom_left_center
	RESERVE_SPRITE	bottom_right_center
	


chip_memory_block:
	.skip	TOTAL_CHIP_MEMORY_SIZE
	
fg_screen_buffer_2:
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING
	.rept	CLIPPED_WIDTH_MARGIN/16
	.skip	ONE_FULL_16_BIT_ROW
	.endr
	.skip	SCREEN_SIZE

	.endif	
fg_screen_buffer_1:
	.rept	CLIPPED_WIDTH_MARGIN/16
	.skip	ONE_FULL_16_BIT_ROW
	.endr
	.skip	SCREEN_SIZE



	.skip	8
	


		