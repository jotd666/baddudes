*
*	Amiga-specific portions of baddudes (AGA version)
*
* (c) JOTD 2025
*



.include "custom.i"
.include "exec_lvos.i"
.include "dos_lvos.i"
.include "graphics_lvos.i"
.include "baddudes.inc"

AttnFlags = 0x128
AFB_68010 = 0
AFB_68020 = 1

	.macro	TMPBREAK
	BREAKPOINT	"work breakpoint"
	.endm

TOTAL_PUBLIC_MEMORY_SIZE = 350000
TOTAL_CHIP_MEMORY_SIZE = 600000

PREVIOUS_SPRITE_SIZE = 8
BORDERBLANK = 1

SPRITE_X_CORRECTION = 0
SPRITE_Y_CORRECTION = 0
HW_SPRITE_X_CORRECTION = 0
HW_SPRITE_Y_CORRECTION = 0

PANEL_Y_GAP = 208
Y_MAX = 260

BASE_BPLCON3_VALUE = (BORDERBLANK<<5)
BASE_BPLCON2_VALUE = 0x0200  | killehb (we're using 6 real bitplanes)
SCREEN_ADDRESS = 0x244000

* set both to nonzero for full static screen, no scroll, 1 screen tile
OPT_NO_SCROLLING_X = 0
OPT_NO_SCROLLING_Y = 0

* if the alloc_sprite & update_sprite routines
* are reused, changing those offsets can make
* a quick reuse from game to game as most sprite
* RAMs have 4 bytes per sprite, only the order
* and some bits differ

TARGET_SPRITE_Y = 0
TARGET_SPRITE_X = 4
TARGET_SPRITE_CODE = 2
TARGET_SPRITE_SIZE = 8

	.ifdef	RELEASE
OPT_ENABLE_PROFILING = 0         | DO NOT CHANGE THIS
OPT_ENABLE_LOGGING = 0           | DO NOT CHANGE THIS
ONE_TICK = 1
	.else
OPT_ENABLE_LOGGING = 1
OPT_ENABLE_PROFILING = 0
* set to higher values than 1 to speed game up
ONE_TICK = 1


	.endif
	

OPT_ENABLE_DOUBLE_BUFFERING = 0

_custom = 0xDFF000

OPT_ENABLE_MULTIPLEXED_SPRITES = 0

* background scrolls (in-game)
* foreground is static and contains bobs

NB_PLAYFIELD_PLANES = 6
*TOTAL_NB_COLORS = 1<<NB_PLAYFIELD_PLANES
NB_BYTES_PER_SCREEN = 32
NB_BYTES_PER_ROW = NB_BYTES_PER_SCREEN*3

* fmode=0b11xx => 3, 0b01xx => 2
SPRITE_FMODE = 1
	.ifeq	SPRITE_FMODE-3
SPRITE_POWER_OF_2 = 3
	.else
	.ifeq	SPRITE_FMODE-1
SPRITE_POWER_OF_2 = 2
	.else
	.error	"invalid SPRITE_FMODE value"
	.endif
	.endif
	

NB_PLAYFIELD_LINES = 256

* the screen plane size is pretty huge, so the offset can go beyond 0x8000 and
* the word add on address registers won't work
SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES*2
SCREEN_SIZE =  SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES
RESTORE_SCREEN_PLANE_SIZE = SCREEN_PLANE_SIZE
RESTORE_SCREEN_SIZE = RESTORE_SCREEN_PLANE_SIZE*6   | max 5 planes, can be 4 too ATM 6 for convenience (8x8 fonts)


NB_HOST_SPRITES = 8

* MAME driver uses 0x800 bytes of sprite ram, 8 bytes per sprite, let's hope
* that the game doesn't use them all!
NB_TARGET_SPRITES = 256

SPRITE_X = 0
SPRITE_Y = 1
SPRITE_CODE = 2
SPRITE_CLUT = 3
SPRITE_SIZEOF = 4


.macro	GET_RAM_START_IN_A6	
	.ifdef	RELEASE
	lea		ram_buffer,a6
	.else
	move.l		ram_start_ff8000,a6
	.endif
	.endm
	
.macro	WAIT_BLIT
	move.w	#0x8400,(dmacon,a5)		| blitter high priority
wait\@:
	BTST	#6,(dmaconr,a5)
	BNE.S	wait\@
	move.w	#0x0400,(dmacon,a5)		| blitter normal priority
.endm

.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm


* debug macro that colors the screen until LMB pressed
.macro 	blitz_bypass
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* same thing but if LMB is pressed when entering, macro waits for release)
.macro blitz
w\@:
	btst	#6,0xbfe001
	beq.b	w\@
	blitz_bypass
.endm

start:
	move.l	a7,old_stack
	bra	_user
    
	

* exports

	.global		_user
	.global		_player_start
	.global		_demo_end
	.global		_resload
	.global		_dosbase
	.global		cheat_used
* osd layer		
	.global		osd_flush_caches
	.global		osd_break
	.global		osd_real_ram_address
	.global		osd_read_byte
	.global		osd_read_word
	.global		osd_read_long
	.global		osd_write_byte
	.global		osd_write_word
	.global		osd_write_long
	.global		osd_enable_interrupts
	.global		osd_set_context
	
	.include	"ReadJoypad.i"
	.include	"whdload_funcs.i"
		.text


.list

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	.include	"profiler.68k"
	.endif

	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
	move.b	d1,_keyexit
    move.l a0,_resload

	move.l	a0,a2
	lea	(_tag,pc),a0
	jsr	(resload_Control,a2)
	
	.ifndef	RELEASE
	* install quit handler 
	move.l	#quit_to_os,0x4	
	.endif
	
	* load game ROM in 0 (this is temporary)
	lea		rom_file,a0
	sub.l	a1,a1			| ATM in 0
	move.l	a1,rom_base
	jsr	(resload_LoadFileDecrunch,a2)
	
	
   bra		.no_forbid
.standard:
	
    * open dos library, graphics library
    move.l  0x4.W,a6
    lea dosname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_dosbase

	lea	read_args_string,a0
	lea	program_args,a1
	move.l	#program_args_end-program_args,d0
	lsr.l	#2,d0		| number of longs
	

	bsr	get_args_BCPL

0:	
	lea		program_args,a0

	move.l	(A0)+,D0	| INVINCIBLE/S
	beq.b	1f
	or.l	#1,cheat_flags
	st.b	cheat_used
1:
	move.l	(A0)+,D0	| INFLIVES/S
	beq.b	2f
	or.l	#2,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| SECTORSELECT/S
	beq.b	2f
	or.l	#8,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| CHEATKEYS/S
	beq.b	2f
	* cheat isn't used as long as no cheat key is used
	or.l	#0x10,cheat_flags
2:

	move.l	(A0)+,D0	| STARTCOURSE/K/N
	beq.b	2f
	bsr		bcpl_string_to_int
	move.l	d0,dip_switch_start_course
2:
	move.l	(A0)+,D0	| STARTLIVES/S
	beq.b	2f
	bsr		bcpl_string_to_int
	subq.b	#1,d0
	bmi.b	2f
	move.l	d0,dip_switch_start_lives
	bra.b	3f
2:
	move.l	#2,dip_switch_start_lives		| 3 lives default
3:


	lea		_custom,a5
	lea		debug_copperlist,a0
	move.l	a0,cop1lc(a5)

* no multitask
	
	move.l	4.W,A6
	lea graphicsname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_gfxbase
    move.l	d0,a6
	move.l	38(a6),old_syscoplist
	move.l	34(A6),old_actiview		| gb_ActiView

	sub.l	a1,a1
	jsr	_LVOLoadView(a6)
	jsr	_LVOWaitTOF(a6)
	jsr	_LVOWaitTOF(a6)
	
	jbsr		load_highscores
    * check if "floppy" file is here
    move.l  _dosbase,a6
    move.l   #floppy_file,d1
    move.l  #1005,d2   | MODE_OLDFILE
    jsr     _LVOOpen(a6)
    move.l  d0,d1
    beq.b   .no_floppy
    * "floppy" file found
    jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    move.l  #100,d1
    jsr     _LVODelay(a6)
.no_floppy:

* no multitask
	
    move.l  4,a6
    jsr _LVOForbid(a6)

    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	move.l	#-1,184(A0)	| pr_WindowPtr: no more system requesters (insert volume, write protected...)

.no_forbid:
	* align bitplanes
	lea		fg_screen_buffer_1,a0
	bsr		align_for_fmode
	move.l	a0,fg_screen_data_1
	move.l	a0,fg_drawed_screen_ptr
	move.l	a0,fg_displayed_screen_ptr
	
	
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	lea		fg_screen_buffer_2,a0
	bsr		align_for_fmode
	move.l	a0,fg_screen_data_2
	move.l	a0,fg_displayed_screen_ptr
	.endif
	
	lea		_custom,a5
	
    move.w #0x6200+BORDERBLANK,bplcon0(a5) | 6 bitplanes, borderblank
	


* ALL DIP SWITCHES ARE WRONG ATM

*	move.l	dip_switch_start_course,d0
*	move.b	d0,start_level_flag
	
	moveq	#0,d1
	move.b	dip_switch_start_lives+3,d1
	bne.b	1f
	moveq	#3,d1	| 3 lives is default
1:
	* DSW 0 = 2 lives
*	move.b	(a0,d1.w),d0
*	not.b	d0
*	move.b	d0,dip_switches_1
	
	
	move.l	misc_options,d1
	btst	#0,d1
	
	btst	#1,d1
	beq.b	0f
	bset	#5,d0
0:
	btst	#2,d1
	beq.b	0f
	bset	#6,d0
0:
	.ifndef	RELEASE
	btst	#31,d1
	sne		break_at_startup_flag
	.endif
	
	**move.b	d0,dip_switches_2


	

	move.l	cheat_flags,d0
	btst	#0,d0
	beq.b	0f
	st		cheat_used
	bset	#6,dip_switches_2
0:
	btst	#1,d0
	beq.b	0f
	st		infinite_lives_flag
	st		cheat_used
0:
	btst	#2,d0
	beq.b	0f
	st		infinite_time_flag
	st		cheat_used
0:
	move.l	cheat_flags,d0
	btst	#3,d0
	beq.b	0f
	st		cheat_used
	bset	#5,dip_switches_2
0:
	
	jsr	 _detect_controller_types 
	clr.b	controller_joypad_0
	clr.b	controller_joypad_1

	jra		demo_game


* so memory is quadword-aligned (not trusting .align directives)
align_for_fmode:
	add.w	#0x10,a0
	move.l	a0,d0
	and.b	#0xF8,d0
	move.l	d0,a0
	rts

	
* < D0: bcpl string (with leading size byte)
* < A1: dest C string
bcpl_arg_string_copy:
    movem.l D0-D2/A0-A1,-(a7)
	lsl.l	#2,d0
	moveq.l	#0,d2
    move.l  d0,a0
	move.b	(a0)+,d2	| size
	beq.b	1f
	subq	#1,d2
0:
	move.b	(a0)+,(a1)+
	dbf		d2,0b
1:
    movem.l (a7)+,D0-D2/A0-A1
    rts


bcpl_string_to_int:
    movem.l A0/A1,-(a7)
    lea temp_filename_buffer,a1
    bsr bcpl_arg_string_copy
    * convert to integer
    move.l  a1,a0
    * < A0: pointer on C string
    * > D0: value
    * > D1: -1 if ok, position of the string if error
    bsr parse_integer
    movem.l  (a7)+,a0/a1
	rts
	
* parse integer from string
* < A0: pointer on C string
* > D0: value
* > D1: -1 if ok, position of the string if error
parse_integer:
    movem.l  d2/d3,-(a7)
    * go to end of string
    moveq.l #-1,d1
.loop1:
    addq.l  #1,d1
    tst.b   (a0,d1.w)
    bne.b   .loop1
    * d1 is the number of chars
    moveq.l #0,d0
    moveq.l #0,d2
    subq.l  #2,d1   | 10th power minus 1
.loop2:
    move.b  (a0)+,d2
    beq.b   .out
    
    cmp.b   #32,d2
    beq.b   .skip
    sub.b   #48,d2
    bcs.b   .error
    cmp.b   #10,d2
    bcc.b   .error
    move.w  d1,d3
    bmi.b   .doadd
.muloop:
    mulu    #10,d2
    dbf d3,.muloop
.doadd:
    add.l   d2,d0
.skip:
    subq.l  #1,d1
    bra.b   .loop2
.out:    
    movem.l  (a7)+,d2/d3
    rts
.error:
    moveq.l #0,d0
    bra.b   .error
	
    * thanks Toni for this 1.3 read argument code
BCPL_RdArgs = 78
	
	* a1 = pointer to result array. Must be LONG aligned!
	* a0 = formatting string. BSTR!
	* d0 = size of result array (number of LONGs)
get_args_BCPL:
	movem.l d2/d3/d4,-(sp)
	move.l d0,d3
	moveq #BCPL_RdArgs,d0
	move.l a0,d1
	lsr.l #2,d1
	move.l a1,d2
	lsr.l #2,d2
	moveq #0,d4
	bsr.s call_bcpl
	movem.l (sp)+,d2/d3/d4
	rts

	* d0 = gv index
	* d1-d4 = bcpl parms

BCPL_STACK = 3000

call_bcpl:
	movem.l d2-d7/a2-a6,-(sp)

	move.l d0,d6
	move.l d1,d5

	move.l 4.w,a6
	move.l	_dosbase,a5


	sub.l a1,a1
	jsr	_LVOFindTask(a6)
	move.l d0,a4

	* allocate BCPL stack
	move.l #BCPL_STACK,d0
	move.l #65536+1,d1
	jsr	_LVOAllocMem(a6)
	move.l d0,d7
	beq.s 0f
	
	movem.l d7/a5/a6,-(sp)

	moveq #0,d0
	move.l d5,d1
	sub.l a0,a0
	move.l d7,a1
	lea 3*4(a1),a1
	move.l 136(a4),a2
	move.l 0(a2,d6.w*4),a4
	movem.l 46(a5),a5/a6
	jsr (a5) | call bcpl!
	
	movem.l (sp)+,d7/a5/a6

0:
	move.l d7,a1
	move.l #BCPL_STACK,d0
	jsr	_LVOFreeMem(a6)


	movem.l (sp)+,d2-d7/a2-a6
	rts



	

demo_game:

	* init dynamic memory blocks
	jbsr	free_all_memory
	
	move.w	#CTX_INTRO,d0
	jbsr	osd_set_context
	
	move		#0x4000,_custom+intena						| disable interrupts
	move		#0x7FFF,_custom+intreq						| ack all interrupts
	bsr			platform_init					| amiga-specific init
		
0:	

	
	* compute ram start
	lea		ram_buffer,a6
	.ifndef	RELEASE
	* align so real addresses are $xxxx8yyyy
	* and lower 16-bit match original RAM offsets
	move.l	a6,d0
	clr.w	d0
	add.l	#0x18000,d0
	move.l	d0,a6
	move.l	a6,ram_start_ff8000
	.endif

	move.l	a6,ram_base
	*lea		stack_top,a7
	jmp			baddudes_reset					| pass control to the mpatrol core
		
	
* just in case some hardware calls nmi
_nmi:
	move.w	#0x7FFF,_custom+intreq
	move.w	#0x7FFF,_custom+intreq
	rts
	
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	lea		_custom,a5
	move.w	(intreqr,a5),d0
	btst	#5,d0
	beq.b		1f
	
	move.l	_joypad_state,d1
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state
	
	* CD32 "play" is disabled but it's free to read
	* 3rd button on a Sega 3-button so 3rd button is pause
	btst	#JPB_BTN_PLAY,d0
	beq.b	0f
	btst	#JPB_BTN_PLAY,d1
	bne.b	0f
	bsr		toggle_pause
0:
	* here music doesn't loop. We have to stop it when it ends
	move.w	music_tick,d1
	beq.b	13f
	
	subq	#1,d1

	move.w	d1,music_tick
	bne.b	13f
	jbsr		osd_sound_stop
13:
	
	* ack vbl twice (040/pistorm bug)
	move.w	#0x20,(intreq,a5)
	move.w	#0x20,(intreq,a5)	
	jra	3f
1:
	* has to be copper
	* is level 1 interrupt set? that would mean that mid-screen interrupt
	* is the source of the interrupt
	btst	#2,d0
	sne		mid_screen_interrupt

	* we're going to ack copper & software interrupt now
	* do it twice (040/pistorm bug)
	move.w	#0x14,(intreq,a5)
	move.w	#0x14,(intreq,a5)

	* set base for RAM
	GET_RAM_START_IN_A6
	btst	#2,d0
	beq.b	2f
	* mid-screen copper interrupt, must occur once every 5 times
	* to simulate ~60 Hz on 50 Hz display
	move.b	mid_screen_interrupt_count,d0
	addq.b	#1,d0
	cmp.b	#5,d0
	bne.b	1f
	* declare that we're in interrupt mode so osd_disable_interrupts/osd_enable_interrupts
	* also set SR accordingly
	st.b	interrupt_mode
	jbsr		baddudes_irq
	clr.b	interrupt_mode	
	clr.b	d0
1:
	move.b	d0,mid_screen_interrupt_count
	jra		3f
2:

	

	
	tst.b	pause_flag
	jne	23f

	subq.w	#1,delay_timer
		
	* declare that we're in interrupt mode so osd_disable_interrupts/osd_enable_interrupts
	* also set SR accordingly
	st.b	interrupt_mode
	jbsr		baddudes_irq
	clr.b	interrupt_mode

	move.w	display_dudes,d0
	jeq		1100f
	
	cmp.w	#1,display_dudes
	jeq		1101f
	move.w	D0,-(a7)
	* restore background
* what: blits data on bg plane, no horizontal shifting (erase)
* args:
* < A0: pristine background
* < A1: dest buffer
* < D0: X (rounded to smaller 8-multiple)
* < D1: Y
* < D2: width in bytes
* < D4: height

	move.l	dude_pics,a2
	move.l	(a2),a2		| first dude struct data

	move.l	fg_drawed_screen_ptr,a1
	lea		background_restore_buffer,a0
	move.w	(a2)+,d0			| X
	move.w	(a2)+,d1			| Y
	move.w	(a2)+,d2			| width
	lsr.w	#3,d2				| divide by 8 to get len in bytes
	move.w	(a2)+,d4			| height
	jbsr	restore_background
	lea	(SCREEN_PLANE_SIZE,a1),a1
	* remaining planes need to be simply cleared
	* when exiting from restore_background, A1 points
	* to the exact next erase position so D0=0, D1=0 here
	move.w	nb_tile_planes_24a000,d3
	neg.w	d3
	addq.w	#NB_PLAYFIELD_PLANES,d3
	moveq	#0,d0
	moveq	#0,d1
	lea		_custom,a5
	jbsr	clear_fg_planes_any_blitter_internal
	move.w	(a7)+,d0
1101:
	
	* set dudes palette
	move.l	dude_pics,a2
	move.l	(-4,a2,d0.w*4),a2		| requested dude struct
	lea		(8,a2),a0			    | palette (maybe different for both pics)
	lea		dudes_palette,a1
	move.w	#24,d0
	jbsr	load_palette

	move.l	fg_drawed_screen_ptr,a1
	move.w	(a2)+,d0			| X
	move.w	(a2)+,d1			| Y
	move.w	(a2)+,d2			| width
	lsr.w	#3,d2				| divide by 8 to get len in bytes
	move.w	#4,d3				| 4 bitplanes in cookie cut mode
	move.w	(a2)+,d4			| height
	moveq	#0,d5
	lea		(0x40,a2),a0			| pic planes
	move.l	(6*4,a0),a3				| mask plane
	movem.l	D0-D5/A1/A2,-(a7)
	jbsr	blit_planes_any_internal_cookie_cut
	movem.l	(a7)+,D0-D5/A1/A2
	lea		(0x50,a2),a0			| pic remaining planes
	move.w	#2,d3				| 4 bitplanes in non cookie cut mode
	lea		(SCREEN_PLANE_SIZE*4,a1),a1
	jbsr	blit_planes_any_internal_no_cookie_cut
	
	clr.w	display_dudes
	* we have to wait for blitter, as 8x8 font engine uses cpu only
	lea		_custom,a5
	WAIT_BLIT
	
1100:
	
	
	bsr		really_update_sprites
	
	* double buffering only in-game
	cmp.w	#CTX_GAME,global_context
	jcs		23f
	bsr		switch_screen_buffers

23:
	* don't blit, but update hw sprites as it doesn't cost a lot


3:
    movem.l (a7)+,d0-d7/a0-a6
    rte
	
osd_flush_caches:
	tst.l	_resload
	jeq		0f
	move.l	_resload,a2
	jsr		(resload_FlushCache,a2)
	rts
0:
	move.l	4,a6
	jsr	(_LVOCacheClearU,a6)
	rts
	
* < D0: operation size
* < D1: operation type read/write
* < A6: address
* <> D7: input/output

special_memory_op:
	movem.l	d2-d3/a0-a1,-(a7)
	* hash the address
	move.l	a6,d2
	swap	d2		| 24, 30, 31
	sub.w	#0x24,d2
	jeq		video_ram_op
	cmp.w	#0x30-0x24,D2
	jeq		ports_ram_op
	.ifndef RELEASE
	cmp.w	#0x31-0x24,D2
	jeq		palette_and_sprites_ram_op
	add.w	#0x24,d2
	BREAKPOINT	"virtual access violation (address in D2)"
	jra		special_memory_op_out
	.endif
	jra		palette_and_sprites_ram_op
special_memory_op_out:
	movem.l	(a7)+,d2-d3/a0-a1
	rts
	
* virtual address 0x24xxxx
video_ram_op:
	.ifndef RELEASE
	add.w	#0x24,d2
	.endif
	swap	d2
	move.w	d2,d3
	and.w	#0xF000,d3
	rol.w	#4,d3
	lea		addr_24xxxx_table_op,a0
	jsr		([a0,d3.w*4])
	
	jra		special_memory_op_out
	
* virtual address 0x30xxxx
ports_ram_op:
	.ifndef RELEASE
	add.w	#0x24,d2
	.endif

	swap	d2
	move.w	d2,d3
	and.w	#0xC000,d3
	jeq		an_ports
	* 0x30Cxxx, 0->0x19: atm do nothing
	and.w	#0x1F,d2
	lea		addr_30c00xx_table_op,a0
	jsr		([a0,d2.w*4])

	jra		special_memory_op_out
an_ports:
	BREAKPOINT		"an ports"
	jra		special_memory_op_out

* virtual address 0x31xxxx
palette_and_sprites_ram_op:
	.ifndef RELEASE
	add.w	#0x31,d2
	.endif

	swap	d2
			| to_implement
	jra		special_memory_op_out
	
* actual inputs
addr_30c0000_op:
	jbsr	read_controls
	move.w	d0,d7
	rts
	
* system (start/coin and also vblank - which is stubbed)
addr_30c0002_op:
	tst.b	D1
	jne		0f
	jbsr	read_system_inputs
	move.b	d0,d7		| make sure sync flag set (bit 7 cleared)
	
	rts
0:
	BREAKPOINT	"unexpected write to 30c0002"
	rts
	
	
addr_30c00xx_op:
	rts
	
addr_24xxxx_table_op:
	.long	addr_240xxx_op
	.long	addr_unmapped_op
	.long	addr_242xxx_op
	.long	addr_unmapped_op
	.long	addr_244xxx_tile_layer_op
	.long	addr_245xxx_tile_layer_0_op
	.long	addr_246xxx_op
	.long	addr_unmapped_op
	.long	addr_248xxx_op
	.long	addr_unmapped_op
	.long	addr_24Axxx_tile_layer_op
	.long	addr_unmapped_op
	.long	addr_24Cxxx_op
	.long	addr_24Dxxx_tile_layer_2_op
	.long	addr_unmapped_op
	.long	addr_unmapped_op
	
addr_30c00xx_table_op:
	.long	addr_30c0000_op   | 0x00
	.long	addr_30c00xx_op   | 0x01
	.long	addr_30c0002_op   | 0x02
	.long	addr_30c00xx_op   | 0x03
	.long	addr_30c00xx_op   | 0x04
	.long	addr_30c00xx_op   | 0x05
	.long	addr_30c00xx_op   | 0x06
	.long	addr_30c00xx_op   | 0x07
	.long	addr_30c00xx_op   | 0x08
	.long	addr_30c00xx_op   | 0x09
	.long	addr_30c00xx_op   | 0x0a
	.long	addr_30c00xx_op   | 0x0b
	.long	addr_30c00xx_op   | 0x0c
	.long	addr_30c00xx_op   | 0x0d
	.long	addr_30c00xx_op   | 0x0e
	.long	addr_30c00xx_op   | 0x0f
	.long	addr_30c00xx_op   | 0x10
	.long	addr_30c00xx_op   | 0x11
	.long	addr_30c00xx_op   | 0x12
	.long	addr_30c00xx_op   | 0x13
	.long	addr_30c00xx_op   | 0x14
	.long	addr_30c00xx_op   | 0x15
	.long	addr_30c00xx_op   | 0x16
	.long	addr_30c00xx_op   | 0x17
	.long	addr_30c00xx_op   | 0x18
	.long	addr_30c00xx_op   | 0x19
	.long	addr_30c00xx_op   | 0x1a
	.long	addr_30c00xx_op   | 0x1b
	.long	addr_30c00xx_op   | 0x1c
	.long	addr_30c00xx_op   | 0x1d
	.long	addr_30c00xx_op   | 0x1e
	.long	addr_30c00xx_op   | 0x1f



addr_unmapped_op:
	BREAKPOINT		"unmapped memory (in d2)"
	rts

addr_240xxx_op:
	rts		| to_implement
addr_242xxx_op:
	rts	| to_implement
	
* 8x8 tile layer, right screen nothing done TODO
addr_245xxx_tile_layer_0_op:
	rts
	
* 8x8 tile layer
addr_244xxx_tile_layer_op:
	and.w	#0x7FF,d2

	cmp.b	#2,d0
	jne		0f
	swap	d7	
0:
	subq	#1,d0
	jpl		0f

	* byte op
	tst.b	d1
	jne		1f		| write
	BREAKPOINT	"byte read from 244xxx (in D2)"
	rts
1:
	* write byte: equivalent to write word with attr+code
	lea		video_ram_244000,a6
	bclr	#0,d2
	jeq		11f
	* this is not working properly!
	* odd: get even MSB value
	BREAKPOINT	"write byte 244xxx"
	rol.w	#8,d7
	move.b	(a6,d2.w),d7
	rol.w	#8,d7
	jra		12f
11:
	* even: get odd LSB value
	rol.w	#8,d7
	move.b	(1,a6,d2.w),d7
12:
	moveq	#1,d0		| word operation
	lea		0x244000,a6
	add.w	d2,a6
	jra		addr_244xxx_tile_layer_op
2:
	rts
0:
	movem.l	a0-a5/d2-d6,-(a7)
10:
	move.w	d2,-(a7)
	lea		video_ram_244000,a0
	add.w	d2,a0
	tst.b	d1
	jne		0f		| write
	BREAKPOINT	"word read from 244xxx (in D2)"
	* read: TODO check read size
	move.w	(a0),d7
	jra		101f
0:
	cmp.w	(a0),d7
	jeq		100f	| already the proper value
	move.w	d7,(a0)	| set value in memory first

	* special cases: on some special tiles, 
	* blit the whole pic (big dudes in intro)
	cmp.w	#CTX_INTRO,global_context
	jne		16f
	cmp.w	#0x5526,d7	| written at 244398
	jne		15f
	move.w	#1,display_dudes
	jra		100f
15:
	cmp.w	#0x541E,d7
	jne		16f
	move.w	#2,display_dudes
	jra		100f
16:
	* then draw the 8x8 tile
	move.w	d2,d3
	and.w	#0x3F,D3		| this is X
	lsr.w	#1,d3			| divide by 2
	lsr.w	#6,D2			| this is Y
	subq	#1,d2
	jmi		100f
	lsl.w	#3,d2			| times 8
	cmp.w	#512,d2
	jcc		100f
	
	move.l	fg_drawed_screen_ptr,a1
	lea		background_restore_buffer,a5
	lea		mulNB_BYTES_PER_ROW_table,a2
	add.w	(a2,d2.w*2),d3
	add.w	d3,a1			| screen dest address on bg playfield
	add.w	d3,a5
	move.w	d7,d6			| tile code
	and.w	#0x7FF,d6
	jeq		erase_tile_8
	move.w	d7,d5			| save code
	rol.w	#4,d5
	and.w	#0xF,d5			| tile clut

	.ifne	OPT_ENABLE_LOGGING
	move.l	#video_ram_244000,0x14
	lea		tile_log_table_244000,a2
	move.l	a2,0x10		| store address in zero page
	move.w	d6,-(a7)
	lsl.w	#4,d6		| 16 cluts
	add.w	d5,d6		| clut offset
	st.b	(a2,d6.w)
	move.w	(a7)+,d6
	.endif

	* this is rather tricky
	* 1) "cookie cut" or "clear mask" data for first planes (which contain background)
	* 2) "copy data" or "clear" for the last planes
	move.l		tile_data_244000,a0
	add.l	(a0,d6.w*4),a0	| select tile code
	move.l	(a0,d5.w*4),d6
	jeq		100f		| ignored

	add.l	d6,a0	| select tile clut
	
	move.w	nb_tile_planes_24a000,d6
	subq	#1,d6
	move.l	a0,a3			| base ptr
	move.l	(24,a0),a4		| where the mask is
	add.l	a3,a4
	* cookie cut loop against background
0:
	move.l	(a0)+,d2
	jeq		2f		| restore background, remove mask bits
	lea		(a3,d2.l),a2
	* plane contains data: copy it
	.set	offset,0
	.rept	8
	move.b	(a4)+,d3			| get mask line
	and.b	(offset,a5),d3		| read pristine backbuffer/remove bits (cookie cut) 
	or.b	(a2)+,d3			| insert tile bits
	move.b	d3,(offset,a1)		| put in destination
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	subq	#8,a4
1:
	lea		(SCREEN_PLANE_SIZE,a1),a1
	lea		(RESTORE_SCREEN_PLANE_SIZE,a5),a5
	dbf		d6,0b
	* plain copy loop on the planes without background
	move.w	nb_tile_planes_24a000,d6
0:	
	move.l	(a0)+,d2
	jeq		3f		| erase plane
	lea		(a3,d2.l),a2
	* plane contains data: copy it
	.set	offset,0
	.rept	8
	move.b	(a2)+,(offset,a1)		| put in destination
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	subq	#8,a4
11:
	lea		(SCREEN_PLANE_SIZE,a1),a1
	addq	#1,d6
	cmp.w	#NB_PLAYFIELD_PLANES,d6
	jne	0b
	
100:	
	move.w	(a7)+,d2
	* preparing for longword write
	addq.w	#2,d2
	swap	d7
	dbf		d0,10b		| next word (if longword write)
101:
	movem.l	(a7)+,a0-a5/d2-d6
	rts
2:
	* just cut this plane using mask (no data to OR with)
	.set	offset,0
	.rept	8
	move.b	(a4)+,d3			| get mask line
	and.b	(offset,a5),d3		| read pristine backbuffer/remove bits (cookie cut) 
	move.b	d3,(offset,a1)		| put in destination
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	subq	#8,a4
	jra		1b
3:
	* just erase this plane
	.set	offset,0
	.rept	8	
	clr.b	(offset,a1)		| put in destination
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	jra		11b
	
erase_tile_8:
	move.w	nb_tile_planes_24a000,d6
	subq	#1,d6
0:
	.set	offset,0
	.rept	8
	move.b	(offset,a5),(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	lea		(SCREEN_PLANE_SIZE,a1),a1
	lea		(RESTORE_SCREEN_PLANE_SIZE,a5),a5
	dbf		d6,0b
	
	move.w	nb_tile_planes_24a000,d6
0:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	lea		(SCREEN_PLANE_SIZE,a1),a1
	addq	#1,d6
	cmp.w	#NB_PLAYFIELD_PLANES,d6
	jne	0b
	
	jra		100b
	rts
addr_248xxx_op:
	rts	| to_implement
	
* scroll registers
* 00246010: X-scroll (wraps at 0x200)
* 00246012: Y-scroll
addr_246xxx_op:
	cmp.w	#0x6010,d2
	jeq		0f
	cmp.w	#0x6012,d2
	jeq		1f
	* unsupported, also not useful & ignored
	rts
0:
	and.w	#0x1FF,d7
	move.w	d7,d0
	jbsr	set_scroll_x
	rts
1:
	and.w	#0x1FF,d7
	move.w	d7,d0
	jbsr	set_scroll_y
	rts
	
	.macro	NEXT_PLANES
	lea		(SCREEN_PLANE_SIZE,a1),a1
	lea		(SCREEN_PLANE_SIZE,a4),a4	
	.endm
	.macro	CLR_PLANE
	.set	offset,0
	.rept	16
	clr.w	(offset,a1)
	clr.w	(offset,a4)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.endm

	.macro	CLR_MIRROR_PLANE
	.set	offset,0
	.rept	16
	clr.w	(offset+NB_BYTES_PER_SCREEN,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.endm
	
* 16x16 tile layer
addr_24Axxx_tile_layer_op:
	and.w	#0x7FF,d2

	cmp.b	#2,d0
	jne		0f
	swap	d7	
0:
	subq	#1,d0
	jpl		0f
	* byte op: ignore
	rts
0:
	movem.l	a0-a4/d2-d6,-(a7)
10:

	move.w	d2,-(a7)
	lea		video_ram_24a000,a0
	add.w	d2,a0
	tst.b	d1
	jne		0f		| write
	BREAKPOINT	"word read from 24axxx (in D2)"
	move.w	(a0),d7
	jra		101f
0:
	cmp.w	(a0),d7
	jeq		100f	| already the proper value

	move.w	d7,(a0)	| set value in memory first
	* then draw the 16x16 tile
	moveq	#0,d3			| D3.L!!
	move.w	d2,d3
	and.w	#0x1F,D3		| this is X
	move.w	d2,d4
	and.w	#0x1E0,d4
	lsr.w	#1,D4			| this is Y


	* now compute quadrant.
	sub.w	#0x200,d2
	smi		first_half_flag		| first half
	jmi		20f		| 000-200: no changes
	sub.w	#0x200,d2
	jpl		21f	
	.ifeq	OPT_NO_SCROLLING_X	
	* 200-400: add to X
	add.w	#0x20,D3
	.endif
	jra		20f
21:
	sub.w	#0x200,d2
	jpl		22f	
	st		first_half_flag
	* 400-600: add to Y
	.ifeq	OPT_NO_SCROLLING_Y	
	add.w	#16*16,d4
	.endif
	jra		20f
22:
	* 600_800: add to both
	.ifeq	OPT_NO_SCROLLING_X	
	add.w	#0x20,D3
	.endif
	.ifeq	OPT_NO_SCROLLING_Y	
	add.w	#16*16,d4
	.endif
20:
	move.l	fg_drawed_screen_ptr,a1
	lea		background_restore_buffer,a4
	lea		mulNB_BYTES_PER_ROW_table,a2
	moveq	#0,d5
	move.w	(a2,d4.w*2),d5
	add.l	d3,d5
	add.l	d5,a1			| screen dest address on playfield
	add.l	d5,a4			| screen dest address on restore playfield
	
	move.w	d7,d5			| save code
	move.w	d7,d6			| tile code
	and.w	#0x7FF,d6
	jeq		erase_tile
	rol.w	#4,d5
	and.w	#0xF,d5			| tile clut

	.ifne	OPT_ENABLE_LOGGING
	cmp.w	#0x7FF,d6			| when logging on title: 1FF, else increase!
	jcc		0f
	lea		tile_log_table_24a000,a2
	move.l 	#video_ram_24a000,0xC
	move.l	a2,0x8		| store address in zero page
	move.w	d6,-(a7)
	lsl.w	#4,d6		| 16 cluts
	add.w	d5,d6		| clut offset
	st.b	(a2,d6.w)
	move.w	(a7)+,d6
0:
	.endif

111:
	move.l	tile_data_24a000,a0
	add.l	(a0,d6.w*4),a0  | skip palette select tile code
	move.l	(a0,d5.w*4),d6
	jeq		100f				| tile not found/ignored, skip

	add.l	d6,a0	| select tile clut
	
	move.w	nb_tile_planes_24a000,d6
	subq	#1,d6
	move.l	a0,a3			| base ptr
0:
	move.l	(a0)+,d2
	jeq		2f		| erase plane

	.ifndef	RELEASE
	cmp.l	#0x00FFFFF,d2
	jcs		22f
	lea		111b,a1
	BREAKPOINT	"invalid d2 value!"
22:
	.endif
	
	lea		(a3,d2.l),a2
	tst.b	first_half_flag
	jeq		23f

	* plane contains data: copy it
	.set	offset,0
	.rept	16
	move.w	(a2)+,d5
	move.w	d5,(offset,a1)
	move.w	d5,(offset+NB_BYTES_PER_SCREEN,a1)
	move.w	d5,(offset,a4)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr	
	
	NEXT_PLANES
	dbf		d6,0b
	jra		100f
23:
	* plane contains data: copy it
	.set	offset,0
	.rept	16
	move.w	(a2)+,d5
	move.w	d5,(offset,a1)
	move.w	d5,(offset,a4)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr	
1:
	NEXT_PLANES
	dbf		d6,0b
100:	
	move.w	(a7)+,d2
	* preparing for longword write
	addq.w	#2,d2
	swap	d7
	dbf		d0,10b		| next word (if longword write)
101:
	movem.l	(a7)+,a0-a4/d2-d6
	rts
2:
	CLR_PLANE
	tst.b	first_half_flag
	jeq		1b
	CLR_MIRROR_PLANE
	jra		1b
	
erase_tile:
	move.w	nb_tile_planes_24a000,d6
	subq	#1,d6
	tst.b	first_half_flag
	jne		erase_tile_twice
0:
	CLR_PLANE
	NEXT_PLANES
	dbf		d6,0b
	jra		100b
	
erase_tile_twice:
0:
	CLR_PLANE
	CLR_MIRROR_PLANE
	NEXT_PLANES
	dbf		d6,0b
	jra		100b
	
addr_24Cxxx_op:
	* happens at start, see if needed
	*BREAKPOINT	"word read/write from 24Cxxx (in D2)"
	rts	      | to_implement
* 16x16 tile layer TODO NOP
addr_24Dxxx_tile_layer_2_op:
	*BREAKPOINT	"word read/write from 24Dxxx (in D2)"
	rts
	

* < A6: virtual address (in RAM)
* > A6: real address

osd_real_ram_address:
	sub.l	#0xFF8000,a6
	.ifndef	RELEASE
	bpl.b	0f
	add.l	#0xFF8000,a6
	BREAKPOINT	"ram address out of range (in A6)"
	illegal
0:	
	.endif
	
	add.l	ram_base,a6
	rts
	
	.macro	OSD_MEM_WRITE_OP	size
	movem.l	d0/d1/d7,-(a7)
	move.w	#\size,d0
	move.w	#1,d1
	jbsr	special_memory_op
	movem.l	(a7)+,d0/d1/d7
	rts
	.endm
	
	.macro	OSD_MEM_READ_OP	size
	movem.l	d0/d1,-(a7)
	move.w	#\size,d0
	move.w	#0,d1		| read
	jbsr	special_memory_op
	movem.l	(a7)+,d0/d1
	rts
	.endm
	
osd_read_byte:
	OSD_MEM_READ_OP	0

osd_write_byte:
	OSD_MEM_WRITE_OP	0


osd_read_word:
	OSD_MEM_READ_OP	1

osd_write_word:
	OSD_MEM_WRITE_OP	1


osd_read_long:
	OSD_MEM_READ_OP	2

osd_write_long:
	OSD_MEM_WRITE_OP	2

	
osd_blitz:
	blitz
	rts
	
osd_break:
	* sends a WinUAE command to enter WinUAE debugger
	.ifndef	RELEASE
	move.l	D0,-(a7)
	pea     0.w
	* Normally it would point to where the result of the command is written, but since the last parameter (first pushed)
	* indicating the number of bytes to write is 0, nothing is written.
	pea     0.w	
	pea     1003f-1002f
	pea     1002f
	pea     -1.w
	pea     82.w
	jsr     0xf0ff60
	lea     24(sp),sp
	move.l	(a7)+,d0
	.endif
    rts
		
1002: .asciz    "AKS_ENTERDEBUGGER 1"
1003:
        .align	2



* < D0: number of 1/60Hz ticks
* can work with interrupts enabled or disabled
osd_wait:
	move.w	d0,delay_timer
	**jbsr	osd_is_vblank_interrupt_enabled
	tst.w	d0
	jne		2f
	* interrupts are disabled: timer isn't going to change
	* wait using vertical blank interrupt request (we don't need it!)
	clr.w	one_out_of_five
0:
	move.w	#0x20,_custom+intreq
	move.w	#0x20,_custom+intreq
1:
	move.w	_custom+intreqr,d0
	btst	#5,d0
	beq.b	1b
	addq.w	#1,one_out_of_five
	cmp.w	#5,one_out_of_five
	bne.b	5f
	subq.w	#1,delay_timer	
	clr.w	one_out_of_five
5:
	subq.w	#1,delay_timer
	beq.b	4f
	bpl.b	0b
4:
	rts
	
2:
	tst.w	delay_timer
	bne.b	2b
	rts




	
is_game_playing:
	movem.l	d0/a6,-(a7)
	GET_RAM_START_IN_A6
	tst.b	(0x215,a6)
	jpl		0f			| negative: game in play
	moveq	#1,d0
	jra		1f
0:
	moveq	#0,d0
1:
	movem.l	(a7)+,d0/a6
	rts
	

	

	


really_update_sprites:
	move.l	bob_previous_drawed_sprites,a4
	lea		_custom,a5
	

	* clear previous positions
	move.w	#NB_TARGET_SPRITES-1,d7

	* compute number of remaining empty planes (after background planes)
	move.w	nb_tile_planes_24a000,d5
	neg.w	d5
	addq.w	#NB_PLAYFIELD_PLANES,d5
	
1:
	move.w	(a4),d0
	beq.b	12f		| y=0: inactive and end of list (let's hope it works!)
	move.w	(2,a4),d1
	and.w	#0x1F0,d0		| align on 16 lower bound
	* clear area where the sprite was
	move.l	fg_drawed_screen_ptr,a1
	moveq	#NB_PLAYFIELD_PLANES,d3
	clr.l	(a4)+ 			| ack deletion
	move.w	(a4),d2			| width in bytes (16 pixels: 4 bytes)
	move.w	(2,a4),d4		| height
	clr.l	(a4)+			| ack deletion
	* restore background
	lea		background_restore_buffer,a0
	jbsr	restore_background
	* clear the rest of the planes (background can be 4 or 5 planes, we need to
	* clear the rest 1 or 2 planes)
	* a1 is returned by restore_background as the last cleared start address
	* go to next plane and use 0,0 coords to avoid more computations
	lea		(SCREEN_PLANE_SIZE,a1),a1
	moveq	#0,d0
	moveq	#0,d1
	move.w	d5,d3
	move.w	d5,-(a7)
	jbsr	clear_fg_planes_any_blitter_internal
	move.w	(a7)+,d5
	dbf		d7,1b
12:	
	GET_RAM_START_IN_A6
	lea	(0x4000,a6),a0		| sprites
	.ifne	OPT_ENABLE_LOGGING
	move.l	a0,0x20			| store address in zero page
	.endif
	
    lea _custom,A5
	move.l	bob_previous_drawed_sprites,a6
	move.l		sprite_table_base,a4
	*add.w	#(NB_TARGET_SPRITES-1)*4,a0		| start by the end (drawing priority)
	move.w	#NB_TARGET_SPRITES-1,d7
1:
	move.w	(TARGET_SPRITE_Y,a0),d1  | sprite Y & attributes
	btst	#15,d1
	jeq		3f						 | if bit 15 not set, then slot is free
	
	move.w	(TARGET_SPRITE_X,a0),d0  | sprite X
*	cmp.b	#230,d0
*	jcc		2f 						| don't draw sprites too far right
	move.w	(TARGET_SPRITE_CODE,a0),d2
	move.w	d0,d3
	rol.w	#4,d3
	and.w	#0xF,d3		| color code


	.ifne	OPT_ENABLE_LOGGING
	lea		sprite_log_table_ffc000,a2
	move.l	a2,0x24		| store address in zero page
	movem.w	d1/d2,-(a7)
	lsl.w	#4,d2		| 16 cluts
	add.w	d3,d2		| clut offset
	rol.w	#8,d1
	bset	#7,d1		| probably set, but at least won't be 0
	and.w	#0xFFFF,d2	| can't go higher, but may be > 0x8000!
	or.b	d1,(a2,d2.l)	| merge/log as used, with properties
	movem.w	(a7)+,d1/d2
	.endif


	move.l	(a4,d2.w*4),d4	| test pointer
	jeq		3f			| zero: skipped

	* we can use scratch registers D2,D5,D6 for attribute computation

*       data2 = X.W
*       data0 = Y.W
*		const bool flash = data2 & 0x800;
*		int flipx = data0 & 0x2000;
*		parentFlipY = flipy = data0 & 0x4000;
*		const int h = (1 << ((data0 & 0x1800) >> 11));   /* 1x, 2x, 4x, 8x height */
*		const int w = (1 << ((data0 & 0x0600) >>  9));   /* 1x, 2x, 4x, 8x width */
	and.w	#0x1FF,d0	| remove attribute bits from sprite X
*	btst	#8,d0
*	jeq		0f
*	sub.w	#0x200,d0
*0:
	move.w	d1,d6		| Y coord + attributes
	move.w	d6,d2		| copy full attributes in D2
	rol.w	#5,d6		| data0 height properly times 16
	and.w	#0x3,d6
	and.w	#0x1FF,d1	| remove attribute bits from sprite Y
*	btst	#8,d1
*	jeq		0f
*	sub.w	#0x200,d1
*0:
	* this game sprite system uses 16,32 and 64 (1,2,4x) heights
	* there's also a 8x possible but not there. when displaying
	* a 16-high tile, the coord is OK, but when displaying a 32-high tile
	* we need to subtract 16, and 48 for a 64-high tile
	* we cannot rely on sprite height as it could have been cropped to optimize
	
	* correct X/Y: 240-x
	neg.w	d1
	add.w	#240,d1
	neg.w	d0
	add.w	#240,d0
	
	tst.b	d6
	jeq		0f
	lea		y_correction_table(pc),a3
	sub.w	(a3,d6.w*2),d1
0:
	*move.w	(TARGET_SPRITE_X,a0),d0  | sprite X, already read & masked
	.ifne	SPRITE_Y_CORRECTION
	add.w	#SPRITE_Y_CORRECTION,d1
	.endif
	.ifne	SPRITE_X_CORRECTION
	add.w	#SPRITE_X_CORRECTION,d0
	.endif

*	move.b	(TARGET_SPRITE_ATTRIBUTES,a0),d3
	* todo yflip
*	and.b	#0x0F,d3	| get attributes

	
	move.l	a0,-(a7)
	move.l	d4,a0
	move.l	(a0,d3.w*4),a0	| structure
	btst	#13,d2
	jeq		0f
	* X-flip

	add.w	#6+(NB_PLAYFIELD_PLANES+1)*4,a0
0:
	move.w	(a0)+,d4		| height
	move.w	(a0)+,d5		| width
	add.w	(a0)+,d1		| add offset to Y
	
	.ifeq	OPT_NO_SCROLLING_X
	add.w	x_scroll_value(pc),d0
	.endif 
	.ifeq	OPT_NO_SCROLLING_Y
	add.w	y_scroll_value(pc),d1
	.endif 
	
	
	* now A0 points on the first bitplane of the bob

	move.l		fg_drawed_screen_ptr,a1
	* D0 and D1 are already set
	move.l	(NB_PLAYFIELD_PLANES*4,a0),d2
	beq.b	2f		| mask is zero: blank tile => skip
	move.l	d2,a3	| mask bitplane
	moveq	#0,d2	| no y-clip
	* note down that this bob will have to be erased
	move.w	d0,(a6)+			| store current sprite attributes to previous ones
	move.w	d1,(a6)+			| store current sprite attributes to previous ones
	move.w	d5,(a6)+			| store width
	move.w	d4,(a6)+			| store height
	
	move.w	d5,d2			| width in bytes, 4 for 16 pixels+shift
	moveq	#0,d5			| Y-offset
	moveq	#NB_PLAYFIELD_PLANES,d3
	bsr		blit_planes_any_internal_cookie_cut
	move.l	(a7)+,a0
3:
	addq.w	#TARGET_SPRITE_SIZE,a0
	dbf		d7,1b
	
	rts

y_correction_table:
	.word	0
	.word	16
	.word	48
	.word	48
	
* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
clear_fg_plane_any_blitter_internal:
	moveq	#1,d3
* < A5: custom
* < D0,D1: x,y
* < A1: foreground plane pointer (often first plane!)
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes to clear
* < D4: blit height
* < D7: mask (disabled, -1 set at start)
* trashes D0-D6
clear_fg_planes_any_blitter_internal:
    * pre-compute the maximum of shit here
	move.w	d1,d6
    beq.b   1f    | optim
	* check if y start + height > Y_MAX
	* (ignores case where y = 0, no risk)
	add.w	d4,d6
	sub.w	#Y_MAX,d6
	bmi.b	0f
	* y start + height > Y_MAX: clip height
	sub.w	d6,d4
	beq.b	10f
	bpl.b	0f
10:
	* null or negative height after clipping: out
	rts
0:
    lea mulNB_BYTES_PER_ROW_table,a2
	.ifdef	NO68020
    add.w   d1,d1
    move.w  (a2,d1.w),d1
	.else
    move.w  (a2,d1.w*2),d1
	.endif
1:
	moveq	#1,d5
	ror.l	#8,d5     | AKA move.l  #0x01000000,d5   | minterm useD & rect clear (0xA) 
    and.w   #0x1F0,d0
    beq.b   2f				| zero X optimization
    lsr.w   #3,d0
    add.w   d0,d1
	bclr	#0,d1
2:   
    add.w   d1,a1       | plane position (always even)

	move.w #NB_BYTES_PER_ROW,d0
	bclr	#0,d2		| make sure D2 is even (else strange things occur!)
    sub.w   d2,d0       | blit width

    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set
	.ifdef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  d7,bltafwm(a5)
	.endif
	
	move.l d5,bltcon0(a5)	
    move.w  d0,bltdmod(a5)	|D modulo
	
	subq	#1,d3
	beq.b	4f
	subq	#1,d3
3:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,3b
4:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
    rts



* what: blits 16x? data on one plane, cookie cut
* args:
* < A0: pointers on 16x? data
* < A1: plane  (40 rows)
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height of data
* trashes: D0-D1
blit_planes_cookie_cut_32x:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	moveq	#NB_PLAYFIELD_PLANES,d3		| 4 planes
    moveq  #6,d2       | 32 pixels + 2 shift bytes
	jra		blit_planes_any_internal_cookie_cut
* what: blits 16x? data on one plane, cookie cut
* args:
* < A0: pointers on 16x? data
* < A1: plane  (40 rows)
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height of data
* trashes: D0-D1
blit_planes_cookie_cut_16x:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	moveq	#NB_PLAYFIELD_PLANES,d3		| 4 planes
    moveq  #4,d2       | 16 pixels + 2 shift bytes
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source (pointer on array of planes)
* < A1: destination fg plane, also background to mix with cookie cut fg plane
* < A3: source mask for cookie cut
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D5: y offset for source planes
* < D7: blit mask (not considered, optim, -1 all through the game)
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1
blit_planes_any_internal_cookie_cut:
    movem.l d0-d7/a4,-(a7)
    * pre-compute the maximum of shit here
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	swap	d1
	clr.w	d1
	swap	d1
	
	lea		cookie_cut_blit_table,a4
	
    move.w  d0,d6
    lsr.w   #3,d0			| X displacement in bytes
	*bclr	#0,d0			| no need, it will be even
    and.w   #0xF,d6
	.ifdef	NO68020
	add.w	d6,d6
	add.w	d6,d6
	move.l	(a4,d6.w),d7
	move.l	(a4,d6.w),d6
	.else
	move.l	(a4,d6.w*4),d7
	lea		cookie_cut_mask_blit_table,a4
	move.l	(a4,d6.w*4),d6
	.endif
3:   
    add.l   d0,d1
4:
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    *bclr    #0,d1
    add.l   d1,a1       | plane position (D1 can be 0x7FFF, up to 0xC000)
	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0
	neg.w	d4    | make d4 positive again
5:
    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height
    * always the same settings (ATM)
	moveq	#0,d2
	
    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	move.w d2,bltamod(a5)		|A modulo=bytes to skip between lines
	move.w d2,bltbmod(a5)		|B modulo=bytes to skip between lines
	move.l d7,bltcon0(a5)	| sets con0 and con1: full cookie cut 2 sources & 1 mask
	
    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
					
	add.w	d5,a3			| apply y offset to mask too (y offset looks wrong)
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	bsr.b	start_process_1_plane
	
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,6b
7:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	bsr.b	start_process_1_plane
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d7/a4
    rts
	
start_process_1_plane:
	move.l (a0)+,d0
	beq.b	60f
	move.l	d0,a4
	add.w	d5,a4		| add Y offset
	bra.b	61f
60:
	* source is 0: just apply mask (less bandwidth lost) and change bltcon
	move.l	d6,bltcon0(a5)	| sets con0 and con1: C-A->D cookie cut, B fixed
 	move.w	d2,bltbdat(a5)	|B word is zero
	rts
61:
	* non-zero: set data source & bltcon
	move.l	d7,bltcon0(a5)	| sets con0 and con1: C-A+B->D cookie cut full
	move.l	a4,bltbpt(a5)	|source graphic top left corner
	rts

	.macro	GEN_MINTERM_TABLE	name,value
\name\()_table:
	.set	shift,0
	.rept	16
	.long	(shift<<28)+(shift<<12)+\value
	.set	shift,shift+1
	.endr
	.endm
	
	GEN_MINTERM_TABLE	cookie_cut_blit,0x0FCA0000
	GEN_MINTERM_TABLE	cookie_cut_mask_blit,0x0BCA0000

* 2 words: first shift (as bplcon value), then
* offset in bytes



* what: blits data on bg plane, no horizontal shifting (erase)
* args:
* < A0: pristine background
* < A1: dest buffer
* < D0: X (rounded to smaller 8-multiple)
* < D1: Y
* < D2: width in bytes
* < D4: height

* > A1: last clear position address
* trashes: D0-D1

restore_background:
	movem.l	d2-d6/a0/a2-a5,-(a7)
	lea		_custom,a5
	* adjust offset X: X//8 even rounded
	lsr.w	#4,d0
	add.w	d0,d0
	swap	d0
	clr.w	d0
	swap	d0
	
	lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
	* add Y offset: Y*40
	move.w	(a4,d1.w),d3
	.else
	move.w	(a4,d1.w*2),d3
	.endif
	
	add.l	d3,d0		| long add, we have a big buffer > 0x8000
	* same offset for source and destination
	add.l	d0,a1
	add.l	d0,a0
	

    move.l  #0x09f00000,d3    | A->D copy, ascending mode	
	move.w	#NB_BYTES_PER_ROW,d1		| blit modulo

    sub.w   d2,d1       | blit modulo
    lsl.w   #6,d4
    lsr.w   #1,d2		| blit width
    add.w   d2,d4       | blit height
	
    * always the same settings

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	move.l d3,bltcon0(a5)	| sets con0 and con1

    move.w  d1,bltamod(a5)	|A modulo
    move.w  d1,bltdmod(a5)	|D modulo
							
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
	move.w	nb_tile_planes_24a000,d0
	subq	#2,d0
0:
	lea	(RESTORE_SCREEN_PLANE_SIZE,a0),a0
	lea	(SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	dbf		D0,0b
	
	movem.l	(a7)+,d2-d6/a0/a2-a5
	rts


* < A5: custom
* < D0.W,D1.W: x,y, no shifting
* < A0: source (pointer on array of planes)
* < A1: destination fg plane
* < D2: width in bytes
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D5: y offset for source planes
* < D7: blit mask (not considered, optim, -1 all through the game)
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1
blit_planes_any_internal_no_cookie_cut:
    movem.l d0-d7/a4,-(a7)
    * pre-compute the maximum of shit here
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	
    lsr.w   #3,d0			| X displacement in bytes

    add.w   d0,d1

	move.l  #0x09f00000,d7    | A->D copy, ascending mode
	move.l  #0x0FCA0000,d6     | D clear

    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    *bclr    #0,d1
    add.w   d1,a1       | plane position (D1 < 0x7FFF, 288*40=0x2D00)
	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0
	neg.w	d4    | make d4 positive again
5:
    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height
    * always the same settings (ATM)
	moveq	#0,d2
	
    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	move.w d2,bltamod(a5)		|A modulo=bytes to skip between lines
	
    move.w  d0,bltdmod(a5)	|D modulo
					
	add.w	d5,a3			| apply y offset to mask too (y offset looks wrong)
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	bsr.b	start_process_1_plane_nocc
	
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,6b
7:
	bsr.b	start_process_1_plane_nocc
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d7/a4
    rts
	
start_process_1_plane_nocc:
	move.l (a0)+,d0
	bne.b	61f

	* source is 0: just apply mask (less bandwidth lost) and change bltcon
	move.l	d6,bltcon0(a5)	| sets con0 and con1: clear
 	move.w	d2,bltbdat(a5)	|B word is zero
	rts
61:
	* non-zero: set data source & bltcon
	move.l	d7,bltcon0(a5)	| sets con0 and con1: C-A+B->D cookie cut full
	move.l d0,bltapt(a5)	| source graphic top left corner
	rts

	
bob_previous_positions_1:
	ds.b	NB_TARGET_SPRITES*PREVIOUS_SPRITE_SIZE
bob_previous_drawed_sprites:
	.long	bob_previous_positions_1
bob_previous_displayed_sprites:
	.ifeq	OPT_ENABLE_DOUBLE_BUFFERING
	.long	bob_previous_positions_1
	.else
	.long	bob_previous_positions_2	
bob_previous_positions_2:
	ds.b	NB_TARGET_SPRITES*PREVIOUS_SPRITE_SIZE	
	.endif

sprite_registers:
	ds.l	NB_TARGET_SPRITES+2		| we need more room for background scroll regs
	
	

switch_screen_buffers:

	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	* let's switch screen buffers, background (chars)
	* toggle fg planes (double buffering)
	* also toggle previous sprite positions
	lea		fg_drawed_screen_ptr,a0
	lea		bob_previous_positions_1,a2
	lea		bob_previous_positions_2,a3
	move.l	fg_screen_data_1,a1
	move.l	fg_screen_data_2,a5
	* also switch previous state memory
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
	exg		a2,a3
2:
	move.l	a1,(a0)
	move.l	a5,fg_displayed_screen_ptr
	move.l	a2,bob_previous_drawed_sprites

	lea		bobs_bitplanes_game+2,a0
	jbsr		set_playfield_bitplanes
	.endif
	
	rts
	
store_system:
	tst.l	_resload
	beq.b	0f
	rts
0:
	* system copper
	
	move.l	4.W,a6
	move.w	AttnFlags(a6),d0
	btst	#AFB_68010,d0
	beq.b	1f
	lea	get_vbr,a5

	jsr		_LVOSupervisor(a6)
	move.l	d0,system_vbr
1:
	

	lea	_custom,a6
	move.w	intenar(a6),old_intena
	move.w	dmaconr(a6),old_dmacon
	lea		old_sysvectors,a0
	move.l	system_vbr,a1
	move.l	(0x68,a1),(a0)+
	move.l	(0x6c,a1),(a0)+
	move.l	(0x70,a1),(a0)+
	move.l	(0x74,a1),(a0)+
	move.l	(0x78,a1),(a0)+
	move.l	(0x7C,a1),(a0)+
	rts

restore_system:
	move.l	system_vbr,a0
	lea	_custom,a6
	jsr		_mt_remove_cia

	move.w	#0x4000,intena(a6)	| ints off
	lea		old_sysvectors,a0
	move.l	system_vbr,a1
	move.l	(a0)+,(0x68,a1)
	move.l	(a0)+,(0x6c,a1)
	move.l	(a0)+,(0x70,a1)
	move.l	(a0)+,(0x74,a1)
	move.l	(a0)+,(0x78,a1)
	move.l	(a0)+,(0x7C,a1)


	bclr	#6,0xbfee01


	lea	_custom,a6
	move.w	old_intena,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0
	move.w	d0,intena(a6)		| clr bits
	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,intena(a6)		| set bits and main

	move.w	old_dmacon,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0

***		and.w	#0xfff0,d0		| preserve sound dma for now

	move.w	d0,dmacon(a6)		| clr bits



	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,dmacon(a6)		| set bits and main

	move.l	old_syscoplist,cop1lc(a6)
	move.l	_gfxbase,a6
	move.b	gb_ChipRevBits0(a6),chiprevbits+3
	move.l	old_actiview,a1
	jsr	_LVOLoadView(a6)


	moveq	#0,d0
	rts

quit_to_os:
	tst.l	_resload
	bne.b	0f
	bsr		restore_system
	* set SR to 0 from here, so we return to OS with SR=0
	* (else it kills the system pretty quickly)
	* it works as quit_to_os is called from an interrupt
	move.w	#0,SR
	move.l	old_stack,a7
	jbsr		save_highscores
	moveq	#0,d0
	rts
0:
	pea	  TDREASON_OK
	move.l	_resload,-(a7)
	addq.l	#resload_Abort,(a7)
	rts



* set sprite pointers on chipmem zone
* < A0: copperlist

init_sprite_bank:
	move.l	#blank_sprite,a1
	move.w	#sprpt,d0
	move.w	#NB_HOST_SPRITES-1,d2		| 7
0:
	move.w	d0,(a0)+
	swap	d1
	move.w	d1,(a0)+
	swap	d1
	addq	#2,d0
	move.w	d0,(a0)+
	move.w	d1,(a0)+
	
	addq	#2,d0
	dbf		d2,0b
	rts
	
platform_init:
	bsr		store_system
	

	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	move.w	#0x7FFF,intena(a5)
	* set blitter parameters once and for all
    move.l  #-1,bltafwm(a5)
	
*	move.l	monitor,d0
*	cmp.l	#NTSC_MONITOR_ID,D0
*	bne		0f
*	* disable extra mid-screen interrupt, as it would be too fast (NTSC)
*	move.w	#0x1FE,intreq_block
*	move.w	#0x1FE,intreq_block+4
*0:

 	*         VVHH
    move.w #0x2481,diwstrt(a5)
    move.w #0x24A0-0x800,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)

	* restrict borders: we don't see bobs on the borders!
	* try to hide color 0 on the border (except on OCS)
    move.w #BASE_BPLCON2_VALUE,bplcon2(a5)
	* AGA-compatible ECS default values
	move.w	#0x32,bplcon4(a5)	| odd sprites palette start at color 48, even at 32
    move.w #(SPRITE_FMODE<<2)+0x1,fmode(a5)

	move.w	#0,bplcon1(a5)
	moveq	#-4+NB_BYTES_PER_ROW-40,d0
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)

	

	
	* set sprite registers in copperlist
	lea		intro_sprites,a0
	bsr		init_sprite_bank
	


	* wait 300 lines
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	
    * init sprite, bitplane, whatever dma

    move.w #0x83E0,dmacon(a5)
 
	* install keyboard and vblank/copper handler
	move.l	system_vbr,a1
	pea		level2_interrupt
	move.l	(a7)+,(0x68,a1)
	pea		_vblank
	move.l	(a7)+,(0x6C,a1)
	pea		_nmi
	move.l	(a7)+,(0x7C,a1)

	* soundfx lib
	lea		_custom,a6
	lea		blank_sound,a0
	move.l	a0,(0xA0,a6)
	move.l	a0,(0xB0,a6)
	move.l	a0,(0xC0,a6)
	move.l	a0,(0xD0,a6)
	move.l	system_vbr,a0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	lea		0x180000,a0
	move.l	#0x20000,d0
	lea		0x100,a1
	bsr		init_fixed_address
	bsr		install_profiler_vbl_hook
	.endif

	
    rts
	
* < A0: filename
* > D0,D1: file pointer, file size
allocate_and_load_public_mem_file:
	jbsr	get_file_size
	move.l	D0,-(a7)
	moveq	#0,d1
	jbsr	allocate_memory
	move.l	d0,a1
	move.l	a1,-(a7)
	jbsr	load_and_decrunch_file
	move.l	(a7)+,d0
	move.l	(a7)+,d1
	rts
	
* < A0: filename
* > D0,D1: file pointer, file size
allocate_and_load_chip_mem_file:
	jbsr	get_file_size
	move.l	D0,-(a7)
	moveq	#1,d1
	jbsr	allocate_memory
	move.l	d0,a1
	move.l	a1,-(a7)
	jbsr	load_and_decrunch_file
	move.l	(a7)+,d0
	move.l	(a7)+,d1
	rts
	
load_and_decrunch_file:
	move.l	_resload,a2
 	jsr	(resload_LoadFileDecrunch,a2)
	rts
	
* < A0: filename
* > D0: size (decrunch supported)
get_file_size:
	tst.l	_resload
	jeq		0f
	movem.l	d1/a0-a2,-(a7)
	move.l	_resload,a2
	jbsr	(resload_GetFileSizeDec,a2)
	movem.l	(a7)+,d1/a0-a2
	rts
0:
	* unsupported
	illegal
	illegal
	illegal
	rts
	
* < D0: required size
* < D1: 0 any, 1 chip
* > d0: allocated block
allocate_memory:
	movem.l	d2-d4/a0-a1,-(a7)
	tst.b	d1
	jeq		0f
	lea		chip_memory_block,a0
	lea		chip_memory_current_ptr,a1
	move.l	#TOTAL_CHIP_MEMORY_SIZE,d3
	jra		1f
0:
	lea		public_memory_block,a0
	lea		public_memory_current_ptr,a1
	move.l	#TOTAL_PUBLIC_MEMORY_SIZE,d3
1:
	and.l	#0xFFFFFFF0,d0
	add.l	#0x10,d0	| will always be aligned on 0x10 bytes
	
	move.l	(a1),d2
	move.l	d2,d4
	sub.l	a0,d2		| occupied size
	add.l	d0,d2		| next free block
	cmp.l	d3,d2		| compare to max
	jcc		out_of_memory
	add.l	d0,(a1)
	move.l	d4,d0		| return value
	movem.l	(a7)+,d2-d4/a0-a1
	rts
	
out_of_memory:
	BREAKPOINT	"out of memory"
	illegal

	
* < D0: 0 any, 1 chip	
free_all_memory:
	lea		public_memory_block,a0
	move.l	a0,public_memory_current_ptr
	lea		chip_memory_block,a0
	move.l	a0,chip_memory_current_ptr
	rts
	
* < A0: palette
* < A1: copperlist
* < D0: number of colors to load	
load_palette:
	subq.w	#1,d0
	beq.b	2f
1:
	addq.w	#2,a1
	move.w	(a0)+,(a1)+
	dbf		d0,1b
2:
	rts
	
* < A1: copperlist
* < D0: number of colors to unload	
unload_palette:
	subq.w	#1,d0
	beq.b	2f
1:
	move.w	#0x1FE,(a1)+		| nop
	addq.w	#2,a1
	dbf		d0,1b
2:
	rts
	

* < A0: palette
* < A1: copperlist
* < D0: number of colors to load	
* < D1: color register to start from (color)
load_palette_fully:
	subq.w	#1,d0
	beq.b	2f
1:
	move.w	d1,(a1)+
	move.w	(a0)+,(a1)+
	addq	#2,d1	| next color reg
	dbf		d0,1b
2:
	rts
	

osd_is_vblank_interrupt_enabled:
	move.w	_custom+intenar,d0
	btst	#5,d0			| check vblank interrupt
	rts
	


* 60Hz VBLANK interrupt (also keyboard)
osd_enable_interrupts:
	tst.b	interrupt_mode
	beq.b	0f
	* clear SR from interrupt mode, so enable interrupts really
	* works from the game (which calls enable interrupts from interrupt)
	move.w	#0x2000,SR
0:
	move.w	#0xC038,_custom+intena
	rts
	
osd_disable_interrupts:
	tst.b	interrupt_mode
	beq.b	0f
	* if interrupts are disabled again from interrupt, re-set SR
	move.w	#0x2700,SR
0:
	move.w	#0x0030,_custom+intena
	rts



	

set_scroll_x:
	move.w	x_scroll_value,d1
	cmp.w	d1,d0
	jne		0f
	rts
0:
	.ifne	OPT_NO_SCROLLING_X
	rts
	.endif
	move.w	d0,x_scroll_value
	jra		set_game_bitplanes

set_scroll_y:
	move.w	y_scroll_value,d1
	cmp.w	d1,d0
	jne		0f
	rts
0:
	.ifne	OPT_NO_SCROLLING_Y
	rts
	.endif
	move.w	d0,y_scroll_value
	jra		set_game_bitplanes

set_playfield_bitplanes:
	* set bitplanes
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.w	y_scroll_value,d0
	*and.w	#0x1FF,d0		| wrap just in case
	lea		mulNB_BYTES_PER_ROW_table,a2
	move.w	(a2,d0.w*2),d0		| compute Y offset
	move.w	x_scroll_value,d2	
	lea		scroll_table,a2
	move.w	(a2,d2.w*4),fine_x_scroll_value
	add.w	(2,a2,d2.w*4),d0
	* TEMP TEMP
	*lsr.w	#3,d2
	*BCLR	#0,d2
	*add.w	d2,d0
	
    add.l	fg_drawed_screen_ptr,d0
	
	move.l	#SCREEN_PLANE_SIZE,d2
0:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l d2,d0		| LONG!
    dbf d1,0b
	rts

set_game_bitplanes:	
	movem.l	d0-d3/a0-a2,-(a7)
    lea	bitplanes_intro+2,a0
	jbsr	set_playfield_bitplanes
	movem.l	(a7)+,d0-d3/a0-a2
    rts
		

* 2 words: first shift (as bplcon value), then
* offset in bytes

scroll_table:
	.include	"scroll_table.68k"



HW_SpriteXTable:
	.set	reptn,0
	.rept 320
	.set	x,reptn+0x80
	.set reptn,reptn+1
    .byte  0,x>>1,0,x&1
  .endr

	.macro DEF_HW_SPRITE_Y_TABLE	height
HW_SpriteYTable_\height:
  .set	reptn,0
  .rept 288
	.set	ys,reptn+0x1c
	.set	ye,ys+\height
    .byte  ys&255, 0, ye&255, ((ys>>6)&4)+((ye>>7)&2)
	.set	reptn,reptn+1
  .endr
	.endm



	

osd_debug_hook:
	rts
	

BIT_INSERT_COIN_1 = 4
BIT_INSERT_COIN_2 = 5
BIT_START_1P = 2
BIT_START_2P = 3

BIT_UP = 0
BIT_LEFT = 2
BIT_RIGHT = 3
BIT_DOWN = 1
BIT_FIRE1 = 4
BIT_FIRE2 = 5

read_system_inputs:
	move.b	#0x7F,d0		| sync flag set, always
	movem.l	a0/d1,-(a7)
	lea		keyboard_table,a0
	* misc control keys
	tst.b	(6,a0)		| "6" key like in MAME
	beq.b	0f
	bclr	#BIT_INSERT_COIN_2,d0
0:	
	tst.b	(5,a0)		| "5" key like in MAME
	beq.b	0f
	bclr	#BIT_INSERT_COIN_1,d0
0:
	tst.b	(1,a0)		| "1" key like in MAME
	beq.b	0f
	bclr	#BIT_START_1P,d0
0:
	tst.b	(2,a0)		| "2" key like in MAME
	beq.b	0f
	bclr	#BIT_START_2P,d0
0:	


*	* directions + fire
*	move.l	_joypad_state,d1
*	btst	#JPB_BTN_UP,d1
*	beq.b	0f
*	bclr	#3,d0
*0:
*	btst	#JPB_BTN_DOWN,d1
*	beq.b	0f
*	bclr	#2,d0
*0:
*
*	btst	#JPB_BTN_RED,d1
*	beq.b	0f
*	bclr	#5,d0
*0:
	movem.l	(a7)+,a0/d1
	rts
	
osd_sound_stop:
	rts
	
osd_sound_start:
	rts

save_highscores:
	rts

load_highscores:
	rts
	
read_controls:
	moveq	#-1,d0
	movem.l	a0/d1,-(a7)

	lea		keyboard_table,a0

	tst.b	(0x4C,a0)		| "up" key
	beq.b	0f
	bclr	#BIT_UP,d0
0:
	tst.b	(0x4D,a0)		| "down" key
	beq.b	0f
	bclr	#BIT_DOWN,d0
0:
	tst.b	(0x4F,a0)		| "<-" key
	beq.b	0f
	bclr	#BIT_LEFT,d0
0:
	tst.b	(0x4E,a0)		| "->" key
	beq.b	0f
	bclr	#BIT_RIGHT,d0
0:
	tst.b	(0x63,a0)		| "ctrl" key
	beq.b	0f
	bclr	#BIT_FIRE1,d0
0:
	tst.b	(0x64,a0)		| left "alt" key
	beq.b	0f
	bclr	#BIT_FIRE2,d0
0:


	* directions + fire
	move.l	_joypad_state,d1
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#BIT_UP,d0
0:
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#BIT_DOWN,d0
0:
	btst	#JPB_BTN_LEFT,d1
	beq.b	0f
	bclr	#BIT_LEFT,d0
0:
	btst	#JPB_BTN_RIGHT,d1
	beq.b	0f
	bclr	#BIT_RIGHT,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	0f
	bclr	#BIT_FIRE1,d0
0:
	btst	#JPB_BTN_BLU,d1
	beq.b	0f
	bclr	#BIT_FIRE2,d0
0:

	movem.l	(a7)+,a0/d1
	rts


osd_read_inputs:

	moveq	#-1,d0
		
	movem.l	a0/d1,-(a7)

*	bsr		is_game_playing
*	bne.b	2f
*0:
	* if game not playing, or within "continue" loop
	* consider "fire" as insert coin
	move.l	_joypad_state,d1
	* save prev state as game loops within vblank
	* pushing fire would either lockup the game
	* or insert a lot of credits simulatenously

	* game not in play, accept start 1P game with "up"
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#BIT_START_1P,d0
0:
	* game not in play, accept start 2P game with "down"
	* temp: disabled ATM, 2P mode is buggy!
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#BIT_START_2P,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	1f
	* game not in play, accept insert coin with fire
	bclr	#BIT_INSERT_COIN_1,d0
1:
2:

	lea		keyboard_table,a0
	* misc control keys
	tst.b	(5,a0)		| "5" key like in MAME
	beq.b	0f
	bclr	#BIT_INSERT_COIN_1,d0		| insert coin
0:
	tst.b	(1,a0)		| "1" key like in MAME
	beq.b	0f
	bclr	#BIT_START_1P,d0
0:
	tst.b	(2,a0)		| "2" key like in MAME
	beq.b	0f
	bclr	#BIT_START_2P,d0
0:	
	movem.l	(a7)+,a0/d1

	rts
	
osd_read_dsw1:
	* actual dipswitches
	move.b	dip_switches_1,d0
	not.b	d0		| active low
	rts
osd_read_dsw2:
	* actual dipswitches
	move.b	dip_switches_2,d0
	moveq	#0,d0		| ATM cleared, related to coinage
	rts
osd_read_dsw3:
	* actual dipswitches
	move.b	dip_switches_3,d0
	not.b	d0		| active low
	rts

	


	

level2_interrupt:
	bsr		handle_keyboard
	move.w	#8,_custom+intreq
	rte
	
handle_keyboard:
	movem.l	D0/A0/A5,-(a7)
	LEA	0x00BFD000,A5
	MOVEQ	#0x08,D0
	AND.B	0x1D01(A5),D0
	jeq		1f
	MOVE.B	0x1C01(A5),D0
	NOT.B	D0
	ROR.B	#1,D0		| raw key code here
  
	CLR.B	0x1C01(A5)
  
    lea keyboard_table,a0
    bclr    #7,d0
    seq (a0,d0.w)       | updates keyboard table
    jne   2f     | we don't care about key release
	
    cmp.b   #0x19,d0	| "P" key
    bne.b   0f

    bsr	toggle_pause
0:

	btst	#4,cheat_flags+3
	jeq		10f
	* cheat keys
	cmp.b	#0x50,d0	| F1 key
	bne.b	0f
	move.w	#0x0FF,_custom+color
	
	st.b	cheat_used
	
0:
	cmp.b	#0x51,d0	| F2 key
	bne.b	0f
	st.b	cheat_used
	move.w	#0x0FF,_custom+color
	
0:
	cmp.b	#0x52,d0	| F3 key
	bne.b	0f
	st.b	cheat_used
	* add 10000 points
0:
	cmp.b	#0x53,d0	| F4 key
	bne.b	0f
	st.b	cheat_used
	move.w	#0x0FF,_custom+color
	eor.b	#1,invincible_flag
0:
*	cmp.b	#0x54,d0	| F5 key
*	bne.b	0f
*	st.b	cheat_used
*	move.w	#0x0FF,_custom+color
*0:
*
10:
	.ifndef	RELEASE
	cmp.b	#0x57,d0	| F8 key: lose all lives
	bne.b	0f
	move.w	#0x0FF,_custom+color
	* last life, if killed, direct game over
	
0:
	cmp.b	#0x58,d0	| F9 key crashes game (restarts whdload)
	bne.b	0f
	illegal
	.endif
0:

	cmp.b	_keyexit,d0	| "ESC" key or whdload quitkey
	bne.b	2f
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key
	bra		quit_to_os
2:
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key

1:
	movem.l	(a7)+,d0/a0/a5
	rts
	
toggle_pause:
	* pause only within game
	jbsr		is_game_playing
	beq.b	0f
	eor.b   #1,pause_flag
0:
	rts

	
osd_set_context:
	movem.l	d0-a6,-(a7)
	cmp.w	global_context,d0
	jeq		1f

	move.w	d0,global_context
	jbsr	free_all_memory
	jbsr	clear_log_memory

	lea		game_context_table,a0
	jsr		([a0,d0.w*4])
1:
	movem.l	(a7)+,d0-a6
	rts
	
clear_log_memory:
	.ifne	OPT_ENABLE_LOGGING
	* context change: clear tile log: it is no longer relevant
	* but not for layer 244000 which is shared
	lea	tile_log_table_24a000,a0
0:
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	clr.l	(a0)+
	cmp.l	#tile_log_table_end,a0
	jne	0b
	.endif
	rts
	
game_context_table:
	.long	0
	.long	set_intro_context			| CTX_INTRO
	.long	set_high_score_context		| CTX_HIGH_SCORE
	.long	set_game_intro_context	    | CTX_GAME_INTRO
	.long	set_game_context		    | CTX_GAME
	
load_tiles_file_244000:
	lea		tiles_title_244000_file,a0
	jbsr	allocate_and_load_public_mem_file
	move.l	d0,tiles_244000
	* set palette
	move.l	d0,a0
	add.w	#4+(56*2),a0	| skip nb planes (6) plus 56 dummy colors

	move.l	a0,letters_colors

	move.l	tiles_244000,a0
	add.w	#4+(64*2),a0	| skip nb planes (6) plus palette
	
	move.l	a0,tile_data_244000
	
	jbsr	load_letters_colors
	
	rts
	
load_tiles_file_24a000:
	jbsr	allocate_and_load_public_mem_file
	move.l	d0,a0
	move.w	(a0)+,d0	| nb planes
	move.w	(a0)+,d1	| nb block planes (ignored)
	move.l	a0,tiles_palette_24a000
	move.w	d0,nb_tile_planes_24a000		| save it for later
	moveq	#0,d1
	bset	d0,d1
	move.w	d1,nb_tile_colors_24a000
	add.w	d1,d1
	add.w	d1,a0
	move.l	a0,tile_data_24a000	 			| save it for later
	rts
	
load_letters_colors:
	move.l	letters_colors,a0
	lea		letters_palette,a1
	move.w	#8,d0
	jbsr	load_palette
	rts
	
**********************
* GAME INTRO CONTEXT *
**********************

set_game_intro_context:
	jbsr	remove_dudes

	jbsr	load_tiles_file_244000

	
	lea		tiles_game_intro_24a000_file,a0
	jbsr	load_tiles_file_24a000

	jbsr	load_intro_palette
	
	* load a few sprites: glasses & talking mouth of the guy
	
	lea		sprites_game_intro_file,a0
	jbsr 	load_sprite_file
	
	* re-apply letter colors 56-63 (the sprites in that context only use 24 colors
	* so we're good!)
	jbsr	load_letters_colors
	rts
	
load_sprite_file:
	jbsr	allocate_and_load_chip_mem_file
	move.l	d0,sprites_memory
	move.l	d0,a0
	move.w	(a0)+,d0	| nb planes (6) ignore
	move.w	(a0)+,d1	| nb plane blocks
	lea	(0x40,a0),a0	| skip 32 first colors
	move.l	a0,a1
	add.w	#0x40,a1
	move.l	a1,sprite_table_base
	lea	sprites_palette,a1
	move.w	#32,d0
	jbsr	load_palette
	
	* relocate tile tables so they're no longer relative (generic blit routines
	* work like that, no need to rewrite them)
	* triple loop!
	
	move.l	sprite_table_base,a0
	move.l	a0,d1
	move.w	#0xFFF,d7		| number of sprites
0:
	move.l	(a0)+,d2
	jeq		1f				| not defined: skip
	add.l	d1,d2			| add to displacement: pointer becomes absolute
	move.l	d2,(-4,a0)		| store
	* now relocate each clut
	move.w	#15,d6			| number of cluts
	move.l	d2,a1
10:
	move.l	(a1)+,d3
	jeq		2f
	add.l	d2,d3			| add to displacement: pointer becomes absolute
	move.l	d3,(-4,a1)		| store
	* now relocate each bitplane
	move.l	d3,a2
	.rept	2
	move.w	#NB_PLAYFIELD_PLANES+1-1,d5  | standard + mirror (bobs) with mask
	addq	#6,a2		| skip h,w,y offset!
20:
	move.l	(a2)+,d4
	jeq		3f
	add.l	d3,d4
	move.l	d4,(-4,a2)		| store
3:
	dbf	d5,20b
	.endr
2:
	dbf	d6,10b			| next clut
1:
	dbf	d7,0b			| next sprite
	rts
	
**********************
* HIGH SCORE CONTEXT *
**********************
	
set_high_score_context:
	jbsr	remove_dudes

	jbsr	load_tiles_file_244000
	
	lea		tiles_highs_24a000_file,a0
	jbsr	load_tiles_file_24a000

	jbsr	load_intro_palette
	
	rts

****************
* GAME CONTEXT *
****************

set_game_context:
	jbsr	load_tiles_file_244000
	
	lea		tiles_level_1_24a000_file,a0
	jbsr	load_tiles_file_24a000

	jbsr	load_intro_palette
	
	* stuck level 1
	lea		sprites_game_level_1_file,a0
	jbsr 	load_sprite_file
	

	rts


	
set_intro_context:

	* load data files for intro

	jbsr	load_tiles_file_244000
	
	
	* TODO: store current memory pointer to avoid resetting all & reload
	
	lea		tiles_title_24a000_file,a0
	jbsr	load_tiles_file_24a000
	
	lea		dudes_pics_files,a0
	jbsr	allocate_and_load_chip_mem_file
	move.l	d0,dude_pics
	
	* resolve relative relocs so generic blitter routines can be used
	* and it also avoids a lot of confusion & bugs
	* if we wanted more speed we could even copy the header into fastmem after that
	* but for intro pics it's probably not worth it
	
	move.l		dude_pics,a0
	move.l	d0,a0
	* dude pic struct relative => absolute
	add.l		d0,(a0)
	add.l		d0,(4,a0)
	
	moveq	#1,d1
0:
	move.l	(a0)+,a1	| pointer on dude pic struct
	move.l	a1,d2
	add.w	#0x40+8,a1	| skip palette & size
	moveq	#6,d0		| 6 bitplanes + mask
1:
	add.l	d2,(a1)+	| relocate to absolute
	dbf		d0,1b
	dbf		d1,0b
	
	
	* set intro copperlist
	
	lea		_custom,a5
	* set them even if reset by game afterwards
	* avoiding ugly stripe bitplane effect at startup
    lea	bitplanes_intro+2,a0
	bsr		set_playfield_bitplanes

	jbsr	load_intro_palette
	
	lea		intro_copperlist,a0
	move.l	a0,cop1lc(a5)

	rts

load_intro_palette:
	* set game intro palette
	lea		intro_palette,a1
	move.w	nb_tile_colors_24a000,d0
	move.l	tiles_palette_24a000,a0		| palette
	jbsr	load_palette
	rts
	
	
remove_dudes:
	* clear dudes pics (basically lower part of screen)
	
* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
	lea	_custom,a5
	moveq	#0,d0
	move.w  #120,d1
	move.w	#256,d4
	sub.w	d1,d4
	move.w	#NB_BYTES_PER_ROW,d2
	move.w	#NB_PLAYFIELD_PLANES,d3		| all planes
	move.l	fg_displayed_screen_ptr,a1
	jbsr	clear_fg_planes_any_blitter_internal
	
	moveq	#0,d0
	move.w  #120,d1
	move.w	#256,d4
	sub.w	d1,d4
	move.w	#NB_BYTES_PER_ROW,d2
	move.w	#NB_PLAYFIELD_PLANES,d3
	move.l	fg_drawed_screen_ptr,a1
	jbsr	clear_fg_planes_any_blitter_internal
	

	
	WAIT_BLIT
	rts	
* < D0: numbers of vertical positions to wait
beamdelay:
0:
	move.w  d0,-(a7)
    move.b	0xdff006,d0	| VPOS
1:
	cmp.b	0xdff006,d0
	beq.s	1b
	move.w	(a7)+,d0
	dbf	d0,0b
	rts

	
	MUL_TABLE	NB_BYTES_PER_ROW,512

	.align	4		| leave this long word alignment
program_args:	ds.l	64,0
program_args_end:
	.long	0		| add a longword else it overwrites the read args string in kick 1.3!
	.align	4
read_args_string:
	.byte	read_args_string_end-read_args_string
	.ascii	"INVINCIBLE/S,INFLIVES/S,STARTLEVEL/S,"
	.ascii	"CHEATKEYS/S,STARTLIVES/K/N"
read_args_string_end:
	.align	2


	.ifndef	RELEASE

write_videoram_out_of_range_error:
	.asciz	"write videoram out of range"
game_tile_not_registered_error:
	.asciz	"game tile (in D2) not registered"
title_tile_not_registered_error:
	.asciz	"title tile (in D2) not registered"
	
	.align	2
	.endif

old_intena:
	.long	0
old_dmacon:
	.long	0
old_sysvectors:
	ds.l	10
old_vbr:
	.long	0
old_syscoplist:
	.long	0
old_actiview:
	.long	0
old_stack:
	.long	0
return_address:
	.long	0
global_context:
	.word	0
display_dudes:
	.word	0
x_scroll_value:
	.word	0
y_scroll_value:
	.word	0
first_half_flag:
	.word	0
_tag:
		.long	WHDLTAG_MONITOR_GET
monitor:
		.long	0
		.long	WHDLTAG_CHIPREVBITS_GET
chiprevbits:
		.long	0
		.long	WHDLTAG_CUSTOM1_GET
cheat_flags:
		.long	0
		.long	WHDLTAG_CUSTOM2_GET
control_flags:
		.long	0

		.long	WHDLTAG_CUSTOM3_GET
misc_options:
		.long	0
		.long	WHDLTAG_CUSTOM4_GET
dip_switch_start_course:
		.long	0
		.long	WHDLTAG_CUSTOM5_GET
dip_switch_start_lives:
		.long	0
	.long	0
dip_switches_1:
		.byte	0
dip_switches_2:
		.byte	0
dip_switches_3:
		.byte	0
current_gfx_bank:
	.byte	-1

mid_screen_interrupt:
	.byte	0
mid_screen_interrupt_count:
	.byte	0
	.align	2
system_vbr:
	.long	0


flip_flop:
	.byte	0

	.align	2

host_sprites:
	ds.b	8*SPRITE_SIZEOF
keyboard_table:
	ds.b	0x100

	
interrupt_mode:
	.byte	0

pause_flag:
	.word	0


vbl_counter:
	.word	0
_resload:
	.long	0
_joypad_state:
	.long	0
_previous_joypad_state:
	.long	0
_gfxbase:
	.long	0
_dosbase:
	.long	0
music_tick:
	.word	0
delay_timer:
	.word	0
one_out_of_five:
	.word	0
fg_screen_data_1:
	.long	0
fg_screen_data_2:
	.long	0
	
	* macro to define a color0 change, synced with baddudes shafts
	* thanks to ross for finetuning this part, it was tricky!
	.macro	 DYN_COLOR_ROW	hpos
    .word    0x35+(\hpos<<8),0xFFFE
    .word    color,0
    .word    0x55+(\hpos<<8),0xFFFE
    .word    color,0
    .word    0x01fe,0xFFFE
    .word    color,0
    .word    0x75+(\hpos<<8),0xFFFE
    .word    color,0
    .word    0x01fe,0xFFFE
    .word    color,0
    .word    0x95+(\hpos<<8),0xFFFE
    .word    color,0
    .word    0x01fe,0xFFFE
    .word    color,0
    .word    0xB5+(\hpos<<8),0xFFFE
    .word    color,0
 	.word	 0x01+((\hpos+1)<<8),0xFFFE
  	.endm
	
	* just to get the size of the color row
color_row_start:
	DYN_COLOR_ROW	0
color_row_end:

fg_drawed_screen_ptr:
	.long	0
fg_displayed_screen_ptr:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	.long	0
	.else
	.long	0
	.endif


	.include	"sound_entries.68k"

update_tile_function:
	.long	0
_keyexit:
	.byte	0x45	| ESC by default unless whdload overwrites it

main_scroll_value:
	.byte	0

	
cheat_used:
	.byte	0
sprites_game_level_1_file:
	.asciz	"sprites_game_level_1.bin"
sprites_game_intro_file:
	.asciz	"sprites_game_intro.bin"
tiles_title_244000_file:
	.asciz	"tiles_title_244000.bin"
tiles_title_24a000_file:
	.asciz	"tiles_title_24a000.bin"
tiles_game_intro_24a000_file:
	.asciz	"tiles_game_intro_24a000.bin"
tiles_highs_24a000_file:
	.asciz	"tiles_highs_24a000.bin"
tiles_level_1_24a000_file:
	.asciz	"tiles_level_1_24a000.bin"
dudes_pics_files:
	.asciz	"dudes.bin"
rom_file:
	.asciz	"bad_dudes.bin"
dosname:
	.asciz	"dos.library"
graphicsname:
	.asciz	"graphics.library"
floppy_file:
	.asciz	"floppy"
temp_filename_buffer:
	ds.b	255
_end_of_ng_code:
		
  

	.align 2



	.ifndef	RELEASE
	* easier to debug game to have memory aligned on 0x10000

	.ifne	OPT_ENABLE_LOGGING
	.section	.bss
	.ascii	"TILE"
tile_log_table_244000:
	* 16 cluts, 2048 tiles
	* a lot of combinations aren't used (fortunately!)
	.skip	0x8000
tile_log_table_24a000:		| make sure it's contiguous to prev table
	* 16 cluts, 2048 tiles
	* a lot of combinations aren't used (fortunately!)
	.skip	0x8000
tile_log_table_24d000:		| make sure it's contiguous to prev table
	* 16 cluts, 2048 tiles
	* a lot of combinations aren't used (fortunately!)
	.skip	0x8000
sprite_log_table_ffc000:
	* 16 cluts, 4096 tiles
	* a lot of combinations aren't used (fortunately!)
	.skip	0x10000

tile_log_table_end:
	.endif
	.endif
	
public_memory_current_ptr:
	.long	0
chip_memory_current_ptr:
	.long	0

	* format of the file is first palette (32 bytes)
	* then main tile table that points to tile cluts, .. and
	* so on. It is readable in the tiles_0.68k file which is
	* pre-assembled so several tile files can be loaded depending
	* on the game phase
tiles_244000:		| address 0x244000
	.long	0
tiles_palette_24a000:		| address 0x24A000
	.long	0
tiles_palette_24d000:		| address 0x24D000
	.long	0
dude_pics:
	.long	0
sprites_memory:
	.long	0
	
tile_data_24a000:
	.long	0
tile_data_244000:
	.long	0
nb_tile_planes_24a000:
	.word	0
nb_tile_colors_24a000:
	.word	0
letters_colors:
	.long	0
sprite_table_base:
	.long	0
tile_data_24d000:
	.long	0
	
	.ascii	"CODE_END"


	.section	.datachip


.macro	DECL_BITPLANES	bpoff_start,nb_planes
	.set	bpoff,\bpoff_start
	.rept	\nb_planes
	dc.w  bplpt+bpoff,0
	dc.w  bplpt+bpoff+2,0
	.set	bpoff,bpoff+4
	.endr
	.endm



.macro	DECL_COLOR_BANK	bankno
	.word	bplcon3,BASE_BPLCON3_VALUE+(\bankno<<13)
	.endm
	
.macro	DECL_COLORS	offset,nb_colors
	.set	colidx,\offset
	.rept	\nb_colors
	dc.w	color+(colidx*2),0
	.set	colidx,colidx+1
	.endr
	.endm

.macro	DECL_SPRITES
	.rept	16
	* 2 slots
	.word	0x1FE,0
    .endr
	.endm

blank_sound:
	ds.l	4
	
blank_sprite:
	.skip	8
	
debug_copperlist:
	dc.w	bplcon0,0x200
	dc.w	color
debug_color:
	dc.w	0
	dc.l	-2
	



	
	* intro copperlist
intro_copperlist:
	* all sprites have the same palette no need to specify odd or even
	* on color bank 1
	
	DECL_COLOR_BANK	1
	* black color sprites
	DECL_COLORS	0,32

bitplanes_intro:
	DECL_BITPLANES	0,NB_PLAYFIELD_PLANES

	.word	bplcon1
fine_x_scroll_value:
	.word	0

intro_sprites:
	DECL_SPRITES


	DECL_COLOR_BANK 0
intro_palette:
	DECL_COLORS	0,32
	* now set color bank 1
	DECL_COLOR_BANK	1
sprites_palette:
dudes_palette:
	DECL_COLORS	0,24
letters_palette:
	DECL_COLORS	24,8
	
	* mid-line wait & extra interrupt
	.word	0x8001,0xFFFE
intro_intreq_block:
	* now wait some lines until we're sure bitmap only contains
	* non-black: we can set color 0 to light blue now
	.word	 intreq,0x8014  | call copper interrupt in the middle of a frame, also flag so copper interrupt knows that we're going to call copper int


	
	* pal limit
    .word  0xFFCF,0xFFFE       | PAL wait
	.word	 intreq,0x8010	| no bobs from now on, get more drawing time

	
    *.word  0x1401,0xFFFE		| wait more lines to set to black (big holes!)
	
    *.word   0x1C01,0xFFFE
	
 	*.word	beampos,0xFFFE
    .long    -2					
	.ascii	"ENDCPLST"
	
	

	.section	.bsspublic

*	.skip	0x10000
*stack_top:

public_memory_block:
	.skip	TOTAL_PUBLIC_MEMORY_SIZE
	

	
	* aligning on 8 bytes so .align will work
	* in the next datachip sections
	.align	8
	
		.section .bsschip
background_restore_buffer:
	.skip	RESTORE_SCREEN_SIZE

chip_memory_block:
	.skip	TOTAL_CHIP_MEMORY_SIZE
	
		
fg_screen_buffer_1:
	.skip	SCREEN_SIZE
	.skip	NB_BYTES_PER_ROW*12*3
	.skip	8
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING
fg_screen_buffer_2:
	.skip	SCREEN_SIZE
	.skip	NB_BYTES_PER_ROW*12*3
	.skip	8
	.endif


		