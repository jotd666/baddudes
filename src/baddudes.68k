	
	.global		baddudes_reset
	.global		baddudes_irq
	.ifdef		__amiga__
	.include	"baddudes_ram.68k"
	.endif
	.align	2

	.include 	"baddudes.inc"
	
	.macro	ROM_JUMP	address
	move.l	rom_base,-(a7)
	add.l	#\address,(a7)
	rts
	.endm
	
	
	
baddudes_reset:
	move.l	rom_base,a0
	move.l	ram_base,a1
	sub.l	#0xFF8000,a1	| arcade RAM base
	move.l	a1,d1
	
	* change original RAM locations to valid locations for the current machine
	lea		ram_relocs(pc),a2
0:
	move.l	(a2)+,d0
	jmi		1f
	add.l	d1,(a0,d0.l)
	jra		0b
1:
	* relocate the program where it's loaded using pre-computed reloc table
	* generated by my other "gamereloc" project: https://github.com/jotd666/GameRelocs

	lea	rom_relocs(pc),a0
	move.l	rom_base(pc),d1
	move.l	d1,a1
0:
	move.l	(a0)+,d0
	jeq		1f
	cmp.l	#0x100,d0
	jcs		0b				| skip zero page relocs, no need for them
	add.l	d1,(a1,d0.l)	| relocate
	jra		0b 
1:
	* now manual patches
	tst.b	invincible_flag
	jeq		0f
	move.l	rom_base,a1
	add.l	#0x15fbe,a1
	move.b	#0x60,(a1)		| turn off collision detection player 1
	move.l	rom_base,a1
	add.l	#0x15fd6,a1
	move.b	#0x60,(a1)		| turn off collision detection player 2
0:
	tst.b	superpowered_blows_flag
	jeq		0f
	move.l	rom_base,a1
	add.l	#0x16a82,a1
	move.l	#0x4E714EB9,(a1)+
	move.l	#make_superpowered,(a1)
0:
	move.b	start_level,d0
	jeq		0f
	addq	#1,d0
	move.l	rom_base,a1
	move.b	d0,(0x01c55,a1)
0:
	* then auto patches
	lea		patchlist,a0
	move.l	rom_base,a1
	jbsr	apply_patchlist
	* jump to rom start

	
	* this is an empty patchlist in release, allows to skip parts
	* in original code to save time debugging further parts
	.ifndef	RELEASE
	lea		debug_patchlist,a0
	move.l	rom_base,a1
	jbsr	apply_patchlist
	.endif
	* this is to help our poor amiga to do faster operations
	.ifdef	__amiga__
	lea		amiga_specific_patchlist,a0
	move.l	rom_base,a1
	jbsr	apply_patchlist
	.endif
	
	* install traps used by short JMP & JSR
	* allows to relocate the code anywhere in RAM
	* (including fastmem on amiga)
	
	lea		trap_0_jsr(pc),a0
	moveq	#0,d0
	jbsr	osd_install_trap
	lea		trap_1_jmp(pc),a0
	moveq	#1,d0
	jbsr	osd_install_trap
	
	ROM_JUMP		0x13dc
	
	
	.ifdef	__amiga__
display_object_hook_028c6:
	* original code
	MOVEQ	#0,D4
	MOVE.W	6(A0),D4	| composite sprite type * 4
	* now decode A0 sprite structure to tell the amiga part that
	* the displayed sprite is at coords X,Y with width and height,
	* so erasing the sprite is way easier and also much faster
	* (well not for all objects, as small objects like ninja stars and
	* nails or also flat horizontal objects don't need 16x16 erase)
	* the ideal code would have 2 modes: if small object (height < 16)
	* then use normal erase, else use block erase
	jbra	osd_object_displayed
	.endif
	
* emulate JSR from trap. Tricky, specially with reentrancy constraint
* (if code below is interrupted by another part which performs the same
* emu jsr, then it would be catastrophic as "jsr_address" would be overwritten)

trap_0_jsr:
	* first, block interrupts, as using jsr address is not reentrant
	move.w	#0x2700,SR
	move.l	a0,-(a7)
	* save original SR & return address
	lea	previous_sr(pc),a0
	move.w	(4,a7),(a0)
	move.w	#0x2700,(4,a7)	| interrupts off after RTE
	lea	jsr_address(pc),a0
	move.l	6(a7),(a0)
	move.l	(a7)+,a0

	pea	afterrte(pc)
	move.l	(A7),6(A7)	| modify RTE return address
	addq.l	#4,a7
	rte
afterrte:
	* we recovered from RTE, SR is 0x2700
	move.l	jsr_address(pc),-(a7)
	addq.l	#2,(a7)		| skip word

	subq.l	#4,a7
	move.l	a0,-(a7)
	move.l	jsr_address(pc),a0
    

	move.w	(a0),a0     | get contents of this jsr address (WORD!!)
	add.l	rom_base,a0	| relocation offset
	
	move.l	a0,4(a7)	| position this address
	move.l	(a7)+,a0
	* restore SR, re-enable interrupts now that jsr_address has been used
	move.w	d0,-(a7)
	move.w	previous_sr(pc),d0
	move.w	d0,sr
	move.w	(a7)+,d0		| original program must run in supervisor else crash !!
	rts
	

* emulate short JMP from TRAP: this is just tricky	
trap_1_jmp:
	movem.l	d0/a0,-(a7)
	move.l	(10,a7),a0	| return address
	moveq	#0,d0
	move.w	(a0),d0		| destination
	add.l	rom_base,d0	| relocated!
	move.l	d0,(10,a7)	| replace return address
	movem.l	(a7)+,d0/a0
	rte
	
baddudes_irq:
	move.l	rom_base,-(a7)
	add.l	#0x00384,(a7)
	rts
	
	
RTS_OPCODE = 0x4E75
JMP_OPCODE = 0x4EF9
JSR_OPCODE = 0x4EB9
LEA_OPCODE = 0x41F9

	.macro	PL_START
	.endm
	.macro	PL_END
	.word	-1
	.endm
	.macro	PL_I  offset
	.word	0x8000
	.long	\offset
	.endm
	.macro	PL_NOP    offset,nb_nops
	.word	0x8001
	.long	\offset
	.word	\nb_nops
	.endm
	.macro	PL_PS    offset,func
	.word	0x8002
	.long	\offset,\func
	.endm
	.macro	PL_PSS    offset,func,nb_nops
	.word	0x8003
	.long	\offset
	.word	\nb_nops
	.long	\func
	.endm
	.macro	PL_S    offset,skip
	.word	0x8004
	.long	\offset
	.word	\skip
	.endm
	.macro	PL_L    offset,value
	.word	0x8005
	.long	\offset
	.long	\value
	.endm
	.macro	PL_W    offset,value
	.word	0x8006
	.long	\offset
	.word	\value
	.endm
	.macro	PL_B    offset,value
	.word	0x8007
	.long	\offset
	.word	\value
	.endm
	.macro	PL_R    offset
	.word	0x8008
	.long	\offset
	.endm
	.macro	PL_P    offset,func
	.word	0x8009
	.long	\offset,\func
	.endm
	.macro	PL_PR    offset,func
	.word	0x800A
	.long	\offset,\func
	.endm
	.macro	PL_PSR    offset,func
	.word	0x800B
	.long	\offset,\func
	.endm
	.macro	PL_PLEAR_0    offset,func
	.word	0x800C
	.long	\offset,\func
	.endm
	.macro	PL_PLEAR_1    offset,func
	.word	0x800D
	.long	\offset,\func
	.endm
	.macro	PL_PLEAR_2    offset,func
	.word	0x800E
	.long	\offset,\func
	.endm
	.macro	PL_PLEAR_3    offset,func
	.word	0x800F
	.long	\offset,\func
	.endm
	.macro	PL_PLEAR_4    offset,func
	.word	0x8010
	.long	\offset,\func
	.endm
	.macro	PL_PLEAR_5    offset,func
	.word	0x8011
	.long	\offset,\func
	.endm
	.macro	PL_PLEAR_6    offset,func
	.word	0x8012
	.long	\offset,\func
	.endm


* < A0: patchlist
* < A1: address
apply_patchlist:
	movem.l	d0-d7/a2-a6,-(a7)
	lea	patch_table(pc),a2
0:
	move.w	(a0)+,d0
	cmp.w	#-1,d0
	jeq		10f
	and.w	#0xFF,d0
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0)+,a3
	add.l	a1,a3
	move.l	(a2,d0.w),a4
	jsr		(a4)
	jra		0b
10:
	jbsr	osd_flush_caches
	movem.l	(a7)+,d0-d7/a2-a6
	rts

patch_table:
	.long	do_PL_I   | offset
	.long	do_PL_NOP | offset,nb_nops
	.long	do_PL_PS  | offset,func
	.long	do_PL_PSS | offset,func,nb_nops
	.long	do_PL_S   | offset,skip
	.long	do_PL_L   | offset,value
	.long	do_PL_W   | offset,value
	.long	do_PL_B   | offset,value
	.long	do_PL_R   | offset
	.long	do_PL_P   | offset,func
	.long	do_PL_PR  | offset,func
	.long	do_PL_PSR | offset,func
	.long	do_PL_PLEAR_0
	.long	do_PL_PLEAR_1
	.long	do_PL_PLEAR_2
	.long	do_PL_PLEAR_3
	.long	do_PL_PLEAR_4
	.long	do_PL_PLEAR_5
	.long	do_PL_PLEAR_6

	
do_PL_I:
	move.w	#0x4AFC,(a3)
	rts

do_PL_NOP:
	move.w	(a0)+,d0
	lsr.w	#1,d0
	subq	#1,d0
0:
	move.w	#0x4E71,(a3)+
	dbf		d0,0b
	rts
	
do_PL_PS:
	move.w	#JSR_OPCODE,(a3)+
	move.l	(a0)+,(a3)
	rts
	
do_PL_P:
	move.w	#JMP_OPCODE,(a3)+
	move.l	(a0)+,(a3)
	rts
	
do_PL_PSS:
	jbsr	do_PL_NOP
	move.w	#JSR_OPCODE,(a3)+
	move.l	(a0)+,(a3)
	rts
	
do_PL_S:
	move.w	#0x6000,(a3)+
	move.w	(a0)+,(a3)
	rts
	
do_PL_L:
	move.l	(a0)+,(a3)
	rts
	
do_PL_W:	
	move.w	(a0)+,(a3)
	rts
	
do_PL_B:	
	move.w	(a0)+,d0
	move.b	d0,(a3)
	rts

do_PL_R:
	move.w	#RTS_OPCODE,(a3)
	rts
	
do_PL_PSR:
	move.w	#JSR_OPCODE,(a3)+
	move.l	(a0)+,d0
	add.l	rom_base,d0
	move.l	d0,(a3)
	rts
	
do_PL_PR:
	move.w	#JMP_OPCODE,(a3)+
	move.l	(a0)+,d0
	add.l	rom_base,d0
	move.l	d0,(a3)
	rts
	
* could have done a macro for this but seriously...
do_PL_PLEAR_0:
	moveq	#0,d0	| rebuild 4xF9 opcode from dest register
	jra 	do_plear
do_PL_PLEAR_1:
	moveq	#1,d0	| rebuild 4xF9 opcode from dest register
	jra 	do_plear
do_PL_PLEAR_2:
	moveq	#2,d0	| rebuild 4xF9 opcode from dest register
	jra 	do_plear
do_PL_PLEAR_3:
	moveq	#3,d0	| rebuild 4xF9 opcode from dest register
	jra 	do_plear
do_PL_PLEAR_4:
	moveq	#4,d0	| rebuild 4xF9 opcode from dest register
	jra 	do_plear
do_PL_PLEAR_5:
	moveq	#5,d0	| rebuild 4xF9 opcode from dest register
	jra 	do_plear
do_PL_PLEAR_6:
	moveq	#6,d0	| rebuild 4xF9 opcode from dest register
do_plear:
	add.w	d0,d0
	lsl.w	#8,d0
	add.w	#LEA_OPCODE,d0
	move.w	d0,(a3)+
	move.l	(a0)+,d0
	add.l	rom_base,d0
	move.l	d0,(a3)+
	rts
	




****************************
***** gernated patches *****
****************************

	.include	"patchlist.68k"

**************************
***** manual patches *****
**************************

make_superpowered:
    * more than enough to kill boss with 1 or 2 blows
	* and mid-stage boss with 1 blow
	MOVE.W	#0x1000,D0
	ADD.W	D0,36(A0)  |  set blow power to mega power!!
	rts
	
	.ifdef	__amiga__
amiga_specific_patchlist:
	PL_START
	PL_PS	0x28C6,display_object_hook_028c6
	PL_END
	.endif
	
	.ifndef	RELEASE
debug_patchlist:
	PL_START
	.ifne	OPT_SKIP_TITLE
	PL_NOP	0x08298,4
	PL_NOP	0x082be,4
	PL_NOP	0x08354,4
	.endif
	.ifne	OPT_SKIP_RONNIE_THANKS
	PL_B	0x1b3e8,0x60
	.endif
	PL_END
	.endif

	.macro	WRITE_WORD_AND_PLUS
	jbsr	osd_write_word
	addq	#2,a6
	.endm
	
	.macro	WRITE_LONG_AND_PLUS
	jbsr	osd_write_long
	addq	#4,a6
	.endm
	
videoram_write_062ae:
	STORE_REGS
	exg		a6,a1
	MOVE.W	(A0),D7
	jbsr	osd_write_word
	MOVE.L	4(A0),D2
	exg		a6,a1
	RESTORE_REGS
	rts

videoram_write_0e0ac:
	ADDI.W	#0x1030,D0
	STORE_REGS
	exg	a3,a6
	MOVE.W	D0,D7
	WRITE_WORD_AND_PLUS
	exg	a3,a6
	RESTORE_REGS
	rts
	
videoram_write_062e2:
	STORE_REGS
	exg		a6,a1
	MOVE.W	4(A0),d7
	addq	#2,a6
	jbsr	osd_write_word
	exg		a6,a1
	RESTORE_REGS
	rts

videoram_write_loop_0e07e:
	STORE_REGS
	exg	a4,a6
0:	
	MOVE.W	(A3)+,d7
	WRITE_WORD_AND_PLUS
	DBF	D0,0b
	exg	a4,a6
	RESTORE_REGS
	RTS

set_game_intro_context_084c4:
	LEA	0x24A000,A1		| original code
	move.w	#CTX_GAME_INTRO,d0
	jbsr	osd_set_context		| just to change palette
	rts
	
videoram_write_loop_d0_d1:
	STORE_REGS
	exg		a6,a0
0:
	MOVE.L	D0,D7
	WRITE_WORD_AND_PLUS
	DBF	D1,0b
	exg		a6,a0
	RESTORE_REGS
	rts

videoram_write_08848:
	STORE_REGS
	exg		a6,a1
	moveq	#0,d7
	MOVE.B	(A0)+,d7
	WRITE_WORD_AND_PLUS
	exg		a6,a1
	RESTORE_REGS
	rts
	
videoram_write_loop_d1_d0:
	STORE_REGS
	exg		a6,a0
0:
	MOVE.L	D1,D7
	WRITE_WORD_AND_PLUS
	DBF	D0,0b
	exg		a6,a0
	RESTORE_REGS
	rts
	
* this routine heavily writes to A2 there and there
* so I copied it and adapted it instead of patching it
* a million times
display_scores_loop_07b9a:
	exg		a6,a2
	MOVE.W	D2,D7
	WRITE_WORD_AND_PLUS		
	ADDI.W	#0x0030,D1		
	MOVE.W	D1,D7
	jbsr	osd_write_word
	addq	#4,a6		
	MOVE.W	D0,D1			
	SUBQ.L	#1,D1			
	LSL.W	#3,D1
	exg		a1,a6
	LEA	0x00ffa8fe,A6
	jbsr	osd_real_ram_address
	exg		a1,a6
	ADDA.L	D1,A1
	.rept	3
	moveq	#0,d7
	move.b	(a1)+,d7
	WRITE_WORD_AND_PLUS
	.endr	
	ADDq	#2,A6	
	ADDq	#1,A1	
	MOVEQ	#2,D3		
	MOVEQ	#0,D4		
lb_07bd8:
	MOVE.B	(A1)+,D1	
	EXT.W	D1			
	MOVE.W	D1,D2		
	LSR.W	#4,D1		
	ANDI.W	#0x000f,D1	
	TST.W	D4			
	BNE.W	lb_07bfa	
	TST.W	D1			
	BNE.W	lb_07bfa	
	moveq	#0,d7
	WRITE_WORD_AND_PLUS
	jra	lb_07c02    
lb_07bfa:
	MOVEQ	#1,D4		
	ADDI.W	#0x0030,D1
	move.w	d1,d7	
	WRITE_WORD_AND_PLUS
lb_07c02:
	ANDI.W	#0x000f,D2	
	TST.W	D4			
	BNE.W	lb_07c1c	
	TST.W	D2			
	BNE.W	lb_07c1c	
	moveq	#0,d7
	WRITE_WORD_AND_PLUS
	jra	lb_07c24
lb_07c1c:
	MOVEQ	#1,D4			
	ADDI.W	#0x0030,D2		
	move.w	D2,d7	
	WRITE_WORD_AND_PLUS		
lb_07c24:
	DBF	D3,lb_07bd8		
	ADDq	#0x00000002,A6		
	MOVE.B	(A1)+,D1	
	EXT.W	D1			
	CMPI.W	#0x0008,D1	
	jne		lb_07c44	
	MOVE.W	#0x007e,D1	
	jra	lb_07c4c					
lb_07c44:
	ANDI.W	#0x000f,D1		
	ADDI.W	#0x0030,D1		
lb_07c4c:
	move.w	d1,d7	
	WRITE_WORD_AND_PLUS
	exg		a6,a2
	RTS			


copy_highscore_tiles_loop_09592:
	* changing game context (palette changes)
	STORE_REGS
	exg	d0,d7
	move.w	#CTX_HIGH_SCORE,d0
	jbsr	osd_set_context
	exg	d0,d7
	exg	a4,a6
lb_09592:
	MOVE.W	(A5)+,d7
	WRITE_WORD_AND_PLUS
	DBF	D0,lb_09592
	exg	a4,a6
	RESTORE_REGS
	RTS
	
set_scroll_values:
	STORE_REGS
	exg	a0,a6
	move.l	d0,d7
0:
	jbsr	osd_write_long
	addq	#4,a6
	DBF	D1,0b
	exg	a0,a6
	RESTORE_REGS
	rts
	
enable_interrupts_01476:
	jbsr	osd_enable_interrupts
	rts
	
set_palette_a2:
	STORE_REGS
	exg	a0,a6
0:
	move.l	(a2)+,d7
	jbsr	osd_write_long
	dbf	d0,0b
	
	exg	a0,a6
	RESTORE_REGS
	rts
	
write_word_a0plus_to_0030c010:
	STORE_REGS
	move.w	(a0)+,d7
	lea	0x0030c010,a6
	jbsr	osd_write_word
	RESTORE_REGS
	rts
	
test_input_bit_7:
    *'BTST', 'arguments': ['#7', 'system_inputs_0030c003']
    jbsr    osd_break
    rts

* happens on game over!
test_input_bit_d1:
    * btst D1,system_inputs_0030c003
    jbsr    osd_break
    nop
    rts

copy_to_tile_0651e:
copy_to_tile_064f6:
	ADDA.W	D7,A3		| D7 is < 0x1FF
	STORE_REGS
	exg		a6,a0
	MOVE.W	(A3),d7
	jbsr	osd_write_word
	exg		a6,a0
	RESTORE_REGS
	MOVE.L	A0,D3
	rts
	
copy_memory_to_tiles_0837c:
	STORE_REGS
	* original game copies 0x800 tiles but this isn't required
	* apparently?? we'll see
	MOVE.W	#0x7F,D0
	exg		a6,a1
lb_08380:
	MOVE.L	(A0)+,d7
	jbsr	osd_write_long
	addq.w	#4,a6
	DBF	D0,lb_08380
	exg		a6,a1
	RESTORE_REGS
	RTS
	

clear_sound:
    *;01502: 'address': 5378, 'size': 6, 'instruction': 'CLR.W', 'arguments': ['sound_0030c010']
    rts

test_mcu_reply:
    *'address': 38810, 'size': 6, 'instruction': 'TST.W', 'arguments': ['mcu_reply_0030c008']
    jbsr    osd_break
    nop
    nop
    rts

* not sure when it happens...
set_sr_01482:
set_sr_00596:
set_sr_0037e:
	move.w	#0x2300,SR
	rts
	
* copy angry baddudes + title pic to layer when credit is inserted
copy_tiles_099f0:
	STORE_REGS
	exg	a6,a3
	lea		video_ram_244000,a2	| direct read from video ram
0:
	MOVE.W	(A2)+,d7
	WRITE_WORD_AND_PLUS		| using LONG doesn't speed it up, on the contrary
	CMPA.L	#video_ram_244000+0x800,A2
	BNE.S	0b
	exg	a6,a3
	RESTORE_REGS
	RTS
	
display_lives_0e122:
	STORE_REGS
	exg	a6,a4
	SUBQ.W	#1,D1	
	BMI.S	lb_0e12e
lb_0e126:
	MOVE.W	#0x0072,d7	| head counting lives
	WRITE_WORD_AND_PLUS
	DBF	D1,lb_0e126
lb_0e12e:
	moveq	#0,d7		| blank after lives
	jbsr	osd_write_word
lb_0e130:
	exg	a6,a4
	RESTORE_REGS
	RTS
	
copy_tiles_06b7a:
copy_tiles_06bbe:
	STORE_REGS
	exg		a6,a0
0:
	MOVE.W	(A1),d7
	jbsr	osd_write_word
	ADD.W	#0x20,A1
	ADD.W	#0x20,A6
	DBF	D0,0b
	exg		a6,a0
	RESTORE_REGS
	rts
	
* < D0: sound code to play
play_sound_0def0:
	rts
	
set_game_context_1ac6:
	* original code
	STORE_REGS
	lea	0x00ff8216,a6
	jbsr	osd_real_ram_address
	BCLR	#5,(a6)
	* patch
	move.w	#CTX_GAME,d0
	jbsr	osd_set_context
	RESTORE_REGS
	rts
	
write_to_tiles_0e30e:
	STORE_REGS
	exg	a6,a0
0:
	MOVE.W	D0,D7
	jbsr	osd_write_word
	LEA	64(A6),A6
	dbf		D1,0b
	exg	a6,a0
	RESTORE_REGS
	RTS
	
write_to_tile_0_083ac:
	STORE_REGS
	move.l	a1,a6
	MOVE.W	D1,D7                  | MOVE.W	D1,(A1)		
	jbsr	osd_write_word         | ADDI.W	#0x0001,D1	
	ADD.W	#1,D7                  | MOVE.W	D1,64(A1)	
	lea	(64,a1),a6                 | ADDI.W	#0x0001,D1	
	jbsr	osd_write_word         | MOVE.W	D1,-2(A1)	
	ADDq.W	#1,D7                  | ADDI.W	#0x0001,D1
	cmp.l	#0x244000,a1
	jeq		0f				| avoid original write to 23FFFE error
	lea	(-2,a1),a6                 | ADDI.W	#0x0001,D1	
	jbsr	osd_write_word
0:
	ADDq.W	#1,D7                  | ADDI.W	#0x0001,D1
	lea	(62,a1),a6                 |     MOVE.W	D1,62(A1)           	
	jbsr	osd_write_word
	move.w	d7,d1
	RESTORE_REGS
	rts
	
set_video_attribute_083ce:
	STORE_REGS
	LEA	video_ram_244000+0x100,A0
	lea	0x244100,a6
lb_083d4:
	MOVE.W	(A0)+,D7		
	ANDI.W	#0x0fff,D7
	ORI.W	#0x3000,D7
	WRITE_WORD_AND_PLUS
	CMPA.L	#0x244300,A6
	BNE.S	lb_083d4
	RESTORE_REGS
	rts

write_ninja_message_0834A:
	ANDI.W	#0x00ff,D0
	exg		a1,a6
	STORE_REGS
	move.w	d0,d7
	jbsr	osd_write_word
	RESTORE_REGS
	exg		a1,a6
	addq	#2,a1
	rts
	
copy_to_tile_0_01fa2:
	STORE_REGS
	exg		a6,a1
lb_01fa2:
	CMPI.B	#0xfe,(A0)		
	BNE.W	lb_01fba		
	ADDA.W	#0x40,A2	
	MOVEA.L	A2,A6			
	ADDQ	#1,A0	
	BRA.S	lb_01fa2		
lb_01fba:
* original code (adapted). osd_write_byte doesn't seem to work
* properly, so in that case a rewrite using osd_write_word is faster
* and at least it works (used when displaying Data East copyright in the
* title screen)
*	MOVE.B	D1,d7
*	jbsr	osd_write_byte
*	addq	#1,a6
*	MOVE.B	(A0)+,d7
*	jbsr	osd_write_byte
*	addq	#1,a6

	MOVE.B	D1,d7
	ror.w	#8,d7
	move.b	(a0)+,d7 
	WRITE_WORD_AND_PLUS
	DBF	D0,lb_01fa2
	exg		a6,a1
	RESTORE_REGS
	RTS		
	
clear_8x8_tile_layer_1b322:
	LEA	0x244000,A6
	MOVEQ	#0,D7
lb_1b32a:
	WRITE_WORD_AND_PLUS
	CMPA.L	#0x00246000,A6
	BNE.S	lb_1b32a
	RTS			
clear_24a000_tile_layer_1b336:
	LEA	0x24A000,A6
	MOVEQ	#0,D7	
lb_1b33e:
	WRITE_WORD_AND_PLUS
	CMPA.L	#0x0024a800,A6
	BNE.S	lb_1b33e
	RTS
clear_24d000_tile_layer_1b34a:
	LEA	0x24d000,A6
	MOVEQ	#0,D7
lb_1b352:
	WRITE_WORD_AND_PLUS
	CMPA.L	#0x0024d800,A6
	BNE.S	lb_1b352
	RTS
	
* happens on game over
write_244xxx_layer_0819c:
	STORE_REGS
	exg		a6,a3
	move	d1,d7
	WRITE_WORD_AND_PLUS
	MOVE.B	3(A1),D7
	ANDI.W	#0x000f,D7		
	ADDI.W	#0x0030,D7
	jbsr	osd_write_word	
	exg		a6,a3
	RESTORE_REGS
	rts
	
intro_context_01a24:
	move.w	#CTX_INTRO,d0
	jbsr 	osd_set_context
	ROM_JUMP	0x1cd8	| clear_pretty_much_all_video

before_end_sequence_01bac:
	move.w	#CTX_END_SEQUENCE_1,d0
	jbsr 	osd_set_context
	ROM_JUMP	0x1cd8	| clear_pretty_much_all_video
	
switch_to_ending_2_1bb3e:
	move.w	#CTX_END_SEQUENCE_2,d0
	jbsr 	osd_set_context
	MOVE.W	#0x000f,D0
	MOVE.W	#0x000f,D1
	rts
	
copy_to_8x8_tiles_1b5b0:
	STORE_REGS
	exg		a6,a3
	move	d0,d7
0:
	WRITE_WORD_AND_PLUS
	CMPA.L	#0x00242040,A6
	BNE.S	0b
	exg		a6,a3
	RESTORE_REGS
	RTS				
	
videoram_write_021e8:
	STORE_REGS
	exg		a6,a3
0:
	MOVE.W	(A4)+,D7
	WRITE_WORD_AND_PLUS
	DBF	D3,0b
	exg		a6,a3
	RESTORE_REGS
	RTS				

videoram_write_0891c:
	STORE_REGS
	exg		a6,a3
	exg		d1,d7
	WRITE_WORD_AND_PLUS		| 0819c: 36c1
	MOVE.B	3(A1),D1		| 0819e: 12290003
	ANDI.W	#0xf,D1		| 081a2: 0241000f
	ADDI.W	#0x30,D1		| 081a6: 06410030
	jbsr	osd_write_word	| 081aa: 3681
	exg		a6,a3
	exg		d1,d7
	RESTORE_REGS
	RTS						| 081ac: 4e75
	

reset_vertical_scroll_1b722:
	STORE_REGS
	exg		A6,A1
	move	d0,d7
0:
	WRITE_WORD_AND_PLUS
	CMPA.L	#0x00242040,A6
	BNE.S	0b
	exg		A6,A1
	RESTORE_REGS
	rts
	
videoram_write_06dea:
videoram_write_06da6:
videoram_write_06c82:
	STORE_REGS
	exg		a6,a0
0:
	MOVE.W	(A1),D7	
	jbsr	osd_write_word
	ADD.W	#0x20,A1	
	ADD.W	#0x20,A6	
	DBF	D0,0b
	exg		a6,a0
	RESTORE_REGS
	RTS				
	
videoram_write_09aa6:
	STORE_REGS
	exg		a6,a2
	MOVE.L	D0,D7
0:
	WRITE_WORD_AND_PLUS
	CMPA.L	#0x244740,A6
	BNE.S	0b
	exg		a6,a2
	RESTORE_REGS
	RTS				
	
videoram_write_0e3ba:
	STORE_REGS
	exg		a6,a0
0:
	MOVE.W	(A1)+,D7
	WRITE_WORD_AND_PLUS
	DBF	D4,0b
	exg		a6,a0
	RESTORE_REGS
	RTS				
	
videoram_clear_01ff8:
	STORE_REGS
	exg		a6,a1
	moveq	#0,d7
0:
	WRITE_WORD_AND_PLUS
	DBF	D1,0b
	exg		a6,a1
	RESTORE_REGS
	RTS				
	
videoram_write_01fca:
	STORE_REGS
	exg		a6,a1
0:
	MOVE.B	D1,d7
	ror.w	#8,d7
	move.b	(a0)+,d7 
	WRITE_WORD_AND_PLUS
	DBF	D0,0b
	exg		a6,a1
	RESTORE_REGS
	RTS				
	
write_to_tile_1bb8e:
	STORE_REGS
	exg	a2,a6
	LSL.W	#4,D2
	ADD.W	D1,D2
	MOVE.W	D2,D7
	WRITE_WORD_AND_PLUS
	exg	a0,a6
	RESTORE_REGS
	RTS
	
copy_to_palette_007be:
	STORE_REGS
	exg	a0,a6
0:
	MOVE.W	#0x000f,D1
1:
	MOVE.W	(A1)+,d7
	jbsr	osd_write_word
	DBF	D1,1b
	DBF	D0,0b
	exg	a0,a6
	RESTORE_REGS
	RTS
	
write_tile_244000_1bc78:
	STORE_REGS
	LEA	0(A1,D0.L),A1
	MOVE.W	D1,D7
	move.l	a1,a6
	jbsr	osd_write_word
	RESTORE_REGS
	RTS
	
copy_rom_to_video_1b310:
	move.w	d7,-(a7)
	exg		a6,a1
0:
    MOVE.W    (A2)+,d7
	WRITE_WORD_AND_PLUS
    SUBQ.W    #1,D1            
    BCC.S    0b
    SUBQ.W    #1,D0
    BCS.S    lb_1b320
    MOVE.W    #0x000f,D1
    BRA.S    0b
lb_1b320:
	exg		a6,a1
	move.w	(a7)+,d7
    RTS
	
	.macro	LEA_RELOC	address,reg
	lea		\address\().w,\reg
	add.l	rom_base,\reg
	.endm
	
leaw_256a:
	LSR.W	#6,D1			| 0256a: ec49
	LEA_RELOC	0x0254a,A2	| 0256c: 45f8254a
	rts
	
leaw_5b7c:
	LEA_RELOC	0x05b14,A3	| 05b7c: 47f85b14
	ADDA.L	D1,A3			| 05b80: d7c1
	rts
	
leaw_8016:
	LSL.W	#2,D1			| 08016: e549
	LEA_RELOC	0x07e74,A2	| 08018: 45f87e74
	rts
	
rom_relocs:
	.include "baddudes_relocs.68k"
	