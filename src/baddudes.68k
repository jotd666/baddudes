	
	.global		baddudes_reset
	.global		baddudes_irq
	.ifdef		__amiga__
	.include	"baddudes_ram.68k"
	.endif
	.align	2

baddudes_reset:
	move.l	rom_base,a0
	move.l	ram_base,a1
	sub.l	#0xFF8000,a1	| arcade RAM base
	move.l	a1,d1
	
	lea		ram_relocs(pc),a2
0:
	move.l	(a2)+,d0
	jmi		1f
	add.l	d1,(a0,d0.l)
	jra		0b
1:
	lea		patchlist,a0
	move.l	rom_base,a1
	jbsr	apply_patchlist
	* jump to rom start

	move.l	rom_base,-(a7)
	add.l	#0x13dc,(a7)
	rts
	
baddudes_irq:
	rts
	
	
	.macro	PL_START
	.endm
	.macro	PL_END
	.word	-1
	.endm
	.macro	PL_I  offset
	.word	0x8000
	.long	\offset
	.endm
	.macro	PL_NOP    offset,nb_nops
	.word	0x8001
	.long	\offset
	.word	\nb_nops
	.endm
	.macro	PL_PS    offset,func
	.word	0x8002
	.long	\offset,\func
	.endm
	.macro	PL_PSS    offset,func,nb_nops
	.word	0x8003
	.long	\offset
	.word	\nb_nops
	.long	\func
	.endm
	.macro	PL_S    offset,skip
	.word	0x8004
	.long	\offset
	.word	\skip
	.endm
	.macro	PL_L    offset,value
	.word	0x8005
	.long	\offset
	.long	\value
	.endm
	.macro	PL_W    offset,value
	.word	0x8006
	.long	\offset
	.word	\value
	.endm
	.macro	PL_B    offset,value
	.word	0x8007
	.long	\offset
	.word	\value
	.endm
	.macro	PL_R    offset
	.word	0x8008
	.long	\offset
	.endm


* < A0: patchlist
* < A1: address
apply_patchlist:
	movem.l	d0-d7/a2-a6,-(a7)
	lea	patch_table(pc),a2
0:
	move.w	(a0)+,d0
	cmp.w	#-1,d0
	jeq		10f
	and.w	#0xFF,d0
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0)+,a3
	move.l	(a2,d0.w),a4
	jsr		(a4)
	jra		0b
10:
	jbsr	osd_flush_caches
	movem.l	(a7)+,d0-d7/a2-a6
	rts

patch_table:
	.long	do_PL_I   | offset
	.long	do_PL_NOP | offset,nb_nops
	.long	do_PL_PS  | offset,func
	.long	do_PL_PSS | offset,func,nb_nops
	.long	do_PL_S   | offset,skip
	.long	do_PL_L   | offset,value
	.long	do_PL_W   | offset,value
	.long	do_PL_B   | offset,value
	.long	do_PL_R   | offset
	
do_PL_I:
	move.w	#0x4AFC,(a3)
	rts

do_PL_NOP:
	move.w	(a0)+,d0
	lsr.w	#1,d0
	subq	#1,d0
0:
	move.w	#0x4E71,(a3)+
	dbf		d0,0b
	rts
	
do_PL_PS:
	move.w	#0x4EB9,(a3)+
	move.l	(a0)+,(a3)+
	rts
	
do_PL_PSS:
	jbsr	do_PL_NOP
	move.w	#0x4EB9,(a3)+
	move.l	(a0)+,(a3)+
	rts
	
do_PL_S:
	move.w	#0x6000,(a3)+
	move.w	(a0)+,(a3)+
	rts
	
do_PL_L:
	move.l	(a0)+,(a3)
	rts
	
do_PL_W:	
	move.w	(a0)+,(a3)
	rts
	
do_PL_B:	
	move.w	(a0)+,d0
	move.b	d0,(a3)
	rts

do_PL_R:
	move.w	#0x4E75,(a3)
	rts
	
	.include	"patchlist.68k"

* manual patches

set_scroll_values:
	STORE_REGS
	exg	a0,a6
	move.l	d0,d7
0:
	jbsr	osd_write_long
	addq	#4,a6
	DBF	D1,0b
	exg	a0,a6
	RESTORE_REGS
	rts
	
enable_interrupts_01476:
	jbsr	osd_enable_interrupts
	rts
	
set_palette_a2:
	STORE_REGS
	exg	a0,a6
0:
	move.l	(a2)+,d7
	jbsr	osd_write_long
	dbf	d0,0b
	
	exg	a0,a6
	RESTORE_REGS
	rts
	
write_word_a0plus_to_0030c010:
	STORE_REGS
	move.w	(a0)+,d7
	lea	0x0030c010,a6
	jbsr	osd_write_word
	RESTORE_REGS
	rts
	
test_input_bit_7:
    *'BTST', 'arguments': ['#7', 'system_inputs_0030c003']
    jbsr    osd_break
    rts

test_input_bit_d1:
    * btst D1,system_inputs_0030c003
    jbsr    osd_break
    nop
    rts


clear_sound:
    *;01502: 'address': 5378, 'size': 6, 'instruction': 'CLR.W', 'arguments': ['sound_0030c010']
    rts

test_mcu_reply:
    *'address': 38810, 'size': 6, 'instruction': 'TST.W', 'arguments': ['mcu_reply_0030c008']
    jbsr    osd_break
    nop
    nop
    rts

copy_rom_to_video_1b310:
	move.w	d7,-(a7)
	exg		a6,a1
0:
    MOVE.W    (A2)+,d7
	jbsr	osd_write_byte
    SUBQ.W    #1,D1            
    BCC.S    0b
    SUBQ.W    #1,D0
    BCS.S    lb_1b320
    MOVE.W    #0x000f,D1
    BRA.S    0b
lb_1b320:
	exg		a6,a1
	move.w	(a7)+,d7
    RTS
	
